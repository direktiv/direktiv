// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: pkg/flow/grpc/protocol.proto

package grpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Flow_Instance_FullMethodName                    = "/direktiv_flow.Flow/Instance"
	Flow_InstanceStream_FullMethodName              = "/direktiv_flow.Flow/InstanceStream"
	Flow_Instances_FullMethodName                   = "/direktiv_flow.Flow/Instances"
	Flow_InstancesStream_FullMethodName             = "/direktiv_flow.Flow/InstancesStream"
	Flow_InstanceInput_FullMethodName               = "/direktiv_flow.Flow/InstanceInput"
	Flow_InstanceOutput_FullMethodName              = "/direktiv_flow.Flow/InstanceOutput"
	Flow_InstanceMetadata_FullMethodName            = "/direktiv_flow.Flow/InstanceMetadata"
	Flow_StartWorkflow_FullMethodName               = "/direktiv_flow.Flow/StartWorkflow"
	Flow_AwaitWorkflow_FullMethodName               = "/direktiv_flow.Flow/AwaitWorkflow"
	Flow_CancelInstance_FullMethodName              = "/direktiv_flow.Flow/CancelInstance"
	Flow_BroadcastCloudevent_FullMethodName         = "/direktiv_flow.Flow/BroadcastCloudevent"
	Flow_NamespaceVariable_FullMethodName           = "/direktiv_flow.Flow/NamespaceVariable"
	Flow_SetNamespaceVariableParcels_FullMethodName = "/direktiv_flow.Flow/SetNamespaceVariableParcels"
	Flow_WorkflowVariable_FullMethodName            = "/direktiv_flow.Flow/WorkflowVariable"
	Flow_SetWorkflowVariableParcels_FullMethodName  = "/direktiv_flow.Flow/SetWorkflowVariableParcels"
	Flow_InstanceVariable_FullMethodName            = "/direktiv_flow.Flow/InstanceVariable"
	Flow_SetInstanceVariableParcels_FullMethodName  = "/direktiv_flow.Flow/SetInstanceVariableParcels"
	Flow_JQ_FullMethodName                          = "/direktiv_flow.Flow/JQ"
	Flow_EventListeners_FullMethodName              = "/direktiv_flow.Flow/EventListeners"
	Flow_EventListenersStream_FullMethodName        = "/direktiv_flow.Flow/EventListenersStream"
	Flow_EventHistory_FullMethodName                = "/direktiv_flow.Flow/EventHistory"
	Flow_EventHistoryStream_FullMethodName          = "/direktiv_flow.Flow/EventHistoryStream"
	Flow_HistoricalEvent_FullMethodName             = "/direktiv_flow.Flow/HistoricalEvent"
	Flow_ReplayEvent_FullMethodName                 = "/direktiv_flow.Flow/ReplayEvent"
)

// FlowClient is the client API for Flow service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FlowClient interface {
	// instances.
	Instance(ctx context.Context, in *InstanceRequest, opts ...grpc.CallOption) (*InstanceResponse, error)
	InstanceStream(ctx context.Context, in *InstanceRequest, opts ...grpc.CallOption) (Flow_InstanceStreamClient, error)
	Instances(ctx context.Context, in *InstancesRequest, opts ...grpc.CallOption) (*InstancesResponse, error)
	InstancesStream(ctx context.Context, in *InstancesRequest, opts ...grpc.CallOption) (Flow_InstancesStreamClient, error)
	InstanceInput(ctx context.Context, in *InstanceInputRequest, opts ...grpc.CallOption) (*InstanceInputResponse, error)
	InstanceOutput(ctx context.Context, in *InstanceOutputRequest, opts ...grpc.CallOption) (*InstanceOutputResponse, error)
	InstanceMetadata(ctx context.Context, in *InstanceMetadataRequest, opts ...grpc.CallOption) (*InstanceMetadataResponse, error)
	// workflows.
	StartWorkflow(ctx context.Context, in *StartWorkflowRequest, opts ...grpc.CallOption) (*StartWorkflowResponse, error)
	AwaitWorkflow(ctx context.Context, in *AwaitWorkflowRequest, opts ...grpc.CallOption) (Flow_AwaitWorkflowClient, error)
	CancelInstance(ctx context.Context, in *CancelInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BroadcastCloudevent(ctx context.Context, in *BroadcastCloudeventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// variables.
	NamespaceVariable(ctx context.Context, in *NamespaceVariableRequest, opts ...grpc.CallOption) (*NamespaceVariableResponse, error)
	SetNamespaceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Flow_SetNamespaceVariableParcelsClient, error)
	WorkflowVariable(ctx context.Context, in *WorkflowVariableRequest, opts ...grpc.CallOption) (*WorkflowVariableResponse, error)
	SetWorkflowVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Flow_SetWorkflowVariableParcelsClient, error)
	InstanceVariable(ctx context.Context, in *InstanceVariableRequest, opts ...grpc.CallOption) (*InstanceVariableResponse, error)
	SetInstanceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Flow_SetInstanceVariableParcelsClient, error)
	JQ(ctx context.Context, in *JQRequest, opts ...grpc.CallOption) (*JQResponse, error)
	// events.
	EventListeners(ctx context.Context, in *EventListenersRequest, opts ...grpc.CallOption) (*EventListenersResponse, error)
	EventListenersStream(ctx context.Context, in *EventListenersRequest, opts ...grpc.CallOption) (Flow_EventListenersStreamClient, error)
	EventHistory(ctx context.Context, in *EventHistoryRequest, opts ...grpc.CallOption) (*EventHistoryResponse, error)
	EventHistoryStream(ctx context.Context, in *EventHistoryRequest, opts ...grpc.CallOption) (Flow_EventHistoryStreamClient, error)
	HistoricalEvent(ctx context.Context, in *HistoricalEventRequest, opts ...grpc.CallOption) (*HistoricalEventResponse, error)
	ReplayEvent(ctx context.Context, in *ReplayEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type flowClient struct {
	cc grpc.ClientConnInterface
}

func NewFlowClient(cc grpc.ClientConnInterface) FlowClient {
	return &flowClient{cc}
}

func (c *flowClient) Instance(ctx context.Context, in *InstanceRequest, opts ...grpc.CallOption) (*InstanceResponse, error) {
	out := new(InstanceResponse)
	err := c.cc.Invoke(ctx, Flow_Instance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InstanceStream(ctx context.Context, in *InstanceRequest, opts ...grpc.CallOption) (Flow_InstanceStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[0], Flow_InstanceStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowInstanceStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_InstanceStreamClient interface {
	Recv() (*InstanceResponse, error)
	grpc.ClientStream
}

type flowInstanceStreamClient struct {
	grpc.ClientStream
}

func (x *flowInstanceStreamClient) Recv() (*InstanceResponse, error) {
	m := new(InstanceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) Instances(ctx context.Context, in *InstancesRequest, opts ...grpc.CallOption) (*InstancesResponse, error) {
	out := new(InstancesResponse)
	err := c.cc.Invoke(ctx, Flow_Instances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InstancesStream(ctx context.Context, in *InstancesRequest, opts ...grpc.CallOption) (Flow_InstancesStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[1], Flow_InstancesStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowInstancesStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_InstancesStreamClient interface {
	Recv() (*InstancesResponse, error)
	grpc.ClientStream
}

type flowInstancesStreamClient struct {
	grpc.ClientStream
}

func (x *flowInstancesStreamClient) Recv() (*InstancesResponse, error) {
	m := new(InstancesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) InstanceInput(ctx context.Context, in *InstanceInputRequest, opts ...grpc.CallOption) (*InstanceInputResponse, error) {
	out := new(InstanceInputResponse)
	err := c.cc.Invoke(ctx, Flow_InstanceInput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InstanceOutput(ctx context.Context, in *InstanceOutputRequest, opts ...grpc.CallOption) (*InstanceOutputResponse, error) {
	out := new(InstanceOutputResponse)
	err := c.cc.Invoke(ctx, Flow_InstanceOutput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InstanceMetadata(ctx context.Context, in *InstanceMetadataRequest, opts ...grpc.CallOption) (*InstanceMetadataResponse, error) {
	out := new(InstanceMetadataResponse)
	err := c.cc.Invoke(ctx, Flow_InstanceMetadata_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) StartWorkflow(ctx context.Context, in *StartWorkflowRequest, opts ...grpc.CallOption) (*StartWorkflowResponse, error) {
	out := new(StartWorkflowResponse)
	err := c.cc.Invoke(ctx, Flow_StartWorkflow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) AwaitWorkflow(ctx context.Context, in *AwaitWorkflowRequest, opts ...grpc.CallOption) (Flow_AwaitWorkflowClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[2], Flow_AwaitWorkflow_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowAwaitWorkflowClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_AwaitWorkflowClient interface {
	Recv() (*AwaitWorkflowResponse, error)
	grpc.ClientStream
}

type flowAwaitWorkflowClient struct {
	grpc.ClientStream
}

func (x *flowAwaitWorkflowClient) Recv() (*AwaitWorkflowResponse, error) {
	m := new(AwaitWorkflowResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) CancelInstance(ctx context.Context, in *CancelInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_CancelInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) BroadcastCloudevent(ctx context.Context, in *BroadcastCloudeventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_BroadcastCloudevent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) NamespaceVariable(ctx context.Context, in *NamespaceVariableRequest, opts ...grpc.CallOption) (*NamespaceVariableResponse, error) {
	out := new(NamespaceVariableResponse)
	err := c.cc.Invoke(ctx, Flow_NamespaceVariable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) SetNamespaceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Flow_SetNamespaceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[3], Flow_SetNamespaceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowSetNamespaceVariableParcelsClient{stream}
	return x, nil
}

type Flow_SetNamespaceVariableParcelsClient interface {
	Send(*SetNamespaceVariableRequest) error
	CloseAndRecv() (*SetNamespaceVariableResponse, error)
	grpc.ClientStream
}

type flowSetNamespaceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *flowSetNamespaceVariableParcelsClient) Send(m *SetNamespaceVariableRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *flowSetNamespaceVariableParcelsClient) CloseAndRecv() (*SetNamespaceVariableResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetNamespaceVariableResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) WorkflowVariable(ctx context.Context, in *WorkflowVariableRequest, opts ...grpc.CallOption) (*WorkflowVariableResponse, error) {
	out := new(WorkflowVariableResponse)
	err := c.cc.Invoke(ctx, Flow_WorkflowVariable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) SetWorkflowVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Flow_SetWorkflowVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[4], Flow_SetWorkflowVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowSetWorkflowVariableParcelsClient{stream}
	return x, nil
}

type Flow_SetWorkflowVariableParcelsClient interface {
	Send(*SetWorkflowVariableRequest) error
	CloseAndRecv() (*SetWorkflowVariableResponse, error)
	grpc.ClientStream
}

type flowSetWorkflowVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *flowSetWorkflowVariableParcelsClient) Send(m *SetWorkflowVariableRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *flowSetWorkflowVariableParcelsClient) CloseAndRecv() (*SetWorkflowVariableResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetWorkflowVariableResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) InstanceVariable(ctx context.Context, in *InstanceVariableRequest, opts ...grpc.CallOption) (*InstanceVariableResponse, error) {
	out := new(InstanceVariableResponse)
	err := c.cc.Invoke(ctx, Flow_InstanceVariable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) SetInstanceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Flow_SetInstanceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[5], Flow_SetInstanceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowSetInstanceVariableParcelsClient{stream}
	return x, nil
}

type Flow_SetInstanceVariableParcelsClient interface {
	Send(*SetInstanceVariableRequest) error
	CloseAndRecv() (*SetInstanceVariableResponse, error)
	grpc.ClientStream
}

type flowSetInstanceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *flowSetInstanceVariableParcelsClient) Send(m *SetInstanceVariableRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *flowSetInstanceVariableParcelsClient) CloseAndRecv() (*SetInstanceVariableResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetInstanceVariableResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) JQ(ctx context.Context, in *JQRequest, opts ...grpc.CallOption) (*JQResponse, error) {
	out := new(JQResponse)
	err := c.cc.Invoke(ctx, Flow_JQ_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) EventListeners(ctx context.Context, in *EventListenersRequest, opts ...grpc.CallOption) (*EventListenersResponse, error) {
	out := new(EventListenersResponse)
	err := c.cc.Invoke(ctx, Flow_EventListeners_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) EventListenersStream(ctx context.Context, in *EventListenersRequest, opts ...grpc.CallOption) (Flow_EventListenersStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[6], Flow_EventListenersStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowEventListenersStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_EventListenersStreamClient interface {
	Recv() (*EventListenersResponse, error)
	grpc.ClientStream
}

type flowEventListenersStreamClient struct {
	grpc.ClientStream
}

func (x *flowEventListenersStreamClient) Recv() (*EventListenersResponse, error) {
	m := new(EventListenersResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) EventHistory(ctx context.Context, in *EventHistoryRequest, opts ...grpc.CallOption) (*EventHistoryResponse, error) {
	out := new(EventHistoryResponse)
	err := c.cc.Invoke(ctx, Flow_EventHistory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) EventHistoryStream(ctx context.Context, in *EventHistoryRequest, opts ...grpc.CallOption) (Flow_EventHistoryStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[7], Flow_EventHistoryStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowEventHistoryStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_EventHistoryStreamClient interface {
	Recv() (*EventHistoryResponse, error)
	grpc.ClientStream
}

type flowEventHistoryStreamClient struct {
	grpc.ClientStream
}

func (x *flowEventHistoryStreamClient) Recv() (*EventHistoryResponse, error) {
	m := new(EventHistoryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) HistoricalEvent(ctx context.Context, in *HistoricalEventRequest, opts ...grpc.CallOption) (*HistoricalEventResponse, error) {
	out := new(HistoricalEventResponse)
	err := c.cc.Invoke(ctx, Flow_HistoricalEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) ReplayEvent(ctx context.Context, in *ReplayEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_ReplayEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlowServer is the server API for Flow service.
// All implementations must embed UnimplementedFlowServer
// for forward compatibility
type FlowServer interface {
	// instances.
	Instance(context.Context, *InstanceRequest) (*InstanceResponse, error)
	InstanceStream(*InstanceRequest, Flow_InstanceStreamServer) error
	Instances(context.Context, *InstancesRequest) (*InstancesResponse, error)
	InstancesStream(*InstancesRequest, Flow_InstancesStreamServer) error
	InstanceInput(context.Context, *InstanceInputRequest) (*InstanceInputResponse, error)
	InstanceOutput(context.Context, *InstanceOutputRequest) (*InstanceOutputResponse, error)
	InstanceMetadata(context.Context, *InstanceMetadataRequest) (*InstanceMetadataResponse, error)
	// workflows.
	StartWorkflow(context.Context, *StartWorkflowRequest) (*StartWorkflowResponse, error)
	AwaitWorkflow(*AwaitWorkflowRequest, Flow_AwaitWorkflowServer) error
	CancelInstance(context.Context, *CancelInstanceRequest) (*emptypb.Empty, error)
	BroadcastCloudevent(context.Context, *BroadcastCloudeventRequest) (*emptypb.Empty, error)
	// variables.
	NamespaceVariable(context.Context, *NamespaceVariableRequest) (*NamespaceVariableResponse, error)
	SetNamespaceVariableParcels(Flow_SetNamespaceVariableParcelsServer) error
	WorkflowVariable(context.Context, *WorkflowVariableRequest) (*WorkflowVariableResponse, error)
	SetWorkflowVariableParcels(Flow_SetWorkflowVariableParcelsServer) error
	InstanceVariable(context.Context, *InstanceVariableRequest) (*InstanceVariableResponse, error)
	SetInstanceVariableParcels(Flow_SetInstanceVariableParcelsServer) error
	JQ(context.Context, *JQRequest) (*JQResponse, error)
	// events.
	EventListeners(context.Context, *EventListenersRequest) (*EventListenersResponse, error)
	EventListenersStream(*EventListenersRequest, Flow_EventListenersStreamServer) error
	EventHistory(context.Context, *EventHistoryRequest) (*EventHistoryResponse, error)
	EventHistoryStream(*EventHistoryRequest, Flow_EventHistoryStreamServer) error
	HistoricalEvent(context.Context, *HistoricalEventRequest) (*HistoricalEventResponse, error)
	ReplayEvent(context.Context, *ReplayEventRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedFlowServer()
}

// UnimplementedFlowServer must be embedded to have forward compatible implementations.
type UnimplementedFlowServer struct {
}

func (UnimplementedFlowServer) Instance(context.Context, *InstanceRequest) (*InstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Instance not implemented")
}
func (UnimplementedFlowServer) InstanceStream(*InstanceRequest, Flow_InstanceStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method InstanceStream not implemented")
}
func (UnimplementedFlowServer) Instances(context.Context, *InstancesRequest) (*InstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Instances not implemented")
}
func (UnimplementedFlowServer) InstancesStream(*InstancesRequest, Flow_InstancesStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method InstancesStream not implemented")
}
func (UnimplementedFlowServer) InstanceInput(context.Context, *InstanceInputRequest) (*InstanceInputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceInput not implemented")
}
func (UnimplementedFlowServer) InstanceOutput(context.Context, *InstanceOutputRequest) (*InstanceOutputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceOutput not implemented")
}
func (UnimplementedFlowServer) InstanceMetadata(context.Context, *InstanceMetadataRequest) (*InstanceMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceMetadata not implemented")
}
func (UnimplementedFlowServer) StartWorkflow(context.Context, *StartWorkflowRequest) (*StartWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkflow not implemented")
}
func (UnimplementedFlowServer) AwaitWorkflow(*AwaitWorkflowRequest, Flow_AwaitWorkflowServer) error {
	return status.Errorf(codes.Unimplemented, "method AwaitWorkflow not implemented")
}
func (UnimplementedFlowServer) CancelInstance(context.Context, *CancelInstanceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelInstance not implemented")
}
func (UnimplementedFlowServer) BroadcastCloudevent(context.Context, *BroadcastCloudeventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastCloudevent not implemented")
}
func (UnimplementedFlowServer) NamespaceVariable(context.Context, *NamespaceVariableRequest) (*NamespaceVariableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NamespaceVariable not implemented")
}
func (UnimplementedFlowServer) SetNamespaceVariableParcels(Flow_SetNamespaceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method SetNamespaceVariableParcels not implemented")
}
func (UnimplementedFlowServer) WorkflowVariable(context.Context, *WorkflowVariableRequest) (*WorkflowVariableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkflowVariable not implemented")
}
func (UnimplementedFlowServer) SetWorkflowVariableParcels(Flow_SetWorkflowVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method SetWorkflowVariableParcels not implemented")
}
func (UnimplementedFlowServer) InstanceVariable(context.Context, *InstanceVariableRequest) (*InstanceVariableResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceVariable not implemented")
}
func (UnimplementedFlowServer) SetInstanceVariableParcels(Flow_SetInstanceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method SetInstanceVariableParcels not implemented")
}
func (UnimplementedFlowServer) JQ(context.Context, *JQRequest) (*JQResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JQ not implemented")
}
func (UnimplementedFlowServer) EventListeners(context.Context, *EventListenersRequest) (*EventListenersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EventListeners not implemented")
}
func (UnimplementedFlowServer) EventListenersStream(*EventListenersRequest, Flow_EventListenersStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method EventListenersStream not implemented")
}
func (UnimplementedFlowServer) EventHistory(context.Context, *EventHistoryRequest) (*EventHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EventHistory not implemented")
}
func (UnimplementedFlowServer) EventHistoryStream(*EventHistoryRequest, Flow_EventHistoryStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method EventHistoryStream not implemented")
}
func (UnimplementedFlowServer) HistoricalEvent(context.Context, *HistoricalEventRequest) (*HistoricalEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HistoricalEvent not implemented")
}
func (UnimplementedFlowServer) ReplayEvent(context.Context, *ReplayEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplayEvent not implemented")
}
func (UnimplementedFlowServer) mustEmbedUnimplementedFlowServer() {}

// UnsafeFlowServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FlowServer will
// result in compilation errors.
type UnsafeFlowServer interface {
	mustEmbedUnimplementedFlowServer()
}

func RegisterFlowServer(s grpc.ServiceRegistrar, srv FlowServer) {
	s.RegisterService(&Flow_ServiceDesc, srv)
}

func _Flow_Instance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).Instance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_Instance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).Instance(ctx, req.(*InstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InstanceStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstanceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).InstanceStream(m, &flowInstanceStreamServer{stream})
}

type Flow_InstanceStreamServer interface {
	Send(*InstanceResponse) error
	grpc.ServerStream
}

type flowInstanceStreamServer struct {
	grpc.ServerStream
}

func (x *flowInstanceStreamServer) Send(m *InstanceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_Instances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).Instances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_Instances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).Instances(ctx, req.(*InstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InstancesStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstancesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).InstancesStream(m, &flowInstancesStreamServer{stream})
}

type Flow_InstancesStreamServer interface {
	Send(*InstancesResponse) error
	grpc.ServerStream
}

type flowInstancesStreamServer struct {
	grpc.ServerStream
}

func (x *flowInstancesStreamServer) Send(m *InstancesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_InstanceInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InstanceInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InstanceInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InstanceInput(ctx, req.(*InstanceInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InstanceOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InstanceOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InstanceOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InstanceOutput(ctx, req.(*InstanceOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InstanceMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InstanceMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InstanceMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InstanceMetadata(ctx, req.(*InstanceMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_StartWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).StartWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_StartWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).StartWorkflow(ctx, req.(*StartWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_AwaitWorkflow_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AwaitWorkflowRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).AwaitWorkflow(m, &flowAwaitWorkflowServer{stream})
}

type Flow_AwaitWorkflowServer interface {
	Send(*AwaitWorkflowResponse) error
	grpc.ServerStream
}

type flowAwaitWorkflowServer struct {
	grpc.ServerStream
}

func (x *flowAwaitWorkflowServer) Send(m *AwaitWorkflowResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_CancelInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).CancelInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_CancelInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).CancelInstance(ctx, req.(*CancelInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_BroadcastCloudevent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastCloudeventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).BroadcastCloudevent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_BroadcastCloudevent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).BroadcastCloudevent(ctx, req.(*BroadcastCloudeventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_NamespaceVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespaceVariableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).NamespaceVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_NamespaceVariable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).NamespaceVariable(ctx, req.(*NamespaceVariableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_SetNamespaceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FlowServer).SetNamespaceVariableParcels(&flowSetNamespaceVariableParcelsServer{stream})
}

type Flow_SetNamespaceVariableParcelsServer interface {
	SendAndClose(*SetNamespaceVariableResponse) error
	Recv() (*SetNamespaceVariableRequest, error)
	grpc.ServerStream
}

type flowSetNamespaceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *flowSetNamespaceVariableParcelsServer) SendAndClose(m *SetNamespaceVariableResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *flowSetNamespaceVariableParcelsServer) Recv() (*SetNamespaceVariableRequest, error) {
	m := new(SetNamespaceVariableRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Flow_WorkflowVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowVariableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).WorkflowVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_WorkflowVariable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).WorkflowVariable(ctx, req.(*WorkflowVariableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_SetWorkflowVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FlowServer).SetWorkflowVariableParcels(&flowSetWorkflowVariableParcelsServer{stream})
}

type Flow_SetWorkflowVariableParcelsServer interface {
	SendAndClose(*SetWorkflowVariableResponse) error
	Recv() (*SetWorkflowVariableRequest, error)
	grpc.ServerStream
}

type flowSetWorkflowVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *flowSetWorkflowVariableParcelsServer) SendAndClose(m *SetWorkflowVariableResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *flowSetWorkflowVariableParcelsServer) Recv() (*SetWorkflowVariableRequest, error) {
	m := new(SetWorkflowVariableRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Flow_InstanceVariable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceVariableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InstanceVariable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InstanceVariable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InstanceVariable(ctx, req.(*InstanceVariableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_SetInstanceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(FlowServer).SetInstanceVariableParcels(&flowSetInstanceVariableParcelsServer{stream})
}

type Flow_SetInstanceVariableParcelsServer interface {
	SendAndClose(*SetInstanceVariableResponse) error
	Recv() (*SetInstanceVariableRequest, error)
	grpc.ServerStream
}

type flowSetInstanceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *flowSetInstanceVariableParcelsServer) SendAndClose(m *SetInstanceVariableResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *flowSetInstanceVariableParcelsServer) Recv() (*SetInstanceVariableRequest, error) {
	m := new(SetInstanceVariableRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Flow_JQ_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JQRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).JQ(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_JQ_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).JQ(ctx, req.(*JQRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_EventListeners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventListenersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).EventListeners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_EventListeners_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).EventListeners(ctx, req.(*EventListenersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_EventListenersStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventListenersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).EventListenersStream(m, &flowEventListenersStreamServer{stream})
}

type Flow_EventListenersStreamServer interface {
	Send(*EventListenersResponse) error
	grpc.ServerStream
}

type flowEventListenersStreamServer struct {
	grpc.ServerStream
}

func (x *flowEventListenersStreamServer) Send(m *EventListenersResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_EventHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).EventHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_EventHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).EventHistory(ctx, req.(*EventHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_EventHistoryStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventHistoryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).EventHistoryStream(m, &flowEventHistoryStreamServer{stream})
}

type Flow_EventHistoryStreamServer interface {
	Send(*EventHistoryResponse) error
	grpc.ServerStream
}

type flowEventHistoryStreamServer struct {
	grpc.ServerStream
}

func (x *flowEventHistoryStreamServer) Send(m *EventHistoryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_HistoricalEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HistoricalEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).HistoricalEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_HistoricalEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).HistoricalEvent(ctx, req.(*HistoricalEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_ReplayEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplayEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).ReplayEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_ReplayEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).ReplayEvent(ctx, req.(*ReplayEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Flow_ServiceDesc is the grpc.ServiceDesc for Flow service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Flow_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "direktiv_flow.Flow",
	HandlerType: (*FlowServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Instance",
			Handler:    _Flow_Instance_Handler,
		},
		{
			MethodName: "Instances",
			Handler:    _Flow_Instances_Handler,
		},
		{
			MethodName: "InstanceInput",
			Handler:    _Flow_InstanceInput_Handler,
		},
		{
			MethodName: "InstanceOutput",
			Handler:    _Flow_InstanceOutput_Handler,
		},
		{
			MethodName: "InstanceMetadata",
			Handler:    _Flow_InstanceMetadata_Handler,
		},
		{
			MethodName: "StartWorkflow",
			Handler:    _Flow_StartWorkflow_Handler,
		},
		{
			MethodName: "CancelInstance",
			Handler:    _Flow_CancelInstance_Handler,
		},
		{
			MethodName: "BroadcastCloudevent",
			Handler:    _Flow_BroadcastCloudevent_Handler,
		},
		{
			MethodName: "NamespaceVariable",
			Handler:    _Flow_NamespaceVariable_Handler,
		},
		{
			MethodName: "WorkflowVariable",
			Handler:    _Flow_WorkflowVariable_Handler,
		},
		{
			MethodName: "InstanceVariable",
			Handler:    _Flow_InstanceVariable_Handler,
		},
		{
			MethodName: "JQ",
			Handler:    _Flow_JQ_Handler,
		},
		{
			MethodName: "EventListeners",
			Handler:    _Flow_EventListeners_Handler,
		},
		{
			MethodName: "EventHistory",
			Handler:    _Flow_EventHistory_Handler,
		},
		{
			MethodName: "HistoricalEvent",
			Handler:    _Flow_HistoricalEvent_Handler,
		},
		{
			MethodName: "ReplayEvent",
			Handler:    _Flow_ReplayEvent_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "InstanceStream",
			Handler:       _Flow_InstanceStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstancesStream",
			Handler:       _Flow_InstancesStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AwaitWorkflow",
			Handler:       _Flow_AwaitWorkflow_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetNamespaceVariableParcels",
			Handler:       _Flow_SetNamespaceVariableParcels_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SetWorkflowVariableParcels",
			Handler:       _Flow_SetWorkflowVariableParcels_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "SetInstanceVariableParcels",
			Handler:       _Flow_SetInstanceVariableParcels_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "EventListenersStream",
			Handler:       _Flow_EventListenersStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "EventHistoryStream",
			Handler:       _Flow_EventHistoryStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/flow/grpc/protocol.proto",
}

const (
	Internal_ReportActionResults_FullMethodName         = "/direktiv_flow.Internal/ReportActionResults"
	Internal_ActionLog_FullMethodName                   = "/direktiv_flow.Internal/ActionLog"
	Internal_NamespaceVariableParcels_FullMethodName    = "/direktiv_flow.Internal/NamespaceVariableParcels"
	Internal_SetNamespaceVariableParcels_FullMethodName = "/direktiv_flow.Internal/SetNamespaceVariableParcels"
	Internal_WorkflowVariableParcels_FullMethodName     = "/direktiv_flow.Internal/WorkflowVariableParcels"
	Internal_SetWorkflowVariableParcels_FullMethodName  = "/direktiv_flow.Internal/SetWorkflowVariableParcels"
	Internal_InstanceVariableParcels_FullMethodName     = "/direktiv_flow.Internal/InstanceVariableParcels"
	Internal_SetInstanceVariableParcels_FullMethodName  = "/direktiv_flow.Internal/SetInstanceVariableParcels"
	Internal_FileVariableParcels_FullMethodName         = "/direktiv_flow.Internal/FileVariableParcels"
)

// InternalClient is the client API for Internal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InternalClient interface {
	ReportActionResults(ctx context.Context, in *ReportActionResultsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ActionLog(ctx context.Context, in *ActionLogRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	NamespaceVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_NamespaceVariableParcelsClient, error)
	SetNamespaceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetNamespaceVariableParcelsClient, error)
	WorkflowVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_WorkflowVariableParcelsClient, error)
	SetWorkflowVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetWorkflowVariableParcelsClient, error)
	InstanceVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_InstanceVariableParcelsClient, error)
	SetInstanceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetInstanceVariableParcelsClient, error)
	FileVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_FileVariableParcelsClient, error)
}

type internalClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalClient(cc grpc.ClientConnInterface) InternalClient {
	return &internalClient{cc}
}

func (c *internalClient) ReportActionResults(ctx context.Context, in *ReportActionResultsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Internal_ReportActionResults_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) ActionLog(ctx context.Context, in *ActionLogRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Internal_ActionLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) NamespaceVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_NamespaceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[0], Internal_NamespaceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalNamespaceVariableParcelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_NamespaceVariableParcelsClient interface {
	Recv() (*VariableInternalResponse, error)
	grpc.ClientStream
}

type internalNamespaceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalNamespaceVariableParcelsClient) Recv() (*VariableInternalResponse, error) {
	m := new(VariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) SetNamespaceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetNamespaceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[1], Internal_SetNamespaceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalSetNamespaceVariableParcelsClient{stream}
	return x, nil
}

type Internal_SetNamespaceVariableParcelsClient interface {
	Send(*SetVariableInternalRequest) error
	CloseAndRecv() (*SetVariableInternalResponse, error)
	grpc.ClientStream
}

type internalSetNamespaceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalSetNamespaceVariableParcelsClient) Send(m *SetVariableInternalRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *internalSetNamespaceVariableParcelsClient) CloseAndRecv() (*SetVariableInternalResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetVariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) WorkflowVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_WorkflowVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[2], Internal_WorkflowVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalWorkflowVariableParcelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_WorkflowVariableParcelsClient interface {
	Recv() (*VariableInternalResponse, error)
	grpc.ClientStream
}

type internalWorkflowVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalWorkflowVariableParcelsClient) Recv() (*VariableInternalResponse, error) {
	m := new(VariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) SetWorkflowVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetWorkflowVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[3], Internal_SetWorkflowVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalSetWorkflowVariableParcelsClient{stream}
	return x, nil
}

type Internal_SetWorkflowVariableParcelsClient interface {
	Send(*SetVariableInternalRequest) error
	CloseAndRecv() (*SetVariableInternalResponse, error)
	grpc.ClientStream
}

type internalSetWorkflowVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalSetWorkflowVariableParcelsClient) Send(m *SetVariableInternalRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *internalSetWorkflowVariableParcelsClient) CloseAndRecv() (*SetVariableInternalResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetVariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) InstanceVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_InstanceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[4], Internal_InstanceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalInstanceVariableParcelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_InstanceVariableParcelsClient interface {
	Recv() (*VariableInternalResponse, error)
	grpc.ClientStream
}

type internalInstanceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalInstanceVariableParcelsClient) Recv() (*VariableInternalResponse, error) {
	m := new(VariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) SetInstanceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetInstanceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[5], Internal_SetInstanceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalSetInstanceVariableParcelsClient{stream}
	return x, nil
}

type Internal_SetInstanceVariableParcelsClient interface {
	Send(*SetVariableInternalRequest) error
	CloseAndRecv() (*SetVariableInternalResponse, error)
	grpc.ClientStream
}

type internalSetInstanceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalSetInstanceVariableParcelsClient) Send(m *SetVariableInternalRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *internalSetInstanceVariableParcelsClient) CloseAndRecv() (*SetVariableInternalResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetVariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) FileVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_FileVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[6], Internal_FileVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalFileVariableParcelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_FileVariableParcelsClient interface {
	Recv() (*VariableInternalResponse, error)
	grpc.ClientStream
}

type internalFileVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalFileVariableParcelsClient) Recv() (*VariableInternalResponse, error) {
	m := new(VariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// InternalServer is the server API for Internal service.
// All implementations must embed UnimplementedInternalServer
// for forward compatibility
type InternalServer interface {
	ReportActionResults(context.Context, *ReportActionResultsRequest) (*emptypb.Empty, error)
	ActionLog(context.Context, *ActionLogRequest) (*emptypb.Empty, error)
	NamespaceVariableParcels(*VariableInternalRequest, Internal_NamespaceVariableParcelsServer) error
	SetNamespaceVariableParcels(Internal_SetNamespaceVariableParcelsServer) error
	WorkflowVariableParcels(*VariableInternalRequest, Internal_WorkflowVariableParcelsServer) error
	SetWorkflowVariableParcels(Internal_SetWorkflowVariableParcelsServer) error
	InstanceVariableParcels(*VariableInternalRequest, Internal_InstanceVariableParcelsServer) error
	SetInstanceVariableParcels(Internal_SetInstanceVariableParcelsServer) error
	FileVariableParcels(*VariableInternalRequest, Internal_FileVariableParcelsServer) error
	mustEmbedUnimplementedInternalServer()
}

// UnimplementedInternalServer must be embedded to have forward compatible implementations.
type UnimplementedInternalServer struct {
}

func (UnimplementedInternalServer) ReportActionResults(context.Context, *ReportActionResultsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportActionResults not implemented")
}
func (UnimplementedInternalServer) ActionLog(context.Context, *ActionLogRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActionLog not implemented")
}
func (UnimplementedInternalServer) NamespaceVariableParcels(*VariableInternalRequest, Internal_NamespaceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method NamespaceVariableParcels not implemented")
}
func (UnimplementedInternalServer) SetNamespaceVariableParcels(Internal_SetNamespaceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method SetNamespaceVariableParcels not implemented")
}
func (UnimplementedInternalServer) WorkflowVariableParcels(*VariableInternalRequest, Internal_WorkflowVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method WorkflowVariableParcels not implemented")
}
func (UnimplementedInternalServer) SetWorkflowVariableParcels(Internal_SetWorkflowVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method SetWorkflowVariableParcels not implemented")
}
func (UnimplementedInternalServer) InstanceVariableParcels(*VariableInternalRequest, Internal_InstanceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method InstanceVariableParcels not implemented")
}
func (UnimplementedInternalServer) SetInstanceVariableParcels(Internal_SetInstanceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method SetInstanceVariableParcels not implemented")
}
func (UnimplementedInternalServer) FileVariableParcels(*VariableInternalRequest, Internal_FileVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method FileVariableParcels not implemented")
}
func (UnimplementedInternalServer) mustEmbedUnimplementedInternalServer() {}

// UnsafeInternalServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalServer will
// result in compilation errors.
type UnsafeInternalServer interface {
	mustEmbedUnimplementedInternalServer()
}

func RegisterInternalServer(s grpc.ServiceRegistrar, srv InternalServer) {
	s.RegisterService(&Internal_ServiceDesc, srv)
}

func _Internal_ReportActionResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportActionResultsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).ReportActionResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Internal_ReportActionResults_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).ReportActionResults(ctx, req.(*ReportActionResultsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_ActionLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).ActionLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Internal_ActionLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).ActionLog(ctx, req.(*ActionLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_NamespaceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VariableInternalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).NamespaceVariableParcels(m, &internalNamespaceVariableParcelsServer{stream})
}

type Internal_NamespaceVariableParcelsServer interface {
	Send(*VariableInternalResponse) error
	grpc.ServerStream
}

type internalNamespaceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalNamespaceVariableParcelsServer) Send(m *VariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_SetNamespaceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InternalServer).SetNamespaceVariableParcels(&internalSetNamespaceVariableParcelsServer{stream})
}

type Internal_SetNamespaceVariableParcelsServer interface {
	SendAndClose(*SetVariableInternalResponse) error
	Recv() (*SetVariableInternalRequest, error)
	grpc.ServerStream
}

type internalSetNamespaceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalSetNamespaceVariableParcelsServer) SendAndClose(m *SetVariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *internalSetNamespaceVariableParcelsServer) Recv() (*SetVariableInternalRequest, error) {
	m := new(SetVariableInternalRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Internal_WorkflowVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VariableInternalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).WorkflowVariableParcels(m, &internalWorkflowVariableParcelsServer{stream})
}

type Internal_WorkflowVariableParcelsServer interface {
	Send(*VariableInternalResponse) error
	grpc.ServerStream
}

type internalWorkflowVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalWorkflowVariableParcelsServer) Send(m *VariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_SetWorkflowVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InternalServer).SetWorkflowVariableParcels(&internalSetWorkflowVariableParcelsServer{stream})
}

type Internal_SetWorkflowVariableParcelsServer interface {
	SendAndClose(*SetVariableInternalResponse) error
	Recv() (*SetVariableInternalRequest, error)
	grpc.ServerStream
}

type internalSetWorkflowVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalSetWorkflowVariableParcelsServer) SendAndClose(m *SetVariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *internalSetWorkflowVariableParcelsServer) Recv() (*SetVariableInternalRequest, error) {
	m := new(SetVariableInternalRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Internal_InstanceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VariableInternalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).InstanceVariableParcels(m, &internalInstanceVariableParcelsServer{stream})
}

type Internal_InstanceVariableParcelsServer interface {
	Send(*VariableInternalResponse) error
	grpc.ServerStream
}

type internalInstanceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalInstanceVariableParcelsServer) Send(m *VariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_SetInstanceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InternalServer).SetInstanceVariableParcels(&internalSetInstanceVariableParcelsServer{stream})
}

type Internal_SetInstanceVariableParcelsServer interface {
	SendAndClose(*SetVariableInternalResponse) error
	Recv() (*SetVariableInternalRequest, error)
	grpc.ServerStream
}

type internalSetInstanceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalSetInstanceVariableParcelsServer) SendAndClose(m *SetVariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *internalSetInstanceVariableParcelsServer) Recv() (*SetVariableInternalRequest, error) {
	m := new(SetVariableInternalRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Internal_FileVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VariableInternalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).FileVariableParcels(m, &internalFileVariableParcelsServer{stream})
}

type Internal_FileVariableParcelsServer interface {
	Send(*VariableInternalResponse) error
	grpc.ServerStream
}

type internalFileVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalFileVariableParcelsServer) Send(m *VariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Internal_ServiceDesc is the grpc.ServiceDesc for Internal service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Internal_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "direktiv_flow.Internal",
	HandlerType: (*InternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportActionResults",
			Handler:    _Internal_ReportActionResults_Handler,
		},
		{
			MethodName: "ActionLog",
			Handler:    _Internal_ActionLog_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NamespaceVariableParcels",
			Handler:       _Internal_NamespaceVariableParcels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetNamespaceVariableParcels",
			Handler:       _Internal_SetNamespaceVariableParcels_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "WorkflowVariableParcels",
			Handler:       _Internal_WorkflowVariableParcels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetWorkflowVariableParcels",
			Handler:       _Internal_SetWorkflowVariableParcels_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "InstanceVariableParcels",
			Handler:       _Internal_InstanceVariableParcels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetInstanceVariableParcels",
			Handler:       _Internal_SetInstanceVariableParcels_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "FileVariableParcels",
			Handler:       _Internal_FileVariableParcels_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/flow/grpc/protocol.proto",
}
