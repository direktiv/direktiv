// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: pkg/flow/grpc/protocol.proto

package grpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	Flow_Namespace_FullMethodName             = "/direktiv_flow.Flow/Namespace"
	Flow_Namespaces_FullMethodName            = "/direktiv_flow.Flow/Namespaces"
	Flow_NamespacesStream_FullMethodName      = "/direktiv_flow.Flow/NamespacesStream"
	Flow_CreateNamespace_FullMethodName       = "/direktiv_flow.Flow/CreateNamespace"
	Flow_DeleteNamespace_FullMethodName       = "/direktiv_flow.Flow/DeleteNamespace"
	Flow_Instance_FullMethodName              = "/direktiv_flow.Flow/Instance"
	Flow_InstanceStream_FullMethodName        = "/direktiv_flow.Flow/InstanceStream"
	Flow_Instances_FullMethodName             = "/direktiv_flow.Flow/Instances"
	Flow_InstancesStream_FullMethodName       = "/direktiv_flow.Flow/InstancesStream"
	Flow_InstanceInput_FullMethodName         = "/direktiv_flow.Flow/InstanceInput"
	Flow_InstanceOutput_FullMethodName        = "/direktiv_flow.Flow/InstanceOutput"
	Flow_InstanceMetadata_FullMethodName      = "/direktiv_flow.Flow/InstanceMetadata"
	Flow_ReleaseInstance_FullMethodName       = "/direktiv_flow.Flow/ReleaseInstance"
	Flow_StartWorkflow_FullMethodName         = "/direktiv_flow.Flow/StartWorkflow"
	Flow_RunWorkflow_FullMethodName           = "/direktiv_flow.Flow/RunWorkflow"
	Flow_AwaitWorkflow_FullMethodName         = "/direktiv_flow.Flow/AwaitWorkflow"
	Flow_CancelInstance_FullMethodName        = "/direktiv_flow.Flow/CancelInstance"
	Flow_BroadcastCloudevent_FullMethodName   = "/direktiv_flow.Flow/BroadcastCloudevent"
	Flow_JQ_FullMethodName                    = "/direktiv_flow.Flow/JQ"
	Flow_WorkflowMetrics_FullMethodName       = "/direktiv_flow.Flow/WorkflowMetrics"
	Flow_EventListeners_FullMethodName        = "/direktiv_flow.Flow/EventListeners"
	Flow_EventListenersStream_FullMethodName  = "/direktiv_flow.Flow/EventListenersStream"
	Flow_EventHistory_FullMethodName          = "/direktiv_flow.Flow/EventHistory"
	Flow_EventHistoryStream_FullMethodName    = "/direktiv_flow.Flow/EventHistoryStream"
	Flow_HistoricalEvent_FullMethodName       = "/direktiv_flow.Flow/HistoricalEvent"
	Flow_ReplayEvent_FullMethodName           = "/direktiv_flow.Flow/ReplayEvent"
	Flow_ResolveNamespaceUID_FullMethodName   = "/direktiv_flow.Flow/ResolveNamespaceUID"
	Flow_CreateNamespaceMirror_FullMethodName = "/direktiv_flow.Flow/CreateNamespaceMirror"
	Flow_UpdateMirrorSettings_FullMethodName  = "/direktiv_flow.Flow/UpdateMirrorSettings"
	Flow_LockMirror_FullMethodName            = "/direktiv_flow.Flow/LockMirror"
	Flow_UnlockMirror_FullMethodName          = "/direktiv_flow.Flow/UnlockMirror"
	Flow_SoftSyncMirror_FullMethodName        = "/direktiv_flow.Flow/SoftSyncMirror"
	Flow_HardSyncMirror_FullMethodName        = "/direktiv_flow.Flow/HardSyncMirror"
	Flow_MirrorInfo_FullMethodName            = "/direktiv_flow.Flow/MirrorInfo"
	Flow_MirrorInfoStream_FullMethodName      = "/direktiv_flow.Flow/MirrorInfoStream"
	Flow_CancelMirrorActivity_FullMethodName  = "/direktiv_flow.Flow/CancelMirrorActivity"
	Flow_NamespaceLint_FullMethodName         = "/direktiv_flow.Flow/NamespaceLint"
)

// FlowClient is the client API for Flow service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FlowClient interface {
	// namespaces.
	Namespace(ctx context.Context, in *NamespaceRequest, opts ...grpc.CallOption) (*NamespaceResponse, error)
	Namespaces(ctx context.Context, in *NamespacesRequest, opts ...grpc.CallOption) (*NamespacesResponse, error)
	NamespacesStream(ctx context.Context, in *NamespacesRequest, opts ...grpc.CallOption) (Flow_NamespacesStreamClient, error)
	CreateNamespace(ctx context.Context, in *CreateNamespaceRequest, opts ...grpc.CallOption) (*CreateNamespaceResponse, error)
	DeleteNamespace(ctx context.Context, in *DeleteNamespaceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// instances.
	Instance(ctx context.Context, in *InstanceRequest, opts ...grpc.CallOption) (*InstanceResponse, error)
	InstanceStream(ctx context.Context, in *InstanceRequest, opts ...grpc.CallOption) (Flow_InstanceStreamClient, error)
	Instances(ctx context.Context, in *InstancesRequest, opts ...grpc.CallOption) (*InstancesResponse, error)
	InstancesStream(ctx context.Context, in *InstancesRequest, opts ...grpc.CallOption) (Flow_InstancesStreamClient, error)
	InstanceInput(ctx context.Context, in *InstanceInputRequest, opts ...grpc.CallOption) (*InstanceInputResponse, error)
	InstanceOutput(ctx context.Context, in *InstanceOutputRequest, opts ...grpc.CallOption) (*InstanceOutputResponse, error)
	InstanceMetadata(ctx context.Context, in *InstanceMetadataRequest, opts ...grpc.CallOption) (*InstanceMetadataResponse, error)
	ReleaseInstance(ctx context.Context, in *ReleaseInstanceRequest, opts ...grpc.CallOption) (*ReleaseInstanceResponse, error)
	// workflows.
	StartWorkflow(ctx context.Context, in *StartWorkflowRequest, opts ...grpc.CallOption) (*StartWorkflowResponse, error)
	RunWorkflow(ctx context.Context, in *RunWorkflowRequest, opts ...grpc.CallOption) (Flow_RunWorkflowClient, error)
	AwaitWorkflow(ctx context.Context, in *AwaitWorkflowRequest, opts ...grpc.CallOption) (Flow_AwaitWorkflowClient, error)
	CancelInstance(ctx context.Context, in *CancelInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	BroadcastCloudevent(ctx context.Context, in *BroadcastCloudeventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	JQ(ctx context.Context, in *JQRequest, opts ...grpc.CallOption) (*JQResponse, error)
	WorkflowMetrics(ctx context.Context, in *WorkflowMetricsRequest, opts ...grpc.CallOption) (*WorkflowMetricsResponse, error)
	// events.
	EventListeners(ctx context.Context, in *EventListenersRequest, opts ...grpc.CallOption) (*EventListenersResponse, error)
	EventListenersStream(ctx context.Context, in *EventListenersRequest, opts ...grpc.CallOption) (Flow_EventListenersStreamClient, error)
	EventHistory(ctx context.Context, in *EventHistoryRequest, opts ...grpc.CallOption) (*EventHistoryResponse, error)
	EventHistoryStream(ctx context.Context, in *EventHistoryRequest, opts ...grpc.CallOption) (Flow_EventHistoryStreamClient, error)
	HistoricalEvent(ctx context.Context, in *HistoricalEventRequest, opts ...grpc.CallOption) (*HistoricalEventResponse, error)
	ReplayEvent(ctx context.Context, in *ReplayEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ResolveNamespaceUID(ctx context.Context, in *ResolveNamespaceUIDRequest, opts ...grpc.CallOption) (*NamespaceResponse, error)
	// mirrors.
	CreateNamespaceMirror(ctx context.Context, in *CreateNamespaceMirrorRequest, opts ...grpc.CallOption) (*CreateNamespaceResponse, error)
	UpdateMirrorSettings(ctx context.Context, in *UpdateMirrorSettingsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	LockMirror(ctx context.Context, in *LockMirrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UnlockMirror(ctx context.Context, in *UnlockMirrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	SoftSyncMirror(ctx context.Context, in *SoftSyncMirrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	HardSyncMirror(ctx context.Context, in *HardSyncMirrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	MirrorInfo(ctx context.Context, in *MirrorInfoRequest, opts ...grpc.CallOption) (*MirrorInfoResponse, error)
	MirrorInfoStream(ctx context.Context, in *MirrorInfoRequest, opts ...grpc.CallOption) (Flow_MirrorInfoStreamClient, error)
	CancelMirrorActivity(ctx context.Context, in *CancelMirrorActivityRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	NamespaceLint(ctx context.Context, in *NamespaceLintRequest, opts ...grpc.CallOption) (*NamespaceLintResponse, error)
}

type flowClient struct {
	cc grpc.ClientConnInterface
}

func NewFlowClient(cc grpc.ClientConnInterface) FlowClient {
	return &flowClient{cc}
}

func (c *flowClient) Namespace(ctx context.Context, in *NamespaceRequest, opts ...grpc.CallOption) (*NamespaceResponse, error) {
	out := new(NamespaceResponse)
	err := c.cc.Invoke(ctx, Flow_Namespace_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) Namespaces(ctx context.Context, in *NamespacesRequest, opts ...grpc.CallOption) (*NamespacesResponse, error) {
	out := new(NamespacesResponse)
	err := c.cc.Invoke(ctx, Flow_Namespaces_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) NamespacesStream(ctx context.Context, in *NamespacesRequest, opts ...grpc.CallOption) (Flow_NamespacesStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[0], Flow_NamespacesStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowNamespacesStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_NamespacesStreamClient interface {
	Recv() (*NamespacesResponse, error)
	grpc.ClientStream
}

type flowNamespacesStreamClient struct {
	grpc.ClientStream
}

func (x *flowNamespacesStreamClient) Recv() (*NamespacesResponse, error) {
	m := new(NamespacesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) CreateNamespace(ctx context.Context, in *CreateNamespaceRequest, opts ...grpc.CallOption) (*CreateNamespaceResponse, error) {
	out := new(CreateNamespaceResponse)
	err := c.cc.Invoke(ctx, Flow_CreateNamespace_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) DeleteNamespace(ctx context.Context, in *DeleteNamespaceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_DeleteNamespace_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) Instance(ctx context.Context, in *InstanceRequest, opts ...grpc.CallOption) (*InstanceResponse, error) {
	out := new(InstanceResponse)
	err := c.cc.Invoke(ctx, Flow_Instance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InstanceStream(ctx context.Context, in *InstanceRequest, opts ...grpc.CallOption) (Flow_InstanceStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[1], Flow_InstanceStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowInstanceStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_InstanceStreamClient interface {
	Recv() (*InstanceResponse, error)
	grpc.ClientStream
}

type flowInstanceStreamClient struct {
	grpc.ClientStream
}

func (x *flowInstanceStreamClient) Recv() (*InstanceResponse, error) {
	m := new(InstanceResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) Instances(ctx context.Context, in *InstancesRequest, opts ...grpc.CallOption) (*InstancesResponse, error) {
	out := new(InstancesResponse)
	err := c.cc.Invoke(ctx, Flow_Instances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InstancesStream(ctx context.Context, in *InstancesRequest, opts ...grpc.CallOption) (Flow_InstancesStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[2], Flow_InstancesStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowInstancesStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_InstancesStreamClient interface {
	Recv() (*InstancesResponse, error)
	grpc.ClientStream
}

type flowInstancesStreamClient struct {
	grpc.ClientStream
}

func (x *flowInstancesStreamClient) Recv() (*InstancesResponse, error) {
	m := new(InstancesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) InstanceInput(ctx context.Context, in *InstanceInputRequest, opts ...grpc.CallOption) (*InstanceInputResponse, error) {
	out := new(InstanceInputResponse)
	err := c.cc.Invoke(ctx, Flow_InstanceInput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InstanceOutput(ctx context.Context, in *InstanceOutputRequest, opts ...grpc.CallOption) (*InstanceOutputResponse, error) {
	out := new(InstanceOutputResponse)
	err := c.cc.Invoke(ctx, Flow_InstanceOutput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) InstanceMetadata(ctx context.Context, in *InstanceMetadataRequest, opts ...grpc.CallOption) (*InstanceMetadataResponse, error) {
	out := new(InstanceMetadataResponse)
	err := c.cc.Invoke(ctx, Flow_InstanceMetadata_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) ReleaseInstance(ctx context.Context, in *ReleaseInstanceRequest, opts ...grpc.CallOption) (*ReleaseInstanceResponse, error) {
	out := new(ReleaseInstanceResponse)
	err := c.cc.Invoke(ctx, Flow_ReleaseInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) StartWorkflow(ctx context.Context, in *StartWorkflowRequest, opts ...grpc.CallOption) (*StartWorkflowResponse, error) {
	out := new(StartWorkflowResponse)
	err := c.cc.Invoke(ctx, Flow_StartWorkflow_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) RunWorkflow(ctx context.Context, in *RunWorkflowRequest, opts ...grpc.CallOption) (Flow_RunWorkflowClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[3], Flow_RunWorkflow_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowRunWorkflowClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_RunWorkflowClient interface {
	Recv() (*RunWorkflowResponse, error)
	grpc.ClientStream
}

type flowRunWorkflowClient struct {
	grpc.ClientStream
}

func (x *flowRunWorkflowClient) Recv() (*RunWorkflowResponse, error) {
	m := new(RunWorkflowResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) AwaitWorkflow(ctx context.Context, in *AwaitWorkflowRequest, opts ...grpc.CallOption) (Flow_AwaitWorkflowClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[4], Flow_AwaitWorkflow_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowAwaitWorkflowClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_AwaitWorkflowClient interface {
	Recv() (*AwaitWorkflowResponse, error)
	grpc.ClientStream
}

type flowAwaitWorkflowClient struct {
	grpc.ClientStream
}

func (x *flowAwaitWorkflowClient) Recv() (*AwaitWorkflowResponse, error) {
	m := new(AwaitWorkflowResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) CancelInstance(ctx context.Context, in *CancelInstanceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_CancelInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) BroadcastCloudevent(ctx context.Context, in *BroadcastCloudeventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_BroadcastCloudevent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) JQ(ctx context.Context, in *JQRequest, opts ...grpc.CallOption) (*JQResponse, error) {
	out := new(JQResponse)
	err := c.cc.Invoke(ctx, Flow_JQ_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) WorkflowMetrics(ctx context.Context, in *WorkflowMetricsRequest, opts ...grpc.CallOption) (*WorkflowMetricsResponse, error) {
	out := new(WorkflowMetricsResponse)
	err := c.cc.Invoke(ctx, Flow_WorkflowMetrics_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) EventListeners(ctx context.Context, in *EventListenersRequest, opts ...grpc.CallOption) (*EventListenersResponse, error) {
	out := new(EventListenersResponse)
	err := c.cc.Invoke(ctx, Flow_EventListeners_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) EventListenersStream(ctx context.Context, in *EventListenersRequest, opts ...grpc.CallOption) (Flow_EventListenersStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[5], Flow_EventListenersStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowEventListenersStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_EventListenersStreamClient interface {
	Recv() (*EventListenersResponse, error)
	grpc.ClientStream
}

type flowEventListenersStreamClient struct {
	grpc.ClientStream
}

func (x *flowEventListenersStreamClient) Recv() (*EventListenersResponse, error) {
	m := new(EventListenersResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) EventHistory(ctx context.Context, in *EventHistoryRequest, opts ...grpc.CallOption) (*EventHistoryResponse, error) {
	out := new(EventHistoryResponse)
	err := c.cc.Invoke(ctx, Flow_EventHistory_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) EventHistoryStream(ctx context.Context, in *EventHistoryRequest, opts ...grpc.CallOption) (Flow_EventHistoryStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[6], Flow_EventHistoryStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowEventHistoryStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_EventHistoryStreamClient interface {
	Recv() (*EventHistoryResponse, error)
	grpc.ClientStream
}

type flowEventHistoryStreamClient struct {
	grpc.ClientStream
}

func (x *flowEventHistoryStreamClient) Recv() (*EventHistoryResponse, error) {
	m := new(EventHistoryResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) HistoricalEvent(ctx context.Context, in *HistoricalEventRequest, opts ...grpc.CallOption) (*HistoricalEventResponse, error) {
	out := new(HistoricalEventResponse)
	err := c.cc.Invoke(ctx, Flow_HistoricalEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) ReplayEvent(ctx context.Context, in *ReplayEventRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_ReplayEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) ResolveNamespaceUID(ctx context.Context, in *ResolveNamespaceUIDRequest, opts ...grpc.CallOption) (*NamespaceResponse, error) {
	out := new(NamespaceResponse)
	err := c.cc.Invoke(ctx, Flow_ResolveNamespaceUID_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) CreateNamespaceMirror(ctx context.Context, in *CreateNamespaceMirrorRequest, opts ...grpc.CallOption) (*CreateNamespaceResponse, error) {
	out := new(CreateNamespaceResponse)
	err := c.cc.Invoke(ctx, Flow_CreateNamespaceMirror_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) UpdateMirrorSettings(ctx context.Context, in *UpdateMirrorSettingsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_UpdateMirrorSettings_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) LockMirror(ctx context.Context, in *LockMirrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_LockMirror_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) UnlockMirror(ctx context.Context, in *UnlockMirrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_UnlockMirror_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) SoftSyncMirror(ctx context.Context, in *SoftSyncMirrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_SoftSyncMirror_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) HardSyncMirror(ctx context.Context, in *HardSyncMirrorRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_HardSyncMirror_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) MirrorInfo(ctx context.Context, in *MirrorInfoRequest, opts ...grpc.CallOption) (*MirrorInfoResponse, error) {
	out := new(MirrorInfoResponse)
	err := c.cc.Invoke(ctx, Flow_MirrorInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) MirrorInfoStream(ctx context.Context, in *MirrorInfoRequest, opts ...grpc.CallOption) (Flow_MirrorInfoStreamClient, error) {
	stream, err := c.cc.NewStream(ctx, &Flow_ServiceDesc.Streams[7], Flow_MirrorInfoStream_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &flowMirrorInfoStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Flow_MirrorInfoStreamClient interface {
	Recv() (*MirrorInfoResponse, error)
	grpc.ClientStream
}

type flowMirrorInfoStreamClient struct {
	grpc.ClientStream
}

func (x *flowMirrorInfoStreamClient) Recv() (*MirrorInfoResponse, error) {
	m := new(MirrorInfoResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *flowClient) CancelMirrorActivity(ctx context.Context, in *CancelMirrorActivityRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Flow_CancelMirrorActivity_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *flowClient) NamespaceLint(ctx context.Context, in *NamespaceLintRequest, opts ...grpc.CallOption) (*NamespaceLintResponse, error) {
	out := new(NamespaceLintResponse)
	err := c.cc.Invoke(ctx, Flow_NamespaceLint_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FlowServer is the server API for Flow service.
// All implementations must embed UnimplementedFlowServer
// for forward compatibility
type FlowServer interface {
	// namespaces.
	Namespace(context.Context, *NamespaceRequest) (*NamespaceResponse, error)
	Namespaces(context.Context, *NamespacesRequest) (*NamespacesResponse, error)
	NamespacesStream(*NamespacesRequest, Flow_NamespacesStreamServer) error
	CreateNamespace(context.Context, *CreateNamespaceRequest) (*CreateNamespaceResponse, error)
	DeleteNamespace(context.Context, *DeleteNamespaceRequest) (*emptypb.Empty, error)
	// instances.
	Instance(context.Context, *InstanceRequest) (*InstanceResponse, error)
	InstanceStream(*InstanceRequest, Flow_InstanceStreamServer) error
	Instances(context.Context, *InstancesRequest) (*InstancesResponse, error)
	InstancesStream(*InstancesRequest, Flow_InstancesStreamServer) error
	InstanceInput(context.Context, *InstanceInputRequest) (*InstanceInputResponse, error)
	InstanceOutput(context.Context, *InstanceOutputRequest) (*InstanceOutputResponse, error)
	InstanceMetadata(context.Context, *InstanceMetadataRequest) (*InstanceMetadataResponse, error)
	ReleaseInstance(context.Context, *ReleaseInstanceRequest) (*ReleaseInstanceResponse, error)
	// workflows.
	StartWorkflow(context.Context, *StartWorkflowRequest) (*StartWorkflowResponse, error)
	RunWorkflow(*RunWorkflowRequest, Flow_RunWorkflowServer) error
	AwaitWorkflow(*AwaitWorkflowRequest, Flow_AwaitWorkflowServer) error
	CancelInstance(context.Context, *CancelInstanceRequest) (*emptypb.Empty, error)
	BroadcastCloudevent(context.Context, *BroadcastCloudeventRequest) (*emptypb.Empty, error)
	JQ(context.Context, *JQRequest) (*JQResponse, error)
	WorkflowMetrics(context.Context, *WorkflowMetricsRequest) (*WorkflowMetricsResponse, error)
	// events.
	EventListeners(context.Context, *EventListenersRequest) (*EventListenersResponse, error)
	EventListenersStream(*EventListenersRequest, Flow_EventListenersStreamServer) error
	EventHistory(context.Context, *EventHistoryRequest) (*EventHistoryResponse, error)
	EventHistoryStream(*EventHistoryRequest, Flow_EventHistoryStreamServer) error
	HistoricalEvent(context.Context, *HistoricalEventRequest) (*HistoricalEventResponse, error)
	ReplayEvent(context.Context, *ReplayEventRequest) (*emptypb.Empty, error)
	ResolveNamespaceUID(context.Context, *ResolveNamespaceUIDRequest) (*NamespaceResponse, error)
	// mirrors.
	CreateNamespaceMirror(context.Context, *CreateNamespaceMirrorRequest) (*CreateNamespaceResponse, error)
	UpdateMirrorSettings(context.Context, *UpdateMirrorSettingsRequest) (*emptypb.Empty, error)
	LockMirror(context.Context, *LockMirrorRequest) (*emptypb.Empty, error)
	UnlockMirror(context.Context, *UnlockMirrorRequest) (*emptypb.Empty, error)
	SoftSyncMirror(context.Context, *SoftSyncMirrorRequest) (*emptypb.Empty, error)
	HardSyncMirror(context.Context, *HardSyncMirrorRequest) (*emptypb.Empty, error)
	MirrorInfo(context.Context, *MirrorInfoRequest) (*MirrorInfoResponse, error)
	MirrorInfoStream(*MirrorInfoRequest, Flow_MirrorInfoStreamServer) error
	CancelMirrorActivity(context.Context, *CancelMirrorActivityRequest) (*emptypb.Empty, error)
	NamespaceLint(context.Context, *NamespaceLintRequest) (*NamespaceLintResponse, error)
	mustEmbedUnimplementedFlowServer()
}

// UnimplementedFlowServer must be embedded to have forward compatible implementations.
type UnimplementedFlowServer struct {
}

func (UnimplementedFlowServer) Namespace(context.Context, *NamespaceRequest) (*NamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Namespace not implemented")
}
func (UnimplementedFlowServer) Namespaces(context.Context, *NamespacesRequest) (*NamespacesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Namespaces not implemented")
}
func (UnimplementedFlowServer) NamespacesStream(*NamespacesRequest, Flow_NamespacesStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method NamespacesStream not implemented")
}
func (UnimplementedFlowServer) CreateNamespace(context.Context, *CreateNamespaceRequest) (*CreateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNamespace not implemented")
}
func (UnimplementedFlowServer) DeleteNamespace(context.Context, *DeleteNamespaceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNamespace not implemented")
}
func (UnimplementedFlowServer) Instance(context.Context, *InstanceRequest) (*InstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Instance not implemented")
}
func (UnimplementedFlowServer) InstanceStream(*InstanceRequest, Flow_InstanceStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method InstanceStream not implemented")
}
func (UnimplementedFlowServer) Instances(context.Context, *InstancesRequest) (*InstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Instances not implemented")
}
func (UnimplementedFlowServer) InstancesStream(*InstancesRequest, Flow_InstancesStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method InstancesStream not implemented")
}
func (UnimplementedFlowServer) InstanceInput(context.Context, *InstanceInputRequest) (*InstanceInputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceInput not implemented")
}
func (UnimplementedFlowServer) InstanceOutput(context.Context, *InstanceOutputRequest) (*InstanceOutputResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceOutput not implemented")
}
func (UnimplementedFlowServer) InstanceMetadata(context.Context, *InstanceMetadataRequest) (*InstanceMetadataResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstanceMetadata not implemented")
}
func (UnimplementedFlowServer) ReleaseInstance(context.Context, *ReleaseInstanceRequest) (*ReleaseInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReleaseInstance not implemented")
}
func (UnimplementedFlowServer) StartWorkflow(context.Context, *StartWorkflowRequest) (*StartWorkflowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWorkflow not implemented")
}
func (UnimplementedFlowServer) RunWorkflow(*RunWorkflowRequest, Flow_RunWorkflowServer) error {
	return status.Errorf(codes.Unimplemented, "method RunWorkflow not implemented")
}
func (UnimplementedFlowServer) AwaitWorkflow(*AwaitWorkflowRequest, Flow_AwaitWorkflowServer) error {
	return status.Errorf(codes.Unimplemented, "method AwaitWorkflow not implemented")
}
func (UnimplementedFlowServer) CancelInstance(context.Context, *CancelInstanceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelInstance not implemented")
}
func (UnimplementedFlowServer) BroadcastCloudevent(context.Context, *BroadcastCloudeventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastCloudevent not implemented")
}
func (UnimplementedFlowServer) JQ(context.Context, *JQRequest) (*JQResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JQ not implemented")
}
func (UnimplementedFlowServer) WorkflowMetrics(context.Context, *WorkflowMetricsRequest) (*WorkflowMetricsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkflowMetrics not implemented")
}
func (UnimplementedFlowServer) EventListeners(context.Context, *EventListenersRequest) (*EventListenersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EventListeners not implemented")
}
func (UnimplementedFlowServer) EventListenersStream(*EventListenersRequest, Flow_EventListenersStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method EventListenersStream not implemented")
}
func (UnimplementedFlowServer) EventHistory(context.Context, *EventHistoryRequest) (*EventHistoryResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EventHistory not implemented")
}
func (UnimplementedFlowServer) EventHistoryStream(*EventHistoryRequest, Flow_EventHistoryStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method EventHistoryStream not implemented")
}
func (UnimplementedFlowServer) HistoricalEvent(context.Context, *HistoricalEventRequest) (*HistoricalEventResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HistoricalEvent not implemented")
}
func (UnimplementedFlowServer) ReplayEvent(context.Context, *ReplayEventRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReplayEvent not implemented")
}
func (UnimplementedFlowServer) ResolveNamespaceUID(context.Context, *ResolveNamespaceUIDRequest) (*NamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResolveNamespaceUID not implemented")
}
func (UnimplementedFlowServer) CreateNamespaceMirror(context.Context, *CreateNamespaceMirrorRequest) (*CreateNamespaceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateNamespaceMirror not implemented")
}
func (UnimplementedFlowServer) UpdateMirrorSettings(context.Context, *UpdateMirrorSettingsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateMirrorSettings not implemented")
}
func (UnimplementedFlowServer) LockMirror(context.Context, *LockMirrorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LockMirror not implemented")
}
func (UnimplementedFlowServer) UnlockMirror(context.Context, *UnlockMirrorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UnlockMirror not implemented")
}
func (UnimplementedFlowServer) SoftSyncMirror(context.Context, *SoftSyncMirrorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SoftSyncMirror not implemented")
}
func (UnimplementedFlowServer) HardSyncMirror(context.Context, *HardSyncMirrorRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method HardSyncMirror not implemented")
}
func (UnimplementedFlowServer) MirrorInfo(context.Context, *MirrorInfoRequest) (*MirrorInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MirrorInfo not implemented")
}
func (UnimplementedFlowServer) MirrorInfoStream(*MirrorInfoRequest, Flow_MirrorInfoStreamServer) error {
	return status.Errorf(codes.Unimplemented, "method MirrorInfoStream not implemented")
}
func (UnimplementedFlowServer) CancelMirrorActivity(context.Context, *CancelMirrorActivityRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelMirrorActivity not implemented")
}
func (UnimplementedFlowServer) NamespaceLint(context.Context, *NamespaceLintRequest) (*NamespaceLintResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method NamespaceLint not implemented")
}
func (UnimplementedFlowServer) mustEmbedUnimplementedFlowServer() {}

// UnsafeFlowServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FlowServer will
// result in compilation errors.
type UnsafeFlowServer interface {
	mustEmbedUnimplementedFlowServer()
}

func RegisterFlowServer(s grpc.ServiceRegistrar, srv FlowServer) {
	s.RegisterService(&Flow_ServiceDesc, srv)
}

func _Flow_Namespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).Namespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_Namespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).Namespace(ctx, req.(*NamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_Namespaces_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespacesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).Namespaces(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_Namespaces_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).Namespaces(ctx, req.(*NamespacesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_NamespacesStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(NamespacesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).NamespacesStream(m, &flowNamespacesStreamServer{stream})
}

type Flow_NamespacesStreamServer interface {
	Send(*NamespacesResponse) error
	grpc.ServerStream
}

type flowNamespacesStreamServer struct {
	grpc.ServerStream
}

func (x *flowNamespacesStreamServer) Send(m *NamespacesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_CreateNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).CreateNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_CreateNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).CreateNamespace(ctx, req.(*CreateNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_DeleteNamespace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNamespaceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).DeleteNamespace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_DeleteNamespace_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).DeleteNamespace(ctx, req.(*DeleteNamespaceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_Instance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).Instance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_Instance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).Instance(ctx, req.(*InstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InstanceStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstanceRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).InstanceStream(m, &flowInstanceStreamServer{stream})
}

type Flow_InstanceStreamServer interface {
	Send(*InstanceResponse) error
	grpc.ServerStream
}

type flowInstanceStreamServer struct {
	grpc.ServerStream
}

func (x *flowInstanceStreamServer) Send(m *InstanceResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_Instances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).Instances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_Instances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).Instances(ctx, req.(*InstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InstancesStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(InstancesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).InstancesStream(m, &flowInstancesStreamServer{stream})
}

type Flow_InstancesStreamServer interface {
	Send(*InstancesResponse) error
	grpc.ServerStream
}

type flowInstancesStreamServer struct {
	grpc.ServerStream
}

func (x *flowInstancesStreamServer) Send(m *InstancesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_InstanceInput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceInputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InstanceInput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InstanceInput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InstanceInput(ctx, req.(*InstanceInputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InstanceOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceOutputRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InstanceOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InstanceOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InstanceOutput(ctx, req.(*InstanceOutputRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_InstanceMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InstanceMetadataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).InstanceMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_InstanceMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).InstanceMetadata(ctx, req.(*InstanceMetadataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_ReleaseInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReleaseInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).ReleaseInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_ReleaseInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).ReleaseInstance(ctx, req.(*ReleaseInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_StartWorkflow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWorkflowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).StartWorkflow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_StartWorkflow_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).StartWorkflow(ctx, req.(*StartWorkflowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_RunWorkflow_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(RunWorkflowRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).RunWorkflow(m, &flowRunWorkflowServer{stream})
}

type Flow_RunWorkflowServer interface {
	Send(*RunWorkflowResponse) error
	grpc.ServerStream
}

type flowRunWorkflowServer struct {
	grpc.ServerStream
}

func (x *flowRunWorkflowServer) Send(m *RunWorkflowResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_AwaitWorkflow_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AwaitWorkflowRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).AwaitWorkflow(m, &flowAwaitWorkflowServer{stream})
}

type Flow_AwaitWorkflowServer interface {
	Send(*AwaitWorkflowResponse) error
	grpc.ServerStream
}

type flowAwaitWorkflowServer struct {
	grpc.ServerStream
}

func (x *flowAwaitWorkflowServer) Send(m *AwaitWorkflowResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_CancelInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).CancelInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_CancelInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).CancelInstance(ctx, req.(*CancelInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_BroadcastCloudevent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BroadcastCloudeventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).BroadcastCloudevent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_BroadcastCloudevent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).BroadcastCloudevent(ctx, req.(*BroadcastCloudeventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_JQ_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(JQRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).JQ(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_JQ_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).JQ(ctx, req.(*JQRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_WorkflowMetrics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkflowMetricsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).WorkflowMetrics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_WorkflowMetrics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).WorkflowMetrics(ctx, req.(*WorkflowMetricsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_EventListeners_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventListenersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).EventListeners(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_EventListeners_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).EventListeners(ctx, req.(*EventListenersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_EventListenersStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventListenersRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).EventListenersStream(m, &flowEventListenersStreamServer{stream})
}

type Flow_EventListenersStreamServer interface {
	Send(*EventListenersResponse) error
	grpc.ServerStream
}

type flowEventListenersStreamServer struct {
	grpc.ServerStream
}

func (x *flowEventListenersStreamServer) Send(m *EventListenersResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_EventHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EventHistoryRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).EventHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_EventHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).EventHistory(ctx, req.(*EventHistoryRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_EventHistoryStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventHistoryRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).EventHistoryStream(m, &flowEventHistoryStreamServer{stream})
}

type Flow_EventHistoryStreamServer interface {
	Send(*EventHistoryResponse) error
	grpc.ServerStream
}

type flowEventHistoryStreamServer struct {
	grpc.ServerStream
}

func (x *flowEventHistoryStreamServer) Send(m *EventHistoryResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_HistoricalEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HistoricalEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).HistoricalEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_HistoricalEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).HistoricalEvent(ctx, req.(*HistoricalEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_ReplayEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplayEventRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).ReplayEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_ReplayEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).ReplayEvent(ctx, req.(*ReplayEventRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_ResolveNamespaceUID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResolveNamespaceUIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).ResolveNamespaceUID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_ResolveNamespaceUID_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).ResolveNamespaceUID(ctx, req.(*ResolveNamespaceUIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_CreateNamespaceMirror_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateNamespaceMirrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).CreateNamespaceMirror(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_CreateNamespaceMirror_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).CreateNamespaceMirror(ctx, req.(*CreateNamespaceMirrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_UpdateMirrorSettings_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateMirrorSettingsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).UpdateMirrorSettings(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_UpdateMirrorSettings_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).UpdateMirrorSettings(ctx, req.(*UpdateMirrorSettingsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_LockMirror_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LockMirrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).LockMirror(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_LockMirror_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).LockMirror(ctx, req.(*LockMirrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_UnlockMirror_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UnlockMirrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).UnlockMirror(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_UnlockMirror_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).UnlockMirror(ctx, req.(*UnlockMirrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_SoftSyncMirror_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SoftSyncMirrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).SoftSyncMirror(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_SoftSyncMirror_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).SoftSyncMirror(ctx, req.(*SoftSyncMirrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_HardSyncMirror_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HardSyncMirrorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).HardSyncMirror(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_HardSyncMirror_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).HardSyncMirror(ctx, req.(*HardSyncMirrorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_MirrorInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MirrorInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).MirrorInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_MirrorInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).MirrorInfo(ctx, req.(*MirrorInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_MirrorInfoStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MirrorInfoRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FlowServer).MirrorInfoStream(m, &flowMirrorInfoStreamServer{stream})
}

type Flow_MirrorInfoStreamServer interface {
	Send(*MirrorInfoResponse) error
	grpc.ServerStream
}

type flowMirrorInfoStreamServer struct {
	grpc.ServerStream
}

func (x *flowMirrorInfoStreamServer) Send(m *MirrorInfoResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Flow_CancelMirrorActivity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelMirrorActivityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).CancelMirrorActivity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_CancelMirrorActivity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).CancelMirrorActivity(ctx, req.(*CancelMirrorActivityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Flow_NamespaceLint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NamespaceLintRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FlowServer).NamespaceLint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Flow_NamespaceLint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FlowServer).NamespaceLint(ctx, req.(*NamespaceLintRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Flow_ServiceDesc is the grpc.ServiceDesc for Flow service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Flow_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "direktiv_flow.Flow",
	HandlerType: (*FlowServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Namespace",
			Handler:    _Flow_Namespace_Handler,
		},
		{
			MethodName: "Namespaces",
			Handler:    _Flow_Namespaces_Handler,
		},
		{
			MethodName: "CreateNamespace",
			Handler:    _Flow_CreateNamespace_Handler,
		},
		{
			MethodName: "DeleteNamespace",
			Handler:    _Flow_DeleteNamespace_Handler,
		},
		{
			MethodName: "Instance",
			Handler:    _Flow_Instance_Handler,
		},
		{
			MethodName: "Instances",
			Handler:    _Flow_Instances_Handler,
		},
		{
			MethodName: "InstanceInput",
			Handler:    _Flow_InstanceInput_Handler,
		},
		{
			MethodName: "InstanceOutput",
			Handler:    _Flow_InstanceOutput_Handler,
		},
		{
			MethodName: "InstanceMetadata",
			Handler:    _Flow_InstanceMetadata_Handler,
		},
		{
			MethodName: "ReleaseInstance",
			Handler:    _Flow_ReleaseInstance_Handler,
		},
		{
			MethodName: "StartWorkflow",
			Handler:    _Flow_StartWorkflow_Handler,
		},
		{
			MethodName: "CancelInstance",
			Handler:    _Flow_CancelInstance_Handler,
		},
		{
			MethodName: "BroadcastCloudevent",
			Handler:    _Flow_BroadcastCloudevent_Handler,
		},
		{
			MethodName: "JQ",
			Handler:    _Flow_JQ_Handler,
		},
		{
			MethodName: "WorkflowMetrics",
			Handler:    _Flow_WorkflowMetrics_Handler,
		},
		{
			MethodName: "EventListeners",
			Handler:    _Flow_EventListeners_Handler,
		},
		{
			MethodName: "EventHistory",
			Handler:    _Flow_EventHistory_Handler,
		},
		{
			MethodName: "HistoricalEvent",
			Handler:    _Flow_HistoricalEvent_Handler,
		},
		{
			MethodName: "ReplayEvent",
			Handler:    _Flow_ReplayEvent_Handler,
		},
		{
			MethodName: "ResolveNamespaceUID",
			Handler:    _Flow_ResolveNamespaceUID_Handler,
		},
		{
			MethodName: "CreateNamespaceMirror",
			Handler:    _Flow_CreateNamespaceMirror_Handler,
		},
		{
			MethodName: "UpdateMirrorSettings",
			Handler:    _Flow_UpdateMirrorSettings_Handler,
		},
		{
			MethodName: "LockMirror",
			Handler:    _Flow_LockMirror_Handler,
		},
		{
			MethodName: "UnlockMirror",
			Handler:    _Flow_UnlockMirror_Handler,
		},
		{
			MethodName: "SoftSyncMirror",
			Handler:    _Flow_SoftSyncMirror_Handler,
		},
		{
			MethodName: "HardSyncMirror",
			Handler:    _Flow_HardSyncMirror_Handler,
		},
		{
			MethodName: "MirrorInfo",
			Handler:    _Flow_MirrorInfo_Handler,
		},
		{
			MethodName: "CancelMirrorActivity",
			Handler:    _Flow_CancelMirrorActivity_Handler,
		},
		{
			MethodName: "NamespaceLint",
			Handler:    _Flow_NamespaceLint_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NamespacesStream",
			Handler:       _Flow_NamespacesStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstanceStream",
			Handler:       _Flow_InstanceStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "InstancesStream",
			Handler:       _Flow_InstancesStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RunWorkflow",
			Handler:       _Flow_RunWorkflow_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "AwaitWorkflow",
			Handler:       _Flow_AwaitWorkflow_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "EventListenersStream",
			Handler:       _Flow_EventListenersStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "EventHistoryStream",
			Handler:       _Flow_EventHistoryStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "MirrorInfoStream",
			Handler:       _Flow_MirrorInfoStream_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/flow/grpc/protocol.proto",
}

const (
	Internal_ReportActionResults_FullMethodName         = "/direktiv_flow.Internal/ReportActionResults"
	Internal_ActionLog_FullMethodName                   = "/direktiv_flow.Internal/ActionLog"
	Internal_NamespaceVariableParcels_FullMethodName    = "/direktiv_flow.Internal/NamespaceVariableParcels"
	Internal_SetNamespaceVariableParcels_FullMethodName = "/direktiv_flow.Internal/SetNamespaceVariableParcels"
	Internal_WorkflowVariableParcels_FullMethodName     = "/direktiv_flow.Internal/WorkflowVariableParcels"
	Internal_SetWorkflowVariableParcels_FullMethodName  = "/direktiv_flow.Internal/SetWorkflowVariableParcels"
	Internal_InstanceVariableParcels_FullMethodName     = "/direktiv_flow.Internal/InstanceVariableParcels"
	Internal_SetInstanceVariableParcels_FullMethodName  = "/direktiv_flow.Internal/SetInstanceVariableParcels"
	Internal_FileVariableParcels_FullMethodName         = "/direktiv_flow.Internal/FileVariableParcels"
)

// InternalClient is the client API for Internal service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InternalClient interface {
	ReportActionResults(ctx context.Context, in *ReportActionResultsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ActionLog(ctx context.Context, in *ActionLogRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	NamespaceVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_NamespaceVariableParcelsClient, error)
	SetNamespaceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetNamespaceVariableParcelsClient, error)
	WorkflowVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_WorkflowVariableParcelsClient, error)
	SetWorkflowVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetWorkflowVariableParcelsClient, error)
	InstanceVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_InstanceVariableParcelsClient, error)
	SetInstanceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetInstanceVariableParcelsClient, error)
	FileVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_FileVariableParcelsClient, error)
}

type internalClient struct {
	cc grpc.ClientConnInterface
}

func NewInternalClient(cc grpc.ClientConnInterface) InternalClient {
	return &internalClient{cc}
}

func (c *internalClient) ReportActionResults(ctx context.Context, in *ReportActionResultsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Internal_ReportActionResults_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) ActionLog(ctx context.Context, in *ActionLogRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, Internal_ActionLog_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *internalClient) NamespaceVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_NamespaceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[0], Internal_NamespaceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalNamespaceVariableParcelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_NamespaceVariableParcelsClient interface {
	Recv() (*VariableInternalResponse, error)
	grpc.ClientStream
}

type internalNamespaceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalNamespaceVariableParcelsClient) Recv() (*VariableInternalResponse, error) {
	m := new(VariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) SetNamespaceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetNamespaceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[1], Internal_SetNamespaceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalSetNamespaceVariableParcelsClient{stream}
	return x, nil
}

type Internal_SetNamespaceVariableParcelsClient interface {
	Send(*SetVariableInternalRequest) error
	CloseAndRecv() (*SetVariableInternalResponse, error)
	grpc.ClientStream
}

type internalSetNamespaceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalSetNamespaceVariableParcelsClient) Send(m *SetVariableInternalRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *internalSetNamespaceVariableParcelsClient) CloseAndRecv() (*SetVariableInternalResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetVariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) WorkflowVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_WorkflowVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[2], Internal_WorkflowVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalWorkflowVariableParcelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_WorkflowVariableParcelsClient interface {
	Recv() (*VariableInternalResponse, error)
	grpc.ClientStream
}

type internalWorkflowVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalWorkflowVariableParcelsClient) Recv() (*VariableInternalResponse, error) {
	m := new(VariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) SetWorkflowVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetWorkflowVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[3], Internal_SetWorkflowVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalSetWorkflowVariableParcelsClient{stream}
	return x, nil
}

type Internal_SetWorkflowVariableParcelsClient interface {
	Send(*SetVariableInternalRequest) error
	CloseAndRecv() (*SetVariableInternalResponse, error)
	grpc.ClientStream
}

type internalSetWorkflowVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalSetWorkflowVariableParcelsClient) Send(m *SetVariableInternalRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *internalSetWorkflowVariableParcelsClient) CloseAndRecv() (*SetVariableInternalResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetVariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) InstanceVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_InstanceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[4], Internal_InstanceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalInstanceVariableParcelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_InstanceVariableParcelsClient interface {
	Recv() (*VariableInternalResponse, error)
	grpc.ClientStream
}

type internalInstanceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalInstanceVariableParcelsClient) Recv() (*VariableInternalResponse, error) {
	m := new(VariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) SetInstanceVariableParcels(ctx context.Context, opts ...grpc.CallOption) (Internal_SetInstanceVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[5], Internal_SetInstanceVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalSetInstanceVariableParcelsClient{stream}
	return x, nil
}

type Internal_SetInstanceVariableParcelsClient interface {
	Send(*SetVariableInternalRequest) error
	CloseAndRecv() (*SetVariableInternalResponse, error)
	grpc.ClientStream
}

type internalSetInstanceVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalSetInstanceVariableParcelsClient) Send(m *SetVariableInternalRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *internalSetInstanceVariableParcelsClient) CloseAndRecv() (*SetVariableInternalResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(SetVariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *internalClient) FileVariableParcels(ctx context.Context, in *VariableInternalRequest, opts ...grpc.CallOption) (Internal_FileVariableParcelsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Internal_ServiceDesc.Streams[6], Internal_FileVariableParcels_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &internalFileVariableParcelsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Internal_FileVariableParcelsClient interface {
	Recv() (*VariableInternalResponse, error)
	grpc.ClientStream
}

type internalFileVariableParcelsClient struct {
	grpc.ClientStream
}

func (x *internalFileVariableParcelsClient) Recv() (*VariableInternalResponse, error) {
	m := new(VariableInternalResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// InternalServer is the server API for Internal service.
// All implementations must embed UnimplementedInternalServer
// for forward compatibility
type InternalServer interface {
	ReportActionResults(context.Context, *ReportActionResultsRequest) (*emptypb.Empty, error)
	ActionLog(context.Context, *ActionLogRequest) (*emptypb.Empty, error)
	NamespaceVariableParcels(*VariableInternalRequest, Internal_NamespaceVariableParcelsServer) error
	SetNamespaceVariableParcels(Internal_SetNamespaceVariableParcelsServer) error
	WorkflowVariableParcels(*VariableInternalRequest, Internal_WorkflowVariableParcelsServer) error
	SetWorkflowVariableParcels(Internal_SetWorkflowVariableParcelsServer) error
	InstanceVariableParcels(*VariableInternalRequest, Internal_InstanceVariableParcelsServer) error
	SetInstanceVariableParcels(Internal_SetInstanceVariableParcelsServer) error
	FileVariableParcels(*VariableInternalRequest, Internal_FileVariableParcelsServer) error
	mustEmbedUnimplementedInternalServer()
}

// UnimplementedInternalServer must be embedded to have forward compatible implementations.
type UnimplementedInternalServer struct {
}

func (UnimplementedInternalServer) ReportActionResults(context.Context, *ReportActionResultsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportActionResults not implemented")
}
func (UnimplementedInternalServer) ActionLog(context.Context, *ActionLogRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ActionLog not implemented")
}
func (UnimplementedInternalServer) NamespaceVariableParcels(*VariableInternalRequest, Internal_NamespaceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method NamespaceVariableParcels not implemented")
}
func (UnimplementedInternalServer) SetNamespaceVariableParcels(Internal_SetNamespaceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method SetNamespaceVariableParcels not implemented")
}
func (UnimplementedInternalServer) WorkflowVariableParcels(*VariableInternalRequest, Internal_WorkflowVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method WorkflowVariableParcels not implemented")
}
func (UnimplementedInternalServer) SetWorkflowVariableParcels(Internal_SetWorkflowVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method SetWorkflowVariableParcels not implemented")
}
func (UnimplementedInternalServer) InstanceVariableParcels(*VariableInternalRequest, Internal_InstanceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method InstanceVariableParcels not implemented")
}
func (UnimplementedInternalServer) SetInstanceVariableParcels(Internal_SetInstanceVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method SetInstanceVariableParcels not implemented")
}
func (UnimplementedInternalServer) FileVariableParcels(*VariableInternalRequest, Internal_FileVariableParcelsServer) error {
	return status.Errorf(codes.Unimplemented, "method FileVariableParcels not implemented")
}
func (UnimplementedInternalServer) mustEmbedUnimplementedInternalServer() {}

// UnsafeInternalServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InternalServer will
// result in compilation errors.
type UnsafeInternalServer interface {
	mustEmbedUnimplementedInternalServer()
}

func RegisterInternalServer(s grpc.ServiceRegistrar, srv InternalServer) {
	s.RegisterService(&Internal_ServiceDesc, srv)
}

func _Internal_ReportActionResults_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportActionResultsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).ReportActionResults(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Internal_ReportActionResults_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).ReportActionResults(ctx, req.(*ReportActionResultsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_ActionLog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActionLogRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InternalServer).ActionLog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Internal_ActionLog_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InternalServer).ActionLog(ctx, req.(*ActionLogRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Internal_NamespaceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VariableInternalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).NamespaceVariableParcels(m, &internalNamespaceVariableParcelsServer{stream})
}

type Internal_NamespaceVariableParcelsServer interface {
	Send(*VariableInternalResponse) error
	grpc.ServerStream
}

type internalNamespaceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalNamespaceVariableParcelsServer) Send(m *VariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_SetNamespaceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InternalServer).SetNamespaceVariableParcels(&internalSetNamespaceVariableParcelsServer{stream})
}

type Internal_SetNamespaceVariableParcelsServer interface {
	SendAndClose(*SetVariableInternalResponse) error
	Recv() (*SetVariableInternalRequest, error)
	grpc.ServerStream
}

type internalSetNamespaceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalSetNamespaceVariableParcelsServer) SendAndClose(m *SetVariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *internalSetNamespaceVariableParcelsServer) Recv() (*SetVariableInternalRequest, error) {
	m := new(SetVariableInternalRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Internal_WorkflowVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VariableInternalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).WorkflowVariableParcels(m, &internalWorkflowVariableParcelsServer{stream})
}

type Internal_WorkflowVariableParcelsServer interface {
	Send(*VariableInternalResponse) error
	grpc.ServerStream
}

type internalWorkflowVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalWorkflowVariableParcelsServer) Send(m *VariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_SetWorkflowVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InternalServer).SetWorkflowVariableParcels(&internalSetWorkflowVariableParcelsServer{stream})
}

type Internal_SetWorkflowVariableParcelsServer interface {
	SendAndClose(*SetVariableInternalResponse) error
	Recv() (*SetVariableInternalRequest, error)
	grpc.ServerStream
}

type internalSetWorkflowVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalSetWorkflowVariableParcelsServer) SendAndClose(m *SetVariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *internalSetWorkflowVariableParcelsServer) Recv() (*SetVariableInternalRequest, error) {
	m := new(SetVariableInternalRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Internal_InstanceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VariableInternalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).InstanceVariableParcels(m, &internalInstanceVariableParcelsServer{stream})
}

type Internal_InstanceVariableParcelsServer interface {
	Send(*VariableInternalResponse) error
	grpc.ServerStream
}

type internalInstanceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalInstanceVariableParcelsServer) Send(m *VariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _Internal_SetInstanceVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(InternalServer).SetInstanceVariableParcels(&internalSetInstanceVariableParcelsServer{stream})
}

type Internal_SetInstanceVariableParcelsServer interface {
	SendAndClose(*SetVariableInternalResponse) error
	Recv() (*SetVariableInternalRequest, error)
	grpc.ServerStream
}

type internalSetInstanceVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalSetInstanceVariableParcelsServer) SendAndClose(m *SetVariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *internalSetInstanceVariableParcelsServer) Recv() (*SetVariableInternalRequest, error) {
	m := new(SetVariableInternalRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Internal_FileVariableParcels_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(VariableInternalRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InternalServer).FileVariableParcels(m, &internalFileVariableParcelsServer{stream})
}

type Internal_FileVariableParcelsServer interface {
	Send(*VariableInternalResponse) error
	grpc.ServerStream
}

type internalFileVariableParcelsServer struct {
	grpc.ServerStream
}

func (x *internalFileVariableParcelsServer) Send(m *VariableInternalResponse) error {
	return x.ServerStream.SendMsg(m)
}

// Internal_ServiceDesc is the grpc.ServiceDesc for Internal service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Internal_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "direktiv_flow.Internal",
	HandlerType: (*InternalServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ReportActionResults",
			Handler:    _Internal_ReportActionResults_Handler,
		},
		{
			MethodName: "ActionLog",
			Handler:    _Internal_ActionLog_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "NamespaceVariableParcels",
			Handler:       _Internal_NamespaceVariableParcels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetNamespaceVariableParcels",
			Handler:       _Internal_SetNamespaceVariableParcels_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "WorkflowVariableParcels",
			Handler:       _Internal_WorkflowVariableParcels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetWorkflowVariableParcels",
			Handler:       _Internal_SetWorkflowVariableParcels_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "InstanceVariableParcels",
			Handler:       _Internal_InstanceVariableParcels_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "SetInstanceVariableParcels",
			Handler:       _Internal_SetInstanceVariableParcels_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "FileVariableParcels",
			Handler:       _Internal_FileVariableParcels_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/flow/grpc/protocol.proto",
}

const (
	Eventing_RequestEvents_FullMethodName = "/direktiv_flow.Eventing/RequestEvents"
)

// EventingClient is the client API for Eventing service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventingClient interface {
	RequestEvents(ctx context.Context, in *EventingRequest, opts ...grpc.CallOption) (Eventing_RequestEventsClient, error)
}

type eventingClient struct {
	cc grpc.ClientConnInterface
}

func NewEventingClient(cc grpc.ClientConnInterface) EventingClient {
	return &eventingClient{cc}
}

func (c *eventingClient) RequestEvents(ctx context.Context, in *EventingRequest, opts ...grpc.CallOption) (Eventing_RequestEventsClient, error) {
	stream, err := c.cc.NewStream(ctx, &Eventing_ServiceDesc.Streams[0], Eventing_RequestEvents_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &eventingRequestEventsClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Eventing_RequestEventsClient interface {
	Recv() (*CloudEvent, error)
	grpc.ClientStream
}

type eventingRequestEventsClient struct {
	grpc.ClientStream
}

func (x *eventingRequestEventsClient) Recv() (*CloudEvent, error) {
	m := new(CloudEvent)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EventingServer is the server API for Eventing service.
// All implementations must embed UnimplementedEventingServer
// for forward compatibility
type EventingServer interface {
	RequestEvents(*EventingRequest, Eventing_RequestEventsServer) error
	mustEmbedUnimplementedEventingServer()
}

// UnimplementedEventingServer must be embedded to have forward compatible implementations.
type UnimplementedEventingServer struct {
}

func (UnimplementedEventingServer) RequestEvents(*EventingRequest, Eventing_RequestEventsServer) error {
	return status.Errorf(codes.Unimplemented, "method RequestEvents not implemented")
}
func (UnimplementedEventingServer) mustEmbedUnimplementedEventingServer() {}

// UnsafeEventingServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventingServer will
// result in compilation errors.
type UnsafeEventingServer interface {
	mustEmbedUnimplementedEventingServer()
}

func RegisterEventingServer(s grpc.ServiceRegistrar, srv EventingServer) {
	s.RegisterService(&Eventing_ServiceDesc, srv)
}

func _Eventing_RequestEvents_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(EventingRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventingServer).RequestEvents(m, &eventingRequestEventsServer{stream})
}

type Eventing_RequestEventsServer interface {
	Send(*CloudEvent) error
	grpc.ServerStream
}

type eventingRequestEventsServer struct {
	grpc.ServerStream
}

func (x *eventingRequestEventsServer) Send(m *CloudEvent) error {
	return x.ServerStream.SendMsg(m)
}

// Eventing_ServiceDesc is the grpc.ServiceDesc for Eventing service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Eventing_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "direktiv_flow.Eventing",
	HandlerType: (*EventingServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RequestEvents",
			Handler:       _Eventing_RequestEvents_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "pkg/flow/grpc/protocol.proto",
}
