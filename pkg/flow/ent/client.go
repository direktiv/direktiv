// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"

	"github.com/direktiv/direktiv/pkg/flow/ent/migrate"
	"github.com/google/uuid"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"github.com/direktiv/direktiv/pkg/flow/ent/annotation"
	"github.com/direktiv/direktiv/pkg/flow/ent/cloudeventfilters"
	"github.com/direktiv/direktiv/pkg/flow/ent/cloudevents"
	"github.com/direktiv/direktiv/pkg/flow/ent/events"
	"github.com/direktiv/direktiv/pkg/flow/ent/eventswait"
	"github.com/direktiv/direktiv/pkg/flow/ent/instance"
	"github.com/direktiv/direktiv/pkg/flow/ent/instanceruntime"
	"github.com/direktiv/direktiv/pkg/flow/ent/logmsg"
	"github.com/direktiv/direktiv/pkg/flow/ent/namespace"
	"github.com/direktiv/direktiv/pkg/flow/ent/services"
	"github.com/direktiv/direktiv/pkg/flow/ent/vardata"
	"github.com/direktiv/direktiv/pkg/flow/ent/varref"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Annotation is the client for interacting with the Annotation builders.
	Annotation *AnnotationClient
	// CloudEventFilters is the client for interacting with the CloudEventFilters builders.
	CloudEventFilters *CloudEventFiltersClient
	// CloudEvents is the client for interacting with the CloudEvents builders.
	CloudEvents *CloudEventsClient
	// Events is the client for interacting with the Events builders.
	Events *EventsClient
	// EventsWait is the client for interacting with the EventsWait builders.
	EventsWait *EventsWaitClient
	// Instance is the client for interacting with the Instance builders.
	Instance *InstanceClient
	// InstanceRuntime is the client for interacting with the InstanceRuntime builders.
	InstanceRuntime *InstanceRuntimeClient
	// LogMsg is the client for interacting with the LogMsg builders.
	LogMsg *LogMsgClient
	// Namespace is the client for interacting with the Namespace builders.
	Namespace *NamespaceClient
	// Services is the client for interacting with the Services builders.
	Services *ServicesClient
	// VarData is the client for interacting with the VarData builders.
	VarData *VarDataClient
	// VarRef is the client for interacting with the VarRef builders.
	VarRef *VarRefClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Annotation = NewAnnotationClient(c.config)
	c.CloudEventFilters = NewCloudEventFiltersClient(c.config)
	c.CloudEvents = NewCloudEventsClient(c.config)
	c.Events = NewEventsClient(c.config)
	c.EventsWait = NewEventsWaitClient(c.config)
	c.Instance = NewInstanceClient(c.config)
	c.InstanceRuntime = NewInstanceRuntimeClient(c.config)
	c.LogMsg = NewLogMsgClient(c.config)
	c.Namespace = NewNamespaceClient(c.config)
	c.Services = NewServicesClient(c.config)
	c.VarData = NewVarDataClient(c.config)
	c.VarRef = NewVarRefClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Annotation:        NewAnnotationClient(cfg),
		CloudEventFilters: NewCloudEventFiltersClient(cfg),
		CloudEvents:       NewCloudEventsClient(cfg),
		Events:            NewEventsClient(cfg),
		EventsWait:        NewEventsWaitClient(cfg),
		Instance:          NewInstanceClient(cfg),
		InstanceRuntime:   NewInstanceRuntimeClient(cfg),
		LogMsg:            NewLogMsgClient(cfg),
		Namespace:         NewNamespaceClient(cfg),
		Services:          NewServicesClient(cfg),
		VarData:           NewVarDataClient(cfg),
		VarRef:            NewVarRefClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:               ctx,
		config:            cfg,
		Annotation:        NewAnnotationClient(cfg),
		CloudEventFilters: NewCloudEventFiltersClient(cfg),
		CloudEvents:       NewCloudEventsClient(cfg),
		Events:            NewEventsClient(cfg),
		EventsWait:        NewEventsWaitClient(cfg),
		Instance:          NewInstanceClient(cfg),
		InstanceRuntime:   NewInstanceRuntimeClient(cfg),
		LogMsg:            NewLogMsgClient(cfg),
		Namespace:         NewNamespaceClient(cfg),
		Services:          NewServicesClient(cfg),
		VarData:           NewVarDataClient(cfg),
		VarRef:            NewVarRefClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Annotation.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Annotation, c.CloudEventFilters, c.CloudEvents, c.Events, c.EventsWait,
		c.Instance, c.InstanceRuntime, c.LogMsg, c.Namespace, c.Services, c.VarData,
		c.VarRef,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Annotation, c.CloudEventFilters, c.CloudEvents, c.Events, c.EventsWait,
		c.Instance, c.InstanceRuntime, c.LogMsg, c.Namespace, c.Services, c.VarData,
		c.VarRef,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AnnotationMutation:
		return c.Annotation.mutate(ctx, m)
	case *CloudEventFiltersMutation:
		return c.CloudEventFilters.mutate(ctx, m)
	case *CloudEventsMutation:
		return c.CloudEvents.mutate(ctx, m)
	case *EventsMutation:
		return c.Events.mutate(ctx, m)
	case *EventsWaitMutation:
		return c.EventsWait.mutate(ctx, m)
	case *InstanceMutation:
		return c.Instance.mutate(ctx, m)
	case *InstanceRuntimeMutation:
		return c.InstanceRuntime.mutate(ctx, m)
	case *LogMsgMutation:
		return c.LogMsg.mutate(ctx, m)
	case *NamespaceMutation:
		return c.Namespace.mutate(ctx, m)
	case *ServicesMutation:
		return c.Services.mutate(ctx, m)
	case *VarDataMutation:
		return c.VarData.mutate(ctx, m)
	case *VarRefMutation:
		return c.VarRef.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AnnotationClient is a client for the Annotation schema.
type AnnotationClient struct {
	config
}

// NewAnnotationClient returns a client for the Annotation from the given config.
func NewAnnotationClient(c config) *AnnotationClient {
	return &AnnotationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `annotation.Hooks(f(g(h())))`.
func (c *AnnotationClient) Use(hooks ...Hook) {
	c.hooks.Annotation = append(c.hooks.Annotation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `annotation.Intercept(f(g(h())))`.
func (c *AnnotationClient) Intercept(interceptors ...Interceptor) {
	c.inters.Annotation = append(c.inters.Annotation, interceptors...)
}

// Create returns a builder for creating a Annotation entity.
func (c *AnnotationClient) Create() *AnnotationCreate {
	mutation := newAnnotationMutation(c.config, OpCreate)
	return &AnnotationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Annotation entities.
func (c *AnnotationClient) CreateBulk(builders ...*AnnotationCreate) *AnnotationCreateBulk {
	return &AnnotationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Annotation.
func (c *AnnotationClient) Update() *AnnotationUpdate {
	mutation := newAnnotationMutation(c.config, OpUpdate)
	return &AnnotationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AnnotationClient) UpdateOne(a *Annotation) *AnnotationUpdateOne {
	mutation := newAnnotationMutation(c.config, OpUpdateOne, withAnnotation(a))
	return &AnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AnnotationClient) UpdateOneID(id uuid.UUID) *AnnotationUpdateOne {
	mutation := newAnnotationMutation(c.config, OpUpdateOne, withAnnotationID(id))
	return &AnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Annotation.
func (c *AnnotationClient) Delete() *AnnotationDelete {
	mutation := newAnnotationMutation(c.config, OpDelete)
	return &AnnotationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AnnotationClient) DeleteOne(a *Annotation) *AnnotationDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AnnotationClient) DeleteOneID(id uuid.UUID) *AnnotationDeleteOne {
	builder := c.Delete().Where(annotation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AnnotationDeleteOne{builder}
}

// Query returns a query builder for Annotation.
func (c *AnnotationClient) Query() *AnnotationQuery {
	return &AnnotationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAnnotation},
		inters: c.Interceptors(),
	}
}

// Get returns a Annotation entity by its id.
func (c *AnnotationClient) Get(ctx context.Context, id uuid.UUID) (*Annotation, error) {
	return c.Query().Where(annotation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AnnotationClient) GetX(ctx context.Context, id uuid.UUID) *Annotation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a Annotation.
func (c *AnnotationClient) QueryNamespace(a *Annotation) *NamespaceQuery {
	query := (&NamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(annotation.Table, annotation.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, annotation.NamespaceTable, annotation.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstance queries the instance edge of a Annotation.
func (c *AnnotationClient) QueryInstance(a *Annotation) *InstanceQuery {
	query := (&InstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(annotation.Table, annotation.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, annotation.InstanceTable, annotation.InstanceColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AnnotationClient) Hooks() []Hook {
	return c.hooks.Annotation
}

// Interceptors returns the client interceptors.
func (c *AnnotationClient) Interceptors() []Interceptor {
	return c.inters.Annotation
}

func (c *AnnotationClient) mutate(ctx context.Context, m *AnnotationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AnnotationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AnnotationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AnnotationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AnnotationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Annotation mutation op: %q", m.Op())
	}
}

// CloudEventFiltersClient is a client for the CloudEventFilters schema.
type CloudEventFiltersClient struct {
	config
}

// NewCloudEventFiltersClient returns a client for the CloudEventFilters from the given config.
func NewCloudEventFiltersClient(c config) *CloudEventFiltersClient {
	return &CloudEventFiltersClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cloudeventfilters.Hooks(f(g(h())))`.
func (c *CloudEventFiltersClient) Use(hooks ...Hook) {
	c.hooks.CloudEventFilters = append(c.hooks.CloudEventFilters, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cloudeventfilters.Intercept(f(g(h())))`.
func (c *CloudEventFiltersClient) Intercept(interceptors ...Interceptor) {
	c.inters.CloudEventFilters = append(c.inters.CloudEventFilters, interceptors...)
}

// Create returns a builder for creating a CloudEventFilters entity.
func (c *CloudEventFiltersClient) Create() *CloudEventFiltersCreate {
	mutation := newCloudEventFiltersMutation(c.config, OpCreate)
	return &CloudEventFiltersCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CloudEventFilters entities.
func (c *CloudEventFiltersClient) CreateBulk(builders ...*CloudEventFiltersCreate) *CloudEventFiltersCreateBulk {
	return &CloudEventFiltersCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CloudEventFilters.
func (c *CloudEventFiltersClient) Update() *CloudEventFiltersUpdate {
	mutation := newCloudEventFiltersMutation(c.config, OpUpdate)
	return &CloudEventFiltersUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CloudEventFiltersClient) UpdateOne(cef *CloudEventFilters) *CloudEventFiltersUpdateOne {
	mutation := newCloudEventFiltersMutation(c.config, OpUpdateOne, withCloudEventFilters(cef))
	return &CloudEventFiltersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CloudEventFiltersClient) UpdateOneID(id int) *CloudEventFiltersUpdateOne {
	mutation := newCloudEventFiltersMutation(c.config, OpUpdateOne, withCloudEventFiltersID(id))
	return &CloudEventFiltersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CloudEventFilters.
func (c *CloudEventFiltersClient) Delete() *CloudEventFiltersDelete {
	mutation := newCloudEventFiltersMutation(c.config, OpDelete)
	return &CloudEventFiltersDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CloudEventFiltersClient) DeleteOne(cef *CloudEventFilters) *CloudEventFiltersDeleteOne {
	return c.DeleteOneID(cef.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CloudEventFiltersClient) DeleteOneID(id int) *CloudEventFiltersDeleteOne {
	builder := c.Delete().Where(cloudeventfilters.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CloudEventFiltersDeleteOne{builder}
}

// Query returns a query builder for CloudEventFilters.
func (c *CloudEventFiltersClient) Query() *CloudEventFiltersQuery {
	return &CloudEventFiltersQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCloudEventFilters},
		inters: c.Interceptors(),
	}
}

// Get returns a CloudEventFilters entity by its id.
func (c *CloudEventFiltersClient) Get(ctx context.Context, id int) (*CloudEventFilters, error) {
	return c.Query().Where(cloudeventfilters.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CloudEventFiltersClient) GetX(ctx context.Context, id int) *CloudEventFilters {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a CloudEventFilters.
func (c *CloudEventFiltersClient) QueryNamespace(cef *CloudEventFilters) *NamespaceQuery {
	query := (&NamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := cef.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cloudeventfilters.Table, cloudeventfilters.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, cloudeventfilters.NamespaceTable, cloudeventfilters.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(cef.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CloudEventFiltersClient) Hooks() []Hook {
	return c.hooks.CloudEventFilters
}

// Interceptors returns the client interceptors.
func (c *CloudEventFiltersClient) Interceptors() []Interceptor {
	return c.inters.CloudEventFilters
}

func (c *CloudEventFiltersClient) mutate(ctx context.Context, m *CloudEventFiltersMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CloudEventFiltersCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CloudEventFiltersUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CloudEventFiltersUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CloudEventFiltersDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CloudEventFilters mutation op: %q", m.Op())
	}
}

// CloudEventsClient is a client for the CloudEvents schema.
type CloudEventsClient struct {
	config
}

// NewCloudEventsClient returns a client for the CloudEvents from the given config.
func NewCloudEventsClient(c config) *CloudEventsClient {
	return &CloudEventsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cloudevents.Hooks(f(g(h())))`.
func (c *CloudEventsClient) Use(hooks ...Hook) {
	c.hooks.CloudEvents = append(c.hooks.CloudEvents, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `cloudevents.Intercept(f(g(h())))`.
func (c *CloudEventsClient) Intercept(interceptors ...Interceptor) {
	c.inters.CloudEvents = append(c.inters.CloudEvents, interceptors...)
}

// Create returns a builder for creating a CloudEvents entity.
func (c *CloudEventsClient) Create() *CloudEventsCreate {
	mutation := newCloudEventsMutation(c.config, OpCreate)
	return &CloudEventsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CloudEvents entities.
func (c *CloudEventsClient) CreateBulk(builders ...*CloudEventsCreate) *CloudEventsCreateBulk {
	return &CloudEventsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CloudEvents.
func (c *CloudEventsClient) Update() *CloudEventsUpdate {
	mutation := newCloudEventsMutation(c.config, OpUpdate)
	return &CloudEventsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CloudEventsClient) UpdateOne(ce *CloudEvents) *CloudEventsUpdateOne {
	mutation := newCloudEventsMutation(c.config, OpUpdateOne, withCloudEvents(ce))
	return &CloudEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CloudEventsClient) UpdateOneID(id uuid.UUID) *CloudEventsUpdateOne {
	mutation := newCloudEventsMutation(c.config, OpUpdateOne, withCloudEventsID(id))
	return &CloudEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CloudEvents.
func (c *CloudEventsClient) Delete() *CloudEventsDelete {
	mutation := newCloudEventsMutation(c.config, OpDelete)
	return &CloudEventsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *CloudEventsClient) DeleteOne(ce *CloudEvents) *CloudEventsDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *CloudEventsClient) DeleteOneID(id uuid.UUID) *CloudEventsDeleteOne {
	builder := c.Delete().Where(cloudevents.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CloudEventsDeleteOne{builder}
}

// Query returns a query builder for CloudEvents.
func (c *CloudEventsClient) Query() *CloudEventsQuery {
	return &CloudEventsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeCloudEvents},
		inters: c.Interceptors(),
	}
}

// Get returns a CloudEvents entity by its id.
func (c *CloudEventsClient) Get(ctx context.Context, id uuid.UUID) (*CloudEvents, error) {
	return c.Query().Where(cloudevents.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CloudEventsClient) GetX(ctx context.Context, id uuid.UUID) *CloudEvents {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a CloudEvents.
func (c *CloudEventsClient) QueryNamespace(ce *CloudEvents) *NamespaceQuery {
	query := (&NamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cloudevents.Table, cloudevents.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, cloudevents.NamespaceTable, cloudevents.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CloudEventsClient) Hooks() []Hook {
	return c.hooks.CloudEvents
}

// Interceptors returns the client interceptors.
func (c *CloudEventsClient) Interceptors() []Interceptor {
	return c.inters.CloudEvents
}

func (c *CloudEventsClient) mutate(ctx context.Context, m *CloudEventsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&CloudEventsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&CloudEventsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&CloudEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&CloudEventsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown CloudEvents mutation op: %q", m.Op())
	}
}

// EventsClient is a client for the Events schema.
type EventsClient struct {
	config
}

// NewEventsClient returns a client for the Events from the given config.
func NewEventsClient(c config) *EventsClient {
	return &EventsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `events.Hooks(f(g(h())))`.
func (c *EventsClient) Use(hooks ...Hook) {
	c.hooks.Events = append(c.hooks.Events, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `events.Intercept(f(g(h())))`.
func (c *EventsClient) Intercept(interceptors ...Interceptor) {
	c.inters.Events = append(c.inters.Events, interceptors...)
}

// Create returns a builder for creating a Events entity.
func (c *EventsClient) Create() *EventsCreate {
	mutation := newEventsMutation(c.config, OpCreate)
	return &EventsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Events entities.
func (c *EventsClient) CreateBulk(builders ...*EventsCreate) *EventsCreateBulk {
	return &EventsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Events.
func (c *EventsClient) Update() *EventsUpdate {
	mutation := newEventsMutation(c.config, OpUpdate)
	return &EventsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventsClient) UpdateOne(e *Events) *EventsUpdateOne {
	mutation := newEventsMutation(c.config, OpUpdateOne, withEvents(e))
	return &EventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventsClient) UpdateOneID(id uuid.UUID) *EventsUpdateOne {
	mutation := newEventsMutation(c.config, OpUpdateOne, withEventsID(id))
	return &EventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Events.
func (c *EventsClient) Delete() *EventsDelete {
	mutation := newEventsMutation(c.config, OpDelete)
	return &EventsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventsClient) DeleteOne(e *Events) *EventsDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventsClient) DeleteOneID(id uuid.UUID) *EventsDeleteOne {
	builder := c.Delete().Where(events.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventsDeleteOne{builder}
}

// Query returns a query builder for Events.
func (c *EventsClient) Query() *EventsQuery {
	return &EventsQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEvents},
		inters: c.Interceptors(),
	}
}

// Get returns a Events entity by its id.
func (c *EventsClient) Get(ctx context.Context, id uuid.UUID) (*Events, error) {
	return c.Query().Where(events.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventsClient) GetX(ctx context.Context, id uuid.UUID) *Events {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWfeventswait queries the wfeventswait edge of a Events.
func (c *EventsClient) QueryWfeventswait(e *Events) *EventsWaitQuery {
	query := (&EventsWaitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(events.Table, events.FieldID, id),
			sqlgraph.To(eventswait.Table, eventswait.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, events.WfeventswaitTable, events.WfeventswaitColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstance queries the instance edge of a Events.
func (c *EventsClient) QueryInstance(e *Events) *InstanceQuery {
	query := (&InstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(events.Table, events.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, events.InstanceTable, events.InstanceColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNamespace queries the namespace edge of a Events.
func (c *EventsClient) QueryNamespace(e *Events) *NamespaceQuery {
	query := (&NamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(events.Table, events.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, events.NamespaceTable, events.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventsClient) Hooks() []Hook {
	return c.hooks.Events
}

// Interceptors returns the client interceptors.
func (c *EventsClient) Interceptors() []Interceptor {
	return c.inters.Events
}

func (c *EventsClient) mutate(ctx context.Context, m *EventsMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventsCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventsUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventsDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Events mutation op: %q", m.Op())
	}
}

// EventsWaitClient is a client for the EventsWait schema.
type EventsWaitClient struct {
	config
}

// NewEventsWaitClient returns a client for the EventsWait from the given config.
func NewEventsWaitClient(c config) *EventsWaitClient {
	return &EventsWaitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventswait.Hooks(f(g(h())))`.
func (c *EventsWaitClient) Use(hooks ...Hook) {
	c.hooks.EventsWait = append(c.hooks.EventsWait, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `eventswait.Intercept(f(g(h())))`.
func (c *EventsWaitClient) Intercept(interceptors ...Interceptor) {
	c.inters.EventsWait = append(c.inters.EventsWait, interceptors...)
}

// Create returns a builder for creating a EventsWait entity.
func (c *EventsWaitClient) Create() *EventsWaitCreate {
	mutation := newEventsWaitMutation(c.config, OpCreate)
	return &EventsWaitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventsWait entities.
func (c *EventsWaitClient) CreateBulk(builders ...*EventsWaitCreate) *EventsWaitCreateBulk {
	return &EventsWaitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventsWait.
func (c *EventsWaitClient) Update() *EventsWaitUpdate {
	mutation := newEventsWaitMutation(c.config, OpUpdate)
	return &EventsWaitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventsWaitClient) UpdateOne(ew *EventsWait) *EventsWaitUpdateOne {
	mutation := newEventsWaitMutation(c.config, OpUpdateOne, withEventsWait(ew))
	return &EventsWaitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventsWaitClient) UpdateOneID(id uuid.UUID) *EventsWaitUpdateOne {
	mutation := newEventsWaitMutation(c.config, OpUpdateOne, withEventsWaitID(id))
	return &EventsWaitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventsWait.
func (c *EventsWaitClient) Delete() *EventsWaitDelete {
	mutation := newEventsWaitMutation(c.config, OpDelete)
	return &EventsWaitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *EventsWaitClient) DeleteOne(ew *EventsWait) *EventsWaitDeleteOne {
	return c.DeleteOneID(ew.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *EventsWaitClient) DeleteOneID(id uuid.UUID) *EventsWaitDeleteOne {
	builder := c.Delete().Where(eventswait.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventsWaitDeleteOne{builder}
}

// Query returns a query builder for EventsWait.
func (c *EventsWaitClient) Query() *EventsWaitQuery {
	return &EventsWaitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeEventsWait},
		inters: c.Interceptors(),
	}
}

// Get returns a EventsWait entity by its id.
func (c *EventsWaitClient) Get(ctx context.Context, id uuid.UUID) (*EventsWait, error) {
	return c.Query().Where(eventswait.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventsWaitClient) GetX(ctx context.Context, id uuid.UUID) *EventsWait {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflowevent queries the workflowevent edge of a EventsWait.
func (c *EventsWaitClient) QueryWorkflowevent(ew *EventsWait) *EventsQuery {
	query := (&EventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ew.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventswait.Table, eventswait.FieldID, id),
			sqlgraph.To(events.Table, events.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, eventswait.WorkfloweventTable, eventswait.WorkfloweventColumn),
		)
		fromV = sqlgraph.Neighbors(ew.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventsWaitClient) Hooks() []Hook {
	return c.hooks.EventsWait
}

// Interceptors returns the client interceptors.
func (c *EventsWaitClient) Interceptors() []Interceptor {
	return c.inters.EventsWait
}

func (c *EventsWaitClient) mutate(ctx context.Context, m *EventsWaitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&EventsWaitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&EventsWaitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&EventsWaitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&EventsWaitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown EventsWait mutation op: %q", m.Op())
	}
}

// InstanceClient is a client for the Instance schema.
type InstanceClient struct {
	config
}

// NewInstanceClient returns a client for the Instance from the given config.
func NewInstanceClient(c config) *InstanceClient {
	return &InstanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `instance.Hooks(f(g(h())))`.
func (c *InstanceClient) Use(hooks ...Hook) {
	c.hooks.Instance = append(c.hooks.Instance, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `instance.Intercept(f(g(h())))`.
func (c *InstanceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Instance = append(c.inters.Instance, interceptors...)
}

// Create returns a builder for creating a Instance entity.
func (c *InstanceClient) Create() *InstanceCreate {
	mutation := newInstanceMutation(c.config, OpCreate)
	return &InstanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Instance entities.
func (c *InstanceClient) CreateBulk(builders ...*InstanceCreate) *InstanceCreateBulk {
	return &InstanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Instance.
func (c *InstanceClient) Update() *InstanceUpdate {
	mutation := newInstanceMutation(c.config, OpUpdate)
	return &InstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InstanceClient) UpdateOne(i *Instance) *InstanceUpdateOne {
	mutation := newInstanceMutation(c.config, OpUpdateOne, withInstance(i))
	return &InstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InstanceClient) UpdateOneID(id uuid.UUID) *InstanceUpdateOne {
	mutation := newInstanceMutation(c.config, OpUpdateOne, withInstanceID(id))
	return &InstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Instance.
func (c *InstanceClient) Delete() *InstanceDelete {
	mutation := newInstanceMutation(c.config, OpDelete)
	return &InstanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InstanceClient) DeleteOne(i *Instance) *InstanceDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InstanceClient) DeleteOneID(id uuid.UUID) *InstanceDeleteOne {
	builder := c.Delete().Where(instance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InstanceDeleteOne{builder}
}

// Query returns a query builder for Instance.
func (c *InstanceClient) Query() *InstanceQuery {
	return &InstanceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInstance},
		inters: c.Interceptors(),
	}
}

// Get returns a Instance entity by its id.
func (c *InstanceClient) Get(ctx context.Context, id uuid.UUID) (*Instance, error) {
	return c.Query().Where(instance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InstanceClient) GetX(ctx context.Context, id uuid.UUID) *Instance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a Instance.
func (c *InstanceClient) QueryNamespace(i *Instance) *NamespaceQuery {
	query := (&NamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, instance.NamespaceTable, instance.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogs queries the logs edge of a Instance.
func (c *InstanceClient) QueryLogs(i *Instance) *LogMsgQuery {
	query := (&LogMsgClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(logmsg.Table, logmsg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instance.LogsTable, instance.LogsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVars queries the vars edge of a Instance.
func (c *InstanceClient) QueryVars(i *Instance) *VarRefQuery {
	query := (&VarRefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(varref.Table, varref.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instance.VarsTable, instance.VarsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRuntime queries the runtime edge of a Instance.
func (c *InstanceClient) QueryRuntime(i *Instance) *InstanceRuntimeQuery {
	query := (&InstanceRuntimeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(instanceruntime.Table, instanceruntime.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, instance.RuntimeTable, instance.RuntimeColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Instance.
func (c *InstanceClient) QueryChildren(i *Instance) *InstanceRuntimeQuery {
	query := (&InstanceRuntimeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(instanceruntime.Table, instanceruntime.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instance.ChildrenTable, instance.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventlisteners queries the eventlisteners edge of a Instance.
func (c *InstanceClient) QueryEventlisteners(i *Instance) *EventsQuery {
	query := (&EventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(events.Table, events.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instance.EventlistenersTable, instance.EventlistenersColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnnotations queries the annotations edge of a Instance.
func (c *InstanceClient) QueryAnnotations(i *Instance) *AnnotationQuery {
	query := (&AnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(annotation.Table, annotation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instance.AnnotationsTable, instance.AnnotationsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InstanceClient) Hooks() []Hook {
	return c.hooks.Instance
}

// Interceptors returns the client interceptors.
func (c *InstanceClient) Interceptors() []Interceptor {
	return c.inters.Instance
}

func (c *InstanceClient) mutate(ctx context.Context, m *InstanceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InstanceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InstanceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Instance mutation op: %q", m.Op())
	}
}

// InstanceRuntimeClient is a client for the InstanceRuntime schema.
type InstanceRuntimeClient struct {
	config
}

// NewInstanceRuntimeClient returns a client for the InstanceRuntime from the given config.
func NewInstanceRuntimeClient(c config) *InstanceRuntimeClient {
	return &InstanceRuntimeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `instanceruntime.Hooks(f(g(h())))`.
func (c *InstanceRuntimeClient) Use(hooks ...Hook) {
	c.hooks.InstanceRuntime = append(c.hooks.InstanceRuntime, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `instanceruntime.Intercept(f(g(h())))`.
func (c *InstanceRuntimeClient) Intercept(interceptors ...Interceptor) {
	c.inters.InstanceRuntime = append(c.inters.InstanceRuntime, interceptors...)
}

// Create returns a builder for creating a InstanceRuntime entity.
func (c *InstanceRuntimeClient) Create() *InstanceRuntimeCreate {
	mutation := newInstanceRuntimeMutation(c.config, OpCreate)
	return &InstanceRuntimeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InstanceRuntime entities.
func (c *InstanceRuntimeClient) CreateBulk(builders ...*InstanceRuntimeCreate) *InstanceRuntimeCreateBulk {
	return &InstanceRuntimeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InstanceRuntime.
func (c *InstanceRuntimeClient) Update() *InstanceRuntimeUpdate {
	mutation := newInstanceRuntimeMutation(c.config, OpUpdate)
	return &InstanceRuntimeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InstanceRuntimeClient) UpdateOne(ir *InstanceRuntime) *InstanceRuntimeUpdateOne {
	mutation := newInstanceRuntimeMutation(c.config, OpUpdateOne, withInstanceRuntime(ir))
	return &InstanceRuntimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InstanceRuntimeClient) UpdateOneID(id uuid.UUID) *InstanceRuntimeUpdateOne {
	mutation := newInstanceRuntimeMutation(c.config, OpUpdateOne, withInstanceRuntimeID(id))
	return &InstanceRuntimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InstanceRuntime.
func (c *InstanceRuntimeClient) Delete() *InstanceRuntimeDelete {
	mutation := newInstanceRuntimeMutation(c.config, OpDelete)
	return &InstanceRuntimeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *InstanceRuntimeClient) DeleteOne(ir *InstanceRuntime) *InstanceRuntimeDeleteOne {
	return c.DeleteOneID(ir.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *InstanceRuntimeClient) DeleteOneID(id uuid.UUID) *InstanceRuntimeDeleteOne {
	builder := c.Delete().Where(instanceruntime.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InstanceRuntimeDeleteOne{builder}
}

// Query returns a query builder for InstanceRuntime.
func (c *InstanceRuntimeClient) Query() *InstanceRuntimeQuery {
	return &InstanceRuntimeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeInstanceRuntime},
		inters: c.Interceptors(),
	}
}

// Get returns a InstanceRuntime entity by its id.
func (c *InstanceRuntimeClient) Get(ctx context.Context, id uuid.UUID) (*InstanceRuntime, error) {
	return c.Query().Where(instanceruntime.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InstanceRuntimeClient) GetX(ctx context.Context, id uuid.UUID) *InstanceRuntime {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstance queries the instance edge of a InstanceRuntime.
func (c *InstanceRuntimeClient) QueryInstance(ir *InstanceRuntime) *InstanceQuery {
	query := (&InstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ir.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instanceruntime.Table, instanceruntime.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, instanceruntime.InstanceTable, instanceruntime.InstanceColumn),
		)
		fromV = sqlgraph.Neighbors(ir.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCaller queries the caller edge of a InstanceRuntime.
func (c *InstanceRuntimeClient) QueryCaller(ir *InstanceRuntime) *InstanceQuery {
	query := (&InstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ir.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instanceruntime.Table, instanceruntime.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, instanceruntime.CallerTable, instanceruntime.CallerColumn),
		)
		fromV = sqlgraph.Neighbors(ir.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InstanceRuntimeClient) Hooks() []Hook {
	return c.hooks.InstanceRuntime
}

// Interceptors returns the client interceptors.
func (c *InstanceRuntimeClient) Interceptors() []Interceptor {
	return c.inters.InstanceRuntime
}

func (c *InstanceRuntimeClient) mutate(ctx context.Context, m *InstanceRuntimeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&InstanceRuntimeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&InstanceRuntimeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&InstanceRuntimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&InstanceRuntimeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown InstanceRuntime mutation op: %q", m.Op())
	}
}

// LogMsgClient is a client for the LogMsg schema.
type LogMsgClient struct {
	config
}

// NewLogMsgClient returns a client for the LogMsg from the given config.
func NewLogMsgClient(c config) *LogMsgClient {
	return &LogMsgClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logmsg.Hooks(f(g(h())))`.
func (c *LogMsgClient) Use(hooks ...Hook) {
	c.hooks.LogMsg = append(c.hooks.LogMsg, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `logmsg.Intercept(f(g(h())))`.
func (c *LogMsgClient) Intercept(interceptors ...Interceptor) {
	c.inters.LogMsg = append(c.inters.LogMsg, interceptors...)
}

// Create returns a builder for creating a LogMsg entity.
func (c *LogMsgClient) Create() *LogMsgCreate {
	mutation := newLogMsgMutation(c.config, OpCreate)
	return &LogMsgCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LogMsg entities.
func (c *LogMsgClient) CreateBulk(builders ...*LogMsgCreate) *LogMsgCreateBulk {
	return &LogMsgCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LogMsg.
func (c *LogMsgClient) Update() *LogMsgUpdate {
	mutation := newLogMsgMutation(c.config, OpUpdate)
	return &LogMsgUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LogMsgClient) UpdateOne(lm *LogMsg) *LogMsgUpdateOne {
	mutation := newLogMsgMutation(c.config, OpUpdateOne, withLogMsg(lm))
	return &LogMsgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LogMsgClient) UpdateOneID(id uuid.UUID) *LogMsgUpdateOne {
	mutation := newLogMsgMutation(c.config, OpUpdateOne, withLogMsgID(id))
	return &LogMsgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LogMsg.
func (c *LogMsgClient) Delete() *LogMsgDelete {
	mutation := newLogMsgMutation(c.config, OpDelete)
	return &LogMsgDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LogMsgClient) DeleteOne(lm *LogMsg) *LogMsgDeleteOne {
	return c.DeleteOneID(lm.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LogMsgClient) DeleteOneID(id uuid.UUID) *LogMsgDeleteOne {
	builder := c.Delete().Where(logmsg.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LogMsgDeleteOne{builder}
}

// Query returns a query builder for LogMsg.
func (c *LogMsgClient) Query() *LogMsgQuery {
	return &LogMsgQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLogMsg},
		inters: c.Interceptors(),
	}
}

// Get returns a LogMsg entity by its id.
func (c *LogMsgClient) Get(ctx context.Context, id uuid.UUID) (*LogMsg, error) {
	return c.Query().Where(logmsg.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LogMsgClient) GetX(ctx context.Context, id uuid.UUID) *LogMsg {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a LogMsg.
func (c *LogMsgClient) QueryNamespace(lm *LogMsg) *NamespaceQuery {
	query := (&NamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(logmsg.Table, logmsg.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, logmsg.NamespaceTable, logmsg.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(lm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstance queries the instance edge of a LogMsg.
func (c *LogMsgClient) QueryInstance(lm *LogMsg) *InstanceQuery {
	query := (&InstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := lm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(logmsg.Table, logmsg.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, logmsg.InstanceTable, logmsg.InstanceColumn),
		)
		fromV = sqlgraph.Neighbors(lm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LogMsgClient) Hooks() []Hook {
	return c.hooks.LogMsg
}

// Interceptors returns the client interceptors.
func (c *LogMsgClient) Interceptors() []Interceptor {
	return c.inters.LogMsg
}

func (c *LogMsgClient) mutate(ctx context.Context, m *LogMsgMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LogMsgCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LogMsgUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LogMsgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LogMsgDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LogMsg mutation op: %q", m.Op())
	}
}

// NamespaceClient is a client for the Namespace schema.
type NamespaceClient struct {
	config
}

// NewNamespaceClient returns a client for the Namespace from the given config.
func NewNamespaceClient(c config) *NamespaceClient {
	return &NamespaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `namespace.Hooks(f(g(h())))`.
func (c *NamespaceClient) Use(hooks ...Hook) {
	c.hooks.Namespace = append(c.hooks.Namespace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `namespace.Intercept(f(g(h())))`.
func (c *NamespaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Namespace = append(c.inters.Namespace, interceptors...)
}

// Create returns a builder for creating a Namespace entity.
func (c *NamespaceClient) Create() *NamespaceCreate {
	mutation := newNamespaceMutation(c.config, OpCreate)
	return &NamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Namespace entities.
func (c *NamespaceClient) CreateBulk(builders ...*NamespaceCreate) *NamespaceCreateBulk {
	return &NamespaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Namespace.
func (c *NamespaceClient) Update() *NamespaceUpdate {
	mutation := newNamespaceMutation(c.config, OpUpdate)
	return &NamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NamespaceClient) UpdateOne(n *Namespace) *NamespaceUpdateOne {
	mutation := newNamespaceMutation(c.config, OpUpdateOne, withNamespace(n))
	return &NamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NamespaceClient) UpdateOneID(id uuid.UUID) *NamespaceUpdateOne {
	mutation := newNamespaceMutation(c.config, OpUpdateOne, withNamespaceID(id))
	return &NamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Namespace.
func (c *NamespaceClient) Delete() *NamespaceDelete {
	mutation := newNamespaceMutation(c.config, OpDelete)
	return &NamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *NamespaceClient) DeleteOne(n *Namespace) *NamespaceDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *NamespaceClient) DeleteOneID(id uuid.UUID) *NamespaceDeleteOne {
	builder := c.Delete().Where(namespace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NamespaceDeleteOne{builder}
}

// Query returns a query builder for Namespace.
func (c *NamespaceClient) Query() *NamespaceQuery {
	return &NamespaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeNamespace},
		inters: c.Interceptors(),
	}
}

// Get returns a Namespace entity by its id.
func (c *NamespaceClient) Get(ctx context.Context, id uuid.UUID) (*Namespace, error) {
	return c.Query().Where(namespace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NamespaceClient) GetX(ctx context.Context, id uuid.UUID) *Namespace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstances queries the instances edge of a Namespace.
func (c *NamespaceClient) QueryInstances(n *Namespace) *InstanceQuery {
	query := (&InstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.InstancesTable, namespace.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogs queries the logs edge of a Namespace.
func (c *NamespaceClient) QueryLogs(n *Namespace) *LogMsgQuery {
	query := (&LogMsgClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(logmsg.Table, logmsg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.LogsTable, namespace.LogsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVars queries the vars edge of a Namespace.
func (c *NamespaceClient) QueryVars(n *Namespace) *VarRefQuery {
	query := (&VarRefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(varref.Table, varref.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.VarsTable, namespace.VarsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCloudevents queries the cloudevents edge of a Namespace.
func (c *NamespaceClient) QueryCloudevents(n *Namespace) *CloudEventsQuery {
	query := (&CloudEventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(cloudevents.Table, cloudevents.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.CloudeventsTable, namespace.CloudeventsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNamespacelisteners queries the namespacelisteners edge of a Namespace.
func (c *NamespaceClient) QueryNamespacelisteners(n *Namespace) *EventsQuery {
	query := (&EventsClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(events.Table, events.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.NamespacelistenersTable, namespace.NamespacelistenersColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAnnotations queries the annotations edge of a Namespace.
func (c *NamespaceClient) QueryAnnotations(n *Namespace) *AnnotationQuery {
	query := (&AnnotationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(annotation.Table, annotation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.AnnotationsTable, namespace.AnnotationsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCloudeventfilters queries the cloudeventfilters edge of a Namespace.
func (c *NamespaceClient) QueryCloudeventfilters(n *Namespace) *CloudEventFiltersQuery {
	query := (&CloudEventFiltersClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(cloudeventfilters.Table, cloudeventfilters.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.CloudeventfiltersTable, namespace.CloudeventfiltersColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryServices queries the services edge of a Namespace.
func (c *NamespaceClient) QueryServices(n *Namespace) *ServicesQuery {
	query := (&ServicesClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(services.Table, services.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.ServicesTable, namespace.ServicesColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NamespaceClient) Hooks() []Hook {
	return c.hooks.Namespace
}

// Interceptors returns the client interceptors.
func (c *NamespaceClient) Interceptors() []Interceptor {
	return c.inters.Namespace
}

func (c *NamespaceClient) mutate(ctx context.Context, m *NamespaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&NamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&NamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&NamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&NamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Namespace mutation op: %q", m.Op())
	}
}

// ServicesClient is a client for the Services schema.
type ServicesClient struct {
	config
}

// NewServicesClient returns a client for the Services from the given config.
func NewServicesClient(c config) *ServicesClient {
	return &ServicesClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `services.Hooks(f(g(h())))`.
func (c *ServicesClient) Use(hooks ...Hook) {
	c.hooks.Services = append(c.hooks.Services, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `services.Intercept(f(g(h())))`.
func (c *ServicesClient) Intercept(interceptors ...Interceptor) {
	c.inters.Services = append(c.inters.Services, interceptors...)
}

// Create returns a builder for creating a Services entity.
func (c *ServicesClient) Create() *ServicesCreate {
	mutation := newServicesMutation(c.config, OpCreate)
	return &ServicesCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Services entities.
func (c *ServicesClient) CreateBulk(builders ...*ServicesCreate) *ServicesCreateBulk {
	return &ServicesCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Services.
func (c *ServicesClient) Update() *ServicesUpdate {
	mutation := newServicesMutation(c.config, OpUpdate)
	return &ServicesUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServicesClient) UpdateOne(s *Services) *ServicesUpdateOne {
	mutation := newServicesMutation(c.config, OpUpdateOne, withServices(s))
	return &ServicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServicesClient) UpdateOneID(id uuid.UUID) *ServicesUpdateOne {
	mutation := newServicesMutation(c.config, OpUpdateOne, withServicesID(id))
	return &ServicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Services.
func (c *ServicesClient) Delete() *ServicesDelete {
	mutation := newServicesMutation(c.config, OpDelete)
	return &ServicesDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ServicesClient) DeleteOne(s *Services) *ServicesDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ServicesClient) DeleteOneID(id uuid.UUID) *ServicesDeleteOne {
	builder := c.Delete().Where(services.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServicesDeleteOne{builder}
}

// Query returns a query builder for Services.
func (c *ServicesClient) Query() *ServicesQuery {
	return &ServicesQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeServices},
		inters: c.Interceptors(),
	}
}

// Get returns a Services entity by its id.
func (c *ServicesClient) Get(ctx context.Context, id uuid.UUID) (*Services, error) {
	return c.Query().Where(services.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServicesClient) GetX(ctx context.Context, id uuid.UUID) *Services {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a Services.
func (c *ServicesClient) QueryNamespace(s *Services) *NamespaceQuery {
	query := (&NamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(services.Table, services.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, services.NamespaceTable, services.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ServicesClient) Hooks() []Hook {
	return c.hooks.Services
}

// Interceptors returns the client interceptors.
func (c *ServicesClient) Interceptors() []Interceptor {
	return c.inters.Services
}

func (c *ServicesClient) mutate(ctx context.Context, m *ServicesMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ServicesCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ServicesUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ServicesUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ServicesDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Services mutation op: %q", m.Op())
	}
}

// VarDataClient is a client for the VarData schema.
type VarDataClient struct {
	config
}

// NewVarDataClient returns a client for the VarData from the given config.
func NewVarDataClient(c config) *VarDataClient {
	return &VarDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vardata.Hooks(f(g(h())))`.
func (c *VarDataClient) Use(hooks ...Hook) {
	c.hooks.VarData = append(c.hooks.VarData, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `vardata.Intercept(f(g(h())))`.
func (c *VarDataClient) Intercept(interceptors ...Interceptor) {
	c.inters.VarData = append(c.inters.VarData, interceptors...)
}

// Create returns a builder for creating a VarData entity.
func (c *VarDataClient) Create() *VarDataCreate {
	mutation := newVarDataMutation(c.config, OpCreate)
	return &VarDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VarData entities.
func (c *VarDataClient) CreateBulk(builders ...*VarDataCreate) *VarDataCreateBulk {
	return &VarDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VarData.
func (c *VarDataClient) Update() *VarDataUpdate {
	mutation := newVarDataMutation(c.config, OpUpdate)
	return &VarDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VarDataClient) UpdateOne(vd *VarData) *VarDataUpdateOne {
	mutation := newVarDataMutation(c.config, OpUpdateOne, withVarData(vd))
	return &VarDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VarDataClient) UpdateOneID(id uuid.UUID) *VarDataUpdateOne {
	mutation := newVarDataMutation(c.config, OpUpdateOne, withVarDataID(id))
	return &VarDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VarData.
func (c *VarDataClient) Delete() *VarDataDelete {
	mutation := newVarDataMutation(c.config, OpDelete)
	return &VarDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VarDataClient) DeleteOne(vd *VarData) *VarDataDeleteOne {
	return c.DeleteOneID(vd.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VarDataClient) DeleteOneID(id uuid.UUID) *VarDataDeleteOne {
	builder := c.Delete().Where(vardata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VarDataDeleteOne{builder}
}

// Query returns a query builder for VarData.
func (c *VarDataClient) Query() *VarDataQuery {
	return &VarDataQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVarData},
		inters: c.Interceptors(),
	}
}

// Get returns a VarData entity by its id.
func (c *VarDataClient) Get(ctx context.Context, id uuid.UUID) (*VarData, error) {
	return c.Query().Where(vardata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VarDataClient) GetX(ctx context.Context, id uuid.UUID) *VarData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVarrefs queries the varrefs edge of a VarData.
func (c *VarDataClient) QueryVarrefs(vd *VarData) *VarRefQuery {
	query := (&VarRefClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vardata.Table, vardata.FieldID, id),
			sqlgraph.To(varref.Table, varref.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vardata.VarrefsTable, vardata.VarrefsColumn),
		)
		fromV = sqlgraph.Neighbors(vd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VarDataClient) Hooks() []Hook {
	return c.hooks.VarData
}

// Interceptors returns the client interceptors.
func (c *VarDataClient) Interceptors() []Interceptor {
	return c.inters.VarData
}

func (c *VarDataClient) mutate(ctx context.Context, m *VarDataMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VarDataCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VarDataUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VarDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VarDataDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VarData mutation op: %q", m.Op())
	}
}

// VarRefClient is a client for the VarRef schema.
type VarRefClient struct {
	config
}

// NewVarRefClient returns a client for the VarRef from the given config.
func NewVarRefClient(c config) *VarRefClient {
	return &VarRefClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `varref.Hooks(f(g(h())))`.
func (c *VarRefClient) Use(hooks ...Hook) {
	c.hooks.VarRef = append(c.hooks.VarRef, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `varref.Intercept(f(g(h())))`.
func (c *VarRefClient) Intercept(interceptors ...Interceptor) {
	c.inters.VarRef = append(c.inters.VarRef, interceptors...)
}

// Create returns a builder for creating a VarRef entity.
func (c *VarRefClient) Create() *VarRefCreate {
	mutation := newVarRefMutation(c.config, OpCreate)
	return &VarRefCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VarRef entities.
func (c *VarRefClient) CreateBulk(builders ...*VarRefCreate) *VarRefCreateBulk {
	return &VarRefCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VarRef.
func (c *VarRefClient) Update() *VarRefUpdate {
	mutation := newVarRefMutation(c.config, OpUpdate)
	return &VarRefUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VarRefClient) UpdateOne(vr *VarRef) *VarRefUpdateOne {
	mutation := newVarRefMutation(c.config, OpUpdateOne, withVarRef(vr))
	return &VarRefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VarRefClient) UpdateOneID(id uuid.UUID) *VarRefUpdateOne {
	mutation := newVarRefMutation(c.config, OpUpdateOne, withVarRefID(id))
	return &VarRefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VarRef.
func (c *VarRefClient) Delete() *VarRefDelete {
	mutation := newVarRefMutation(c.config, OpDelete)
	return &VarRefDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VarRefClient) DeleteOne(vr *VarRef) *VarRefDeleteOne {
	return c.DeleteOneID(vr.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VarRefClient) DeleteOneID(id uuid.UUID) *VarRefDeleteOne {
	builder := c.Delete().Where(varref.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VarRefDeleteOne{builder}
}

// Query returns a query builder for VarRef.
func (c *VarRefClient) Query() *VarRefQuery {
	return &VarRefQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVarRef},
		inters: c.Interceptors(),
	}
}

// Get returns a VarRef entity by its id.
func (c *VarRefClient) Get(ctx context.Context, id uuid.UUID) (*VarRef, error) {
	return c.Query().Where(varref.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VarRefClient) GetX(ctx context.Context, id uuid.UUID) *VarRef {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVardata queries the vardata edge of a VarRef.
func (c *VarRefClient) QueryVardata(vr *VarRef) *VarDataQuery {
	query := (&VarDataClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(varref.Table, varref.FieldID, id),
			sqlgraph.To(vardata.Table, vardata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, varref.VardataTable, varref.VardataColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNamespace queries the namespace edge of a VarRef.
func (c *VarRefClient) QueryNamespace(vr *VarRef) *NamespaceQuery {
	query := (&NamespaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(varref.Table, varref.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, varref.NamespaceTable, varref.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstance queries the instance edge of a VarRef.
func (c *VarRefClient) QueryInstance(vr *VarRef) *InstanceQuery {
	query := (&InstanceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(varref.Table, varref.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, varref.InstanceTable, varref.InstanceColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VarRefClient) Hooks() []Hook {
	return c.hooks.VarRef
}

// Interceptors returns the client interceptors.
func (c *VarRefClient) Interceptors() []Interceptor {
	return c.inters.VarRef
}

func (c *VarRefClient) mutate(ctx context.Context, m *VarRefMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VarRefCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VarRefUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VarRefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VarRefDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VarRef mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Annotation, CloudEventFilters, CloudEvents, Events, EventsWait, Instance,
		InstanceRuntime, LogMsg, Namespace, Services, VarData, VarRef []ent.Hook
	}
	inters struct {
		Annotation, CloudEventFilters, CloudEvents, Events, EventsWait, Instance,
		InstanceRuntime, LogMsg, Namespace, Services, VarData, VarRef []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
