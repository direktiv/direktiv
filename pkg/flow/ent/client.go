// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/direktiv/direktiv/pkg/flow/ent/migrate"

	"github.com/direktiv/direktiv/pkg/flow/ent/cloudevents"
	"github.com/direktiv/direktiv/pkg/flow/ent/events"
	"github.com/direktiv/direktiv/pkg/flow/ent/eventswait"
	"github.com/direktiv/direktiv/pkg/flow/ent/inode"
	"github.com/direktiv/direktiv/pkg/flow/ent/instance"
	"github.com/direktiv/direktiv/pkg/flow/ent/instanceruntime"
	"github.com/direktiv/direktiv/pkg/flow/ent/logmsg"
	"github.com/direktiv/direktiv/pkg/flow/ent/namespace"
	"github.com/direktiv/direktiv/pkg/flow/ent/ref"
	"github.com/direktiv/direktiv/pkg/flow/ent/revision"
	"github.com/direktiv/direktiv/pkg/flow/ent/route"
	"github.com/direktiv/direktiv/pkg/flow/ent/vardata"
	"github.com/direktiv/direktiv/pkg/flow/ent/varref"
	"github.com/direktiv/direktiv/pkg/flow/ent/workflow"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// CloudEvents is the client for interacting with the CloudEvents builders.
	CloudEvents *CloudEventsClient
	// Events is the client for interacting with the Events builders.
	Events *EventsClient
	// EventsWait is the client for interacting with the EventsWait builders.
	EventsWait *EventsWaitClient
	// Inode is the client for interacting with the Inode builders.
	Inode *InodeClient
	// Instance is the client for interacting with the Instance builders.
	Instance *InstanceClient
	// InstanceRuntime is the client for interacting with the InstanceRuntime builders.
	InstanceRuntime *InstanceRuntimeClient
	// LogMsg is the client for interacting with the LogMsg builders.
	LogMsg *LogMsgClient
	// Namespace is the client for interacting with the Namespace builders.
	Namespace *NamespaceClient
	// Ref is the client for interacting with the Ref builders.
	Ref *RefClient
	// Revision is the client for interacting with the Revision builders.
	Revision *RevisionClient
	// Route is the client for interacting with the Route builders.
	Route *RouteClient
	// VarData is the client for interacting with the VarData builders.
	VarData *VarDataClient
	// VarRef is the client for interacting with the VarRef builders.
	VarRef *VarRefClient
	// Workflow is the client for interacting with the Workflow builders.
	Workflow *WorkflowClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.CloudEvents = NewCloudEventsClient(c.config)
	c.Events = NewEventsClient(c.config)
	c.EventsWait = NewEventsWaitClient(c.config)
	c.Inode = NewInodeClient(c.config)
	c.Instance = NewInstanceClient(c.config)
	c.InstanceRuntime = NewInstanceRuntimeClient(c.config)
	c.LogMsg = NewLogMsgClient(c.config)
	c.Namespace = NewNamespaceClient(c.config)
	c.Ref = NewRefClient(c.config)
	c.Revision = NewRevisionClient(c.config)
	c.Route = NewRouteClient(c.config)
	c.VarData = NewVarDataClient(c.config)
	c.VarRef = NewVarRefClient(c.config)
	c.Workflow = NewWorkflowClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		CloudEvents:     NewCloudEventsClient(cfg),
		Events:          NewEventsClient(cfg),
		EventsWait:      NewEventsWaitClient(cfg),
		Inode:           NewInodeClient(cfg),
		Instance:        NewInstanceClient(cfg),
		InstanceRuntime: NewInstanceRuntimeClient(cfg),
		LogMsg:          NewLogMsgClient(cfg),
		Namespace:       NewNamespaceClient(cfg),
		Ref:             NewRefClient(cfg),
		Revision:        NewRevisionClient(cfg),
		Route:           NewRouteClient(cfg),
		VarData:         NewVarDataClient(cfg),
		VarRef:          NewVarRefClient(cfg),
		Workflow:        NewWorkflowClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:          cfg,
		CloudEvents:     NewCloudEventsClient(cfg),
		Events:          NewEventsClient(cfg),
		EventsWait:      NewEventsWaitClient(cfg),
		Inode:           NewInodeClient(cfg),
		Instance:        NewInstanceClient(cfg),
		InstanceRuntime: NewInstanceRuntimeClient(cfg),
		LogMsg:          NewLogMsgClient(cfg),
		Namespace:       NewNamespaceClient(cfg),
		Ref:             NewRefClient(cfg),
		Revision:        NewRevisionClient(cfg),
		Route:           NewRouteClient(cfg),
		VarData:         NewVarDataClient(cfg),
		VarRef:          NewVarRefClient(cfg),
		Workflow:        NewWorkflowClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		CloudEvents.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.CloudEvents.Use(hooks...)
	c.Events.Use(hooks...)
	c.EventsWait.Use(hooks...)
	c.Inode.Use(hooks...)
	c.Instance.Use(hooks...)
	c.InstanceRuntime.Use(hooks...)
	c.LogMsg.Use(hooks...)
	c.Namespace.Use(hooks...)
	c.Ref.Use(hooks...)
	c.Revision.Use(hooks...)
	c.Route.Use(hooks...)
	c.VarData.Use(hooks...)
	c.VarRef.Use(hooks...)
	c.Workflow.Use(hooks...)
}

// CloudEventsClient is a client for the CloudEvents schema.
type CloudEventsClient struct {
	config
}

// NewCloudEventsClient returns a client for the CloudEvents from the given config.
func NewCloudEventsClient(c config) *CloudEventsClient {
	return &CloudEventsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `cloudevents.Hooks(f(g(h())))`.
func (c *CloudEventsClient) Use(hooks ...Hook) {
	c.hooks.CloudEvents = append(c.hooks.CloudEvents, hooks...)
}

// Create returns a create builder for CloudEvents.
func (c *CloudEventsClient) Create() *CloudEventsCreate {
	mutation := newCloudEventsMutation(c.config, OpCreate)
	return &CloudEventsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of CloudEvents entities.
func (c *CloudEventsClient) CreateBulk(builders ...*CloudEventsCreate) *CloudEventsCreateBulk {
	return &CloudEventsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for CloudEvents.
func (c *CloudEventsClient) Update() *CloudEventsUpdate {
	mutation := newCloudEventsMutation(c.config, OpUpdate)
	return &CloudEventsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *CloudEventsClient) UpdateOne(ce *CloudEvents) *CloudEventsUpdateOne {
	mutation := newCloudEventsMutation(c.config, OpUpdateOne, withCloudEvents(ce))
	return &CloudEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *CloudEventsClient) UpdateOneID(id uuid.UUID) *CloudEventsUpdateOne {
	mutation := newCloudEventsMutation(c.config, OpUpdateOne, withCloudEventsID(id))
	return &CloudEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for CloudEvents.
func (c *CloudEventsClient) Delete() *CloudEventsDelete {
	mutation := newCloudEventsMutation(c.config, OpDelete)
	return &CloudEventsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *CloudEventsClient) DeleteOne(ce *CloudEvents) *CloudEventsDeleteOne {
	return c.DeleteOneID(ce.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *CloudEventsClient) DeleteOneID(id uuid.UUID) *CloudEventsDeleteOne {
	builder := c.Delete().Where(cloudevents.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &CloudEventsDeleteOne{builder}
}

// Query returns a query builder for CloudEvents.
func (c *CloudEventsClient) Query() *CloudEventsQuery {
	return &CloudEventsQuery{
		config: c.config,
	}
}

// Get returns a CloudEvents entity by its id.
func (c *CloudEventsClient) Get(ctx context.Context, id uuid.UUID) (*CloudEvents, error) {
	return c.Query().Where(cloudevents.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *CloudEventsClient) GetX(ctx context.Context, id uuid.UUID) *CloudEvents {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a CloudEvents.
func (c *CloudEventsClient) QueryNamespace(ce *CloudEvents) *NamespaceQuery {
	query := &NamespaceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ce.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(cloudevents.Table, cloudevents.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, cloudevents.NamespaceTable, cloudevents.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(ce.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *CloudEventsClient) Hooks() []Hook {
	return c.hooks.CloudEvents
}

// EventsClient is a client for the Events schema.
type EventsClient struct {
	config
}

// NewEventsClient returns a client for the Events from the given config.
func NewEventsClient(c config) *EventsClient {
	return &EventsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `events.Hooks(f(g(h())))`.
func (c *EventsClient) Use(hooks ...Hook) {
	c.hooks.Events = append(c.hooks.Events, hooks...)
}

// Create returns a create builder for Events.
func (c *EventsClient) Create() *EventsCreate {
	mutation := newEventsMutation(c.config, OpCreate)
	return &EventsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Events entities.
func (c *EventsClient) CreateBulk(builders ...*EventsCreate) *EventsCreateBulk {
	return &EventsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Events.
func (c *EventsClient) Update() *EventsUpdate {
	mutation := newEventsMutation(c.config, OpUpdate)
	return &EventsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventsClient) UpdateOne(e *Events) *EventsUpdateOne {
	mutation := newEventsMutation(c.config, OpUpdateOne, withEvents(e))
	return &EventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventsClient) UpdateOneID(id uuid.UUID) *EventsUpdateOne {
	mutation := newEventsMutation(c.config, OpUpdateOne, withEventsID(id))
	return &EventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Events.
func (c *EventsClient) Delete() *EventsDelete {
	mutation := newEventsMutation(c.config, OpDelete)
	return &EventsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EventsClient) DeleteOne(e *Events) *EventsDeleteOne {
	return c.DeleteOneID(e.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EventsClient) DeleteOneID(id uuid.UUID) *EventsDeleteOne {
	builder := c.Delete().Where(events.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventsDeleteOne{builder}
}

// Query returns a query builder for Events.
func (c *EventsClient) Query() *EventsQuery {
	return &EventsQuery{
		config: c.config,
	}
}

// Get returns a Events entity by its id.
func (c *EventsClient) Get(ctx context.Context, id uuid.UUID) (*Events, error) {
	return c.Query().Where(events.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventsClient) GetX(ctx context.Context, id uuid.UUID) *Events {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a Events.
func (c *EventsClient) QueryWorkflow(e *Events) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(events.Table, events.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, events.WorkflowTable, events.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWfeventswait queries the wfeventswait edge of a Events.
func (c *EventsClient) QueryWfeventswait(e *Events) *EventsWaitQuery {
	query := &EventsWaitQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(events.Table, events.FieldID, id),
			sqlgraph.To(eventswait.Table, eventswait.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, events.WfeventswaitTable, events.WfeventswaitColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstance queries the instance edge of a Events.
func (c *EventsClient) QueryInstance(e *Events) *InstanceQuery {
	query := &InstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := e.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(events.Table, events.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, events.InstanceTable, events.InstanceColumn),
		)
		fromV = sqlgraph.Neighbors(e.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventsClient) Hooks() []Hook {
	return c.hooks.Events
}

// EventsWaitClient is a client for the EventsWait schema.
type EventsWaitClient struct {
	config
}

// NewEventsWaitClient returns a client for the EventsWait from the given config.
func NewEventsWaitClient(c config) *EventsWaitClient {
	return &EventsWaitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `eventswait.Hooks(f(g(h())))`.
func (c *EventsWaitClient) Use(hooks ...Hook) {
	c.hooks.EventsWait = append(c.hooks.EventsWait, hooks...)
}

// Create returns a create builder for EventsWait.
func (c *EventsWaitClient) Create() *EventsWaitCreate {
	mutation := newEventsWaitMutation(c.config, OpCreate)
	return &EventsWaitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of EventsWait entities.
func (c *EventsWaitClient) CreateBulk(builders ...*EventsWaitCreate) *EventsWaitCreateBulk {
	return &EventsWaitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for EventsWait.
func (c *EventsWaitClient) Update() *EventsWaitUpdate {
	mutation := newEventsWaitMutation(c.config, OpUpdate)
	return &EventsWaitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *EventsWaitClient) UpdateOne(ew *EventsWait) *EventsWaitUpdateOne {
	mutation := newEventsWaitMutation(c.config, OpUpdateOne, withEventsWait(ew))
	return &EventsWaitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *EventsWaitClient) UpdateOneID(id uuid.UUID) *EventsWaitUpdateOne {
	mutation := newEventsWaitMutation(c.config, OpUpdateOne, withEventsWaitID(id))
	return &EventsWaitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for EventsWait.
func (c *EventsWaitClient) Delete() *EventsWaitDelete {
	mutation := newEventsWaitMutation(c.config, OpDelete)
	return &EventsWaitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *EventsWaitClient) DeleteOne(ew *EventsWait) *EventsWaitDeleteOne {
	return c.DeleteOneID(ew.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *EventsWaitClient) DeleteOneID(id uuid.UUID) *EventsWaitDeleteOne {
	builder := c.Delete().Where(eventswait.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &EventsWaitDeleteOne{builder}
}

// Query returns a query builder for EventsWait.
func (c *EventsWaitClient) Query() *EventsWaitQuery {
	return &EventsWaitQuery{
		config: c.config,
	}
}

// Get returns a EventsWait entity by its id.
func (c *EventsWaitClient) Get(ctx context.Context, id uuid.UUID) (*EventsWait, error) {
	return c.Query().Where(eventswait.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *EventsWaitClient) GetX(ctx context.Context, id uuid.UUID) *EventsWait {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflowevent queries the workflowevent edge of a EventsWait.
func (c *EventsWaitClient) QueryWorkflowevent(ew *EventsWait) *EventsQuery {
	query := &EventsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ew.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(eventswait.Table, eventswait.FieldID, id),
			sqlgraph.To(events.Table, events.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, eventswait.WorkfloweventTable, eventswait.WorkfloweventColumn),
		)
		fromV = sqlgraph.Neighbors(ew.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *EventsWaitClient) Hooks() []Hook {
	return c.hooks.EventsWait
}

// InodeClient is a client for the Inode schema.
type InodeClient struct {
	config
}

// NewInodeClient returns a client for the Inode from the given config.
func NewInodeClient(c config) *InodeClient {
	return &InodeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `inode.Hooks(f(g(h())))`.
func (c *InodeClient) Use(hooks ...Hook) {
	c.hooks.Inode = append(c.hooks.Inode, hooks...)
}

// Create returns a create builder for Inode.
func (c *InodeClient) Create() *InodeCreate {
	mutation := newInodeMutation(c.config, OpCreate)
	return &InodeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Inode entities.
func (c *InodeClient) CreateBulk(builders ...*InodeCreate) *InodeCreateBulk {
	return &InodeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Inode.
func (c *InodeClient) Update() *InodeUpdate {
	mutation := newInodeMutation(c.config, OpUpdate)
	return &InodeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InodeClient) UpdateOne(i *Inode) *InodeUpdateOne {
	mutation := newInodeMutation(c.config, OpUpdateOne, withInode(i))
	return &InodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InodeClient) UpdateOneID(id uuid.UUID) *InodeUpdateOne {
	mutation := newInodeMutation(c.config, OpUpdateOne, withInodeID(id))
	return &InodeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Inode.
func (c *InodeClient) Delete() *InodeDelete {
	mutation := newInodeMutation(c.config, OpDelete)
	return &InodeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InodeClient) DeleteOne(i *Inode) *InodeDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InodeClient) DeleteOneID(id uuid.UUID) *InodeDeleteOne {
	builder := c.Delete().Where(inode.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InodeDeleteOne{builder}
}

// Query returns a query builder for Inode.
func (c *InodeClient) Query() *InodeQuery {
	return &InodeQuery{
		config: c.config,
	}
}

// Get returns a Inode entity by its id.
func (c *InodeClient) Get(ctx context.Context, id uuid.UUID) (*Inode, error) {
	return c.Query().Where(inode.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InodeClient) GetX(ctx context.Context, id uuid.UUID) *Inode {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a Inode.
func (c *InodeClient) QueryNamespace(i *Inode) *NamespaceQuery {
	query := &NamespaceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inode.Table, inode.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inode.NamespaceTable, inode.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Inode.
func (c *InodeClient) QueryChildren(i *Inode) *InodeQuery {
	query := &InodeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inode.Table, inode.FieldID, id),
			sqlgraph.To(inode.Table, inode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, inode.ChildrenTable, inode.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Inode.
func (c *InodeClient) QueryParent(i *Inode) *InodeQuery {
	query := &InodeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inode.Table, inode.FieldID, id),
			sqlgraph.To(inode.Table, inode.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, inode.ParentTable, inode.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflow queries the workflow edge of a Inode.
func (c *InodeClient) QueryWorkflow(i *Inode) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(inode.Table, inode.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, inode.WorkflowTable, inode.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InodeClient) Hooks() []Hook {
	return c.hooks.Inode
}

// InstanceClient is a client for the Instance schema.
type InstanceClient struct {
	config
}

// NewInstanceClient returns a client for the Instance from the given config.
func NewInstanceClient(c config) *InstanceClient {
	return &InstanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `instance.Hooks(f(g(h())))`.
func (c *InstanceClient) Use(hooks ...Hook) {
	c.hooks.Instance = append(c.hooks.Instance, hooks...)
}

// Create returns a create builder for Instance.
func (c *InstanceClient) Create() *InstanceCreate {
	mutation := newInstanceMutation(c.config, OpCreate)
	return &InstanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Instance entities.
func (c *InstanceClient) CreateBulk(builders ...*InstanceCreate) *InstanceCreateBulk {
	return &InstanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Instance.
func (c *InstanceClient) Update() *InstanceUpdate {
	mutation := newInstanceMutation(c.config, OpUpdate)
	return &InstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InstanceClient) UpdateOne(i *Instance) *InstanceUpdateOne {
	mutation := newInstanceMutation(c.config, OpUpdateOne, withInstance(i))
	return &InstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InstanceClient) UpdateOneID(id uuid.UUID) *InstanceUpdateOne {
	mutation := newInstanceMutation(c.config, OpUpdateOne, withInstanceID(id))
	return &InstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Instance.
func (c *InstanceClient) Delete() *InstanceDelete {
	mutation := newInstanceMutation(c.config, OpDelete)
	return &InstanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InstanceClient) DeleteOne(i *Instance) *InstanceDeleteOne {
	return c.DeleteOneID(i.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InstanceClient) DeleteOneID(id uuid.UUID) *InstanceDeleteOne {
	builder := c.Delete().Where(instance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InstanceDeleteOne{builder}
}

// Query returns a query builder for Instance.
func (c *InstanceClient) Query() *InstanceQuery {
	return &InstanceQuery{
		config: c.config,
	}
}

// Get returns a Instance entity by its id.
func (c *InstanceClient) Get(ctx context.Context, id uuid.UUID) (*Instance, error) {
	return c.Query().Where(instance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InstanceClient) GetX(ctx context.Context, id uuid.UUID) *Instance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a Instance.
func (c *InstanceClient) QueryNamespace(i *Instance) *NamespaceQuery {
	query := &NamespaceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, instance.NamespaceTable, instance.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflow queries the workflow edge of a Instance.
func (c *InstanceClient) QueryWorkflow(i *Instance) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, instance.WorkflowTable, instance.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRevision queries the revision edge of a Instance.
func (c *InstanceClient) QueryRevision(i *Instance) *RevisionQuery {
	query := &RevisionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(revision.Table, revision.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, instance.RevisionTable, instance.RevisionColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogs queries the logs edge of a Instance.
func (c *InstanceClient) QueryLogs(i *Instance) *LogMsgQuery {
	query := &LogMsgQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(logmsg.Table, logmsg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instance.LogsTable, instance.LogsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVars queries the vars edge of a Instance.
func (c *InstanceClient) QueryVars(i *Instance) *VarRefQuery {
	query := &VarRefQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(varref.Table, varref.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instance.VarsTable, instance.VarsColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRuntime queries the runtime edge of a Instance.
func (c *InstanceClient) QueryRuntime(i *Instance) *InstanceRuntimeQuery {
	query := &InstanceRuntimeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(instanceruntime.Table, instanceruntime.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, instance.RuntimeTable, instance.RuntimeColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Instance.
func (c *InstanceClient) QueryChildren(i *Instance) *InstanceRuntimeQuery {
	query := &InstanceRuntimeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(instanceruntime.Table, instanceruntime.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instance.ChildrenTable, instance.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryEventlisteners queries the eventlisteners edge of a Instance.
func (c *InstanceClient) QueryEventlisteners(i *Instance) *EventsQuery {
	query := &EventsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := i.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instance.Table, instance.FieldID, id),
			sqlgraph.To(events.Table, events.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, instance.EventlistenersTable, instance.EventlistenersColumn),
		)
		fromV = sqlgraph.Neighbors(i.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InstanceClient) Hooks() []Hook {
	return c.hooks.Instance
}

// InstanceRuntimeClient is a client for the InstanceRuntime schema.
type InstanceRuntimeClient struct {
	config
}

// NewInstanceRuntimeClient returns a client for the InstanceRuntime from the given config.
func NewInstanceRuntimeClient(c config) *InstanceRuntimeClient {
	return &InstanceRuntimeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `instanceruntime.Hooks(f(g(h())))`.
func (c *InstanceRuntimeClient) Use(hooks ...Hook) {
	c.hooks.InstanceRuntime = append(c.hooks.InstanceRuntime, hooks...)
}

// Create returns a create builder for InstanceRuntime.
func (c *InstanceRuntimeClient) Create() *InstanceRuntimeCreate {
	mutation := newInstanceRuntimeMutation(c.config, OpCreate)
	return &InstanceRuntimeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of InstanceRuntime entities.
func (c *InstanceRuntimeClient) CreateBulk(builders ...*InstanceRuntimeCreate) *InstanceRuntimeCreateBulk {
	return &InstanceRuntimeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for InstanceRuntime.
func (c *InstanceRuntimeClient) Update() *InstanceRuntimeUpdate {
	mutation := newInstanceRuntimeMutation(c.config, OpUpdate)
	return &InstanceRuntimeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *InstanceRuntimeClient) UpdateOne(ir *InstanceRuntime) *InstanceRuntimeUpdateOne {
	mutation := newInstanceRuntimeMutation(c.config, OpUpdateOne, withInstanceRuntime(ir))
	return &InstanceRuntimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *InstanceRuntimeClient) UpdateOneID(id uuid.UUID) *InstanceRuntimeUpdateOne {
	mutation := newInstanceRuntimeMutation(c.config, OpUpdateOne, withInstanceRuntimeID(id))
	return &InstanceRuntimeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for InstanceRuntime.
func (c *InstanceRuntimeClient) Delete() *InstanceRuntimeDelete {
	mutation := newInstanceRuntimeMutation(c.config, OpDelete)
	return &InstanceRuntimeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *InstanceRuntimeClient) DeleteOne(ir *InstanceRuntime) *InstanceRuntimeDeleteOne {
	return c.DeleteOneID(ir.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *InstanceRuntimeClient) DeleteOneID(id uuid.UUID) *InstanceRuntimeDeleteOne {
	builder := c.Delete().Where(instanceruntime.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &InstanceRuntimeDeleteOne{builder}
}

// Query returns a query builder for InstanceRuntime.
func (c *InstanceRuntimeClient) Query() *InstanceRuntimeQuery {
	return &InstanceRuntimeQuery{
		config: c.config,
	}
}

// Get returns a InstanceRuntime entity by its id.
func (c *InstanceRuntimeClient) Get(ctx context.Context, id uuid.UUID) (*InstanceRuntime, error) {
	return c.Query().Where(instanceruntime.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *InstanceRuntimeClient) GetX(ctx context.Context, id uuid.UUID) *InstanceRuntime {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInstance queries the instance edge of a InstanceRuntime.
func (c *InstanceRuntimeClient) QueryInstance(ir *InstanceRuntime) *InstanceQuery {
	query := &InstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ir.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instanceruntime.Table, instanceruntime.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, instanceruntime.InstanceTable, instanceruntime.InstanceColumn),
		)
		fromV = sqlgraph.Neighbors(ir.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCaller queries the caller edge of a InstanceRuntime.
func (c *InstanceRuntimeClient) QueryCaller(ir *InstanceRuntime) *InstanceQuery {
	query := &InstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := ir.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(instanceruntime.Table, instanceruntime.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, instanceruntime.CallerTable, instanceruntime.CallerColumn),
		)
		fromV = sqlgraph.Neighbors(ir.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *InstanceRuntimeClient) Hooks() []Hook {
	return c.hooks.InstanceRuntime
}

// LogMsgClient is a client for the LogMsg schema.
type LogMsgClient struct {
	config
}

// NewLogMsgClient returns a client for the LogMsg from the given config.
func NewLogMsgClient(c config) *LogMsgClient {
	return &LogMsgClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logmsg.Hooks(f(g(h())))`.
func (c *LogMsgClient) Use(hooks ...Hook) {
	c.hooks.LogMsg = append(c.hooks.LogMsg, hooks...)
}

// Create returns a create builder for LogMsg.
func (c *LogMsgClient) Create() *LogMsgCreate {
	mutation := newLogMsgMutation(c.config, OpCreate)
	return &LogMsgCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LogMsg entities.
func (c *LogMsgClient) CreateBulk(builders ...*LogMsgCreate) *LogMsgCreateBulk {
	return &LogMsgCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LogMsg.
func (c *LogMsgClient) Update() *LogMsgUpdate {
	mutation := newLogMsgMutation(c.config, OpUpdate)
	return &LogMsgUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LogMsgClient) UpdateOne(lm *LogMsg) *LogMsgUpdateOne {
	mutation := newLogMsgMutation(c.config, OpUpdateOne, withLogMsg(lm))
	return &LogMsgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LogMsgClient) UpdateOneID(id uuid.UUID) *LogMsgUpdateOne {
	mutation := newLogMsgMutation(c.config, OpUpdateOne, withLogMsgID(id))
	return &LogMsgUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LogMsg.
func (c *LogMsgClient) Delete() *LogMsgDelete {
	mutation := newLogMsgMutation(c.config, OpDelete)
	return &LogMsgDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *LogMsgClient) DeleteOne(lm *LogMsg) *LogMsgDeleteOne {
	return c.DeleteOneID(lm.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *LogMsgClient) DeleteOneID(id uuid.UUID) *LogMsgDeleteOne {
	builder := c.Delete().Where(logmsg.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LogMsgDeleteOne{builder}
}

// Query returns a query builder for LogMsg.
func (c *LogMsgClient) Query() *LogMsgQuery {
	return &LogMsgQuery{
		config: c.config,
	}
}

// Get returns a LogMsg entity by its id.
func (c *LogMsgClient) Get(ctx context.Context, id uuid.UUID) (*LogMsg, error) {
	return c.Query().Where(logmsg.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LogMsgClient) GetX(ctx context.Context, id uuid.UUID) *LogMsg {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a LogMsg.
func (c *LogMsgClient) QueryNamespace(lm *LogMsg) *NamespaceQuery {
	query := &NamespaceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := lm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(logmsg.Table, logmsg.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, logmsg.NamespaceTable, logmsg.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(lm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflow queries the workflow edge of a LogMsg.
func (c *LogMsgClient) QueryWorkflow(lm *LogMsg) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := lm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(logmsg.Table, logmsg.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, logmsg.WorkflowTable, logmsg.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(lm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstance queries the instance edge of a LogMsg.
func (c *LogMsgClient) QueryInstance(lm *LogMsg) *InstanceQuery {
	query := &InstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := lm.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(logmsg.Table, logmsg.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, logmsg.InstanceTable, logmsg.InstanceColumn),
		)
		fromV = sqlgraph.Neighbors(lm.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LogMsgClient) Hooks() []Hook {
	return c.hooks.LogMsg
}

// NamespaceClient is a client for the Namespace schema.
type NamespaceClient struct {
	config
}

// NewNamespaceClient returns a client for the Namespace from the given config.
func NewNamespaceClient(c config) *NamespaceClient {
	return &NamespaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `namespace.Hooks(f(g(h())))`.
func (c *NamespaceClient) Use(hooks ...Hook) {
	c.hooks.Namespace = append(c.hooks.Namespace, hooks...)
}

// Create returns a create builder for Namespace.
func (c *NamespaceClient) Create() *NamespaceCreate {
	mutation := newNamespaceMutation(c.config, OpCreate)
	return &NamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Namespace entities.
func (c *NamespaceClient) CreateBulk(builders ...*NamespaceCreate) *NamespaceCreateBulk {
	return &NamespaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Namespace.
func (c *NamespaceClient) Update() *NamespaceUpdate {
	mutation := newNamespaceMutation(c.config, OpUpdate)
	return &NamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NamespaceClient) UpdateOne(n *Namespace) *NamespaceUpdateOne {
	mutation := newNamespaceMutation(c.config, OpUpdateOne, withNamespace(n))
	return &NamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NamespaceClient) UpdateOneID(id uuid.UUID) *NamespaceUpdateOne {
	mutation := newNamespaceMutation(c.config, OpUpdateOne, withNamespaceID(id))
	return &NamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Namespace.
func (c *NamespaceClient) Delete() *NamespaceDelete {
	mutation := newNamespaceMutation(c.config, OpDelete)
	return &NamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *NamespaceClient) DeleteOne(n *Namespace) *NamespaceDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *NamespaceClient) DeleteOneID(id uuid.UUID) *NamespaceDeleteOne {
	builder := c.Delete().Where(namespace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NamespaceDeleteOne{builder}
}

// Query returns a query builder for Namespace.
func (c *NamespaceClient) Query() *NamespaceQuery {
	return &NamespaceQuery{
		config: c.config,
	}
}

// Get returns a Namespace entity by its id.
func (c *NamespaceClient) Get(ctx context.Context, id uuid.UUID) (*Namespace, error) {
	return c.Query().Where(namespace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NamespaceClient) GetX(ctx context.Context, id uuid.UUID) *Namespace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInodes queries the inodes edge of a Namespace.
func (c *NamespaceClient) QueryInodes(n *Namespace) *InodeQuery {
	query := &InodeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(inode.Table, inode.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.InodesTable, namespace.InodesColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflows queries the workflows edge of a Namespace.
func (c *NamespaceClient) QueryWorkflows(n *Namespace) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.WorkflowsTable, namespace.WorkflowsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a Namespace.
func (c *NamespaceClient) QueryInstances(n *Namespace) *InstanceQuery {
	query := &InstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.InstancesTable, namespace.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogs queries the logs edge of a Namespace.
func (c *NamespaceClient) QueryLogs(n *Namespace) *LogMsgQuery {
	query := &LogMsgQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(logmsg.Table, logmsg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.LogsTable, namespace.LogsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVars queries the vars edge of a Namespace.
func (c *NamespaceClient) QueryVars(n *Namespace) *VarRefQuery {
	query := &VarRefQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(varref.Table, varref.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.VarsTable, namespace.VarsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryCloudevents queries the cloudevents edge of a Namespace.
func (c *NamespaceClient) QueryCloudevents(n *Namespace) *CloudEventsQuery {
	query := &CloudEventsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(cloudevents.Table, cloudevents.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.CloudeventsTable, namespace.CloudeventsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NamespaceClient) Hooks() []Hook {
	return c.hooks.Namespace
}

// RefClient is a client for the Ref schema.
type RefClient struct {
	config
}

// NewRefClient returns a client for the Ref from the given config.
func NewRefClient(c config) *RefClient {
	return &RefClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `ref.Hooks(f(g(h())))`.
func (c *RefClient) Use(hooks ...Hook) {
	c.hooks.Ref = append(c.hooks.Ref, hooks...)
}

// Create returns a create builder for Ref.
func (c *RefClient) Create() *RefCreate {
	mutation := newRefMutation(c.config, OpCreate)
	return &RefCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Ref entities.
func (c *RefClient) CreateBulk(builders ...*RefCreate) *RefCreateBulk {
	return &RefCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Ref.
func (c *RefClient) Update() *RefUpdate {
	mutation := newRefMutation(c.config, OpUpdate)
	return &RefUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RefClient) UpdateOne(r *Ref) *RefUpdateOne {
	mutation := newRefMutation(c.config, OpUpdateOne, withRef(r))
	return &RefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RefClient) UpdateOneID(id uuid.UUID) *RefUpdateOne {
	mutation := newRefMutation(c.config, OpUpdateOne, withRefID(id))
	return &RefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Ref.
func (c *RefClient) Delete() *RefDelete {
	mutation := newRefMutation(c.config, OpDelete)
	return &RefDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RefClient) DeleteOne(r *Ref) *RefDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RefClient) DeleteOneID(id uuid.UUID) *RefDeleteOne {
	builder := c.Delete().Where(ref.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RefDeleteOne{builder}
}

// Query returns a query builder for Ref.
func (c *RefClient) Query() *RefQuery {
	return &RefQuery{
		config: c.config,
	}
}

// Get returns a Ref entity by its id.
func (c *RefClient) Get(ctx context.Context, id uuid.UUID) (*Ref, error) {
	return c.Query().Where(ref.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RefClient) GetX(ctx context.Context, id uuid.UUID) *Ref {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a Ref.
func (c *RefClient) QueryWorkflow(r *Ref) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ref.Table, ref.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ref.WorkflowTable, ref.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRevision queries the revision edge of a Ref.
func (c *RefClient) QueryRevision(r *Ref) *RevisionQuery {
	query := &RevisionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ref.Table, ref.FieldID, id),
			sqlgraph.To(revision.Table, revision.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, ref.RevisionTable, ref.RevisionColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoutes queries the routes edge of a Ref.
func (c *RefClient) QueryRoutes(r *Ref) *RouteQuery {
	query := &RouteQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(ref.Table, ref.FieldID, id),
			sqlgraph.To(route.Table, route.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, ref.RoutesTable, ref.RoutesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RefClient) Hooks() []Hook {
	return c.hooks.Ref
}

// RevisionClient is a client for the Revision schema.
type RevisionClient struct {
	config
}

// NewRevisionClient returns a client for the Revision from the given config.
func NewRevisionClient(c config) *RevisionClient {
	return &RevisionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `revision.Hooks(f(g(h())))`.
func (c *RevisionClient) Use(hooks ...Hook) {
	c.hooks.Revision = append(c.hooks.Revision, hooks...)
}

// Create returns a create builder for Revision.
func (c *RevisionClient) Create() *RevisionCreate {
	mutation := newRevisionMutation(c.config, OpCreate)
	return &RevisionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Revision entities.
func (c *RevisionClient) CreateBulk(builders ...*RevisionCreate) *RevisionCreateBulk {
	return &RevisionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Revision.
func (c *RevisionClient) Update() *RevisionUpdate {
	mutation := newRevisionMutation(c.config, OpUpdate)
	return &RevisionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RevisionClient) UpdateOne(r *Revision) *RevisionUpdateOne {
	mutation := newRevisionMutation(c.config, OpUpdateOne, withRevision(r))
	return &RevisionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RevisionClient) UpdateOneID(id uuid.UUID) *RevisionUpdateOne {
	mutation := newRevisionMutation(c.config, OpUpdateOne, withRevisionID(id))
	return &RevisionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Revision.
func (c *RevisionClient) Delete() *RevisionDelete {
	mutation := newRevisionMutation(c.config, OpDelete)
	return &RevisionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RevisionClient) DeleteOne(r *Revision) *RevisionDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RevisionClient) DeleteOneID(id uuid.UUID) *RevisionDeleteOne {
	builder := c.Delete().Where(revision.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RevisionDeleteOne{builder}
}

// Query returns a query builder for Revision.
func (c *RevisionClient) Query() *RevisionQuery {
	return &RevisionQuery{
		config: c.config,
	}
}

// Get returns a Revision entity by its id.
func (c *RevisionClient) Get(ctx context.Context, id uuid.UUID) (*Revision, error) {
	return c.Query().Where(revision.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RevisionClient) GetX(ctx context.Context, id uuid.UUID) *Revision {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a Revision.
func (c *RevisionClient) QueryWorkflow(r *Revision) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(revision.Table, revision.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, revision.WorkflowTable, revision.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRefs queries the refs edge of a Revision.
func (c *RevisionClient) QueryRefs(r *Revision) *RefQuery {
	query := &RefQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(revision.Table, revision.FieldID, id),
			sqlgraph.To(ref.Table, ref.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, revision.RefsTable, revision.RefsColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a Revision.
func (c *RevisionClient) QueryInstances(r *Revision) *InstanceQuery {
	query := &InstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(revision.Table, revision.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, revision.InstancesTable, revision.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RevisionClient) Hooks() []Hook {
	return c.hooks.Revision
}

// RouteClient is a client for the Route schema.
type RouteClient struct {
	config
}

// NewRouteClient returns a client for the Route from the given config.
func NewRouteClient(c config) *RouteClient {
	return &RouteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `route.Hooks(f(g(h())))`.
func (c *RouteClient) Use(hooks ...Hook) {
	c.hooks.Route = append(c.hooks.Route, hooks...)
}

// Create returns a create builder for Route.
func (c *RouteClient) Create() *RouteCreate {
	mutation := newRouteMutation(c.config, OpCreate)
	return &RouteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Route entities.
func (c *RouteClient) CreateBulk(builders ...*RouteCreate) *RouteCreateBulk {
	return &RouteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Route.
func (c *RouteClient) Update() *RouteUpdate {
	mutation := newRouteMutation(c.config, OpUpdate)
	return &RouteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RouteClient) UpdateOne(r *Route) *RouteUpdateOne {
	mutation := newRouteMutation(c.config, OpUpdateOne, withRoute(r))
	return &RouteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RouteClient) UpdateOneID(id uuid.UUID) *RouteUpdateOne {
	mutation := newRouteMutation(c.config, OpUpdateOne, withRouteID(id))
	return &RouteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Route.
func (c *RouteClient) Delete() *RouteDelete {
	mutation := newRouteMutation(c.config, OpDelete)
	return &RouteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *RouteClient) DeleteOne(r *Route) *RouteDeleteOne {
	return c.DeleteOneID(r.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *RouteClient) DeleteOneID(id uuid.UUID) *RouteDeleteOne {
	builder := c.Delete().Where(route.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RouteDeleteOne{builder}
}

// Query returns a query builder for Route.
func (c *RouteClient) Query() *RouteQuery {
	return &RouteQuery{
		config: c.config,
	}
}

// Get returns a Route entity by its id.
func (c *RouteClient) Get(ctx context.Context, id uuid.UUID) (*Route, error) {
	return c.Query().Where(route.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RouteClient) GetX(ctx context.Context, id uuid.UUID) *Route {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a Route.
func (c *RouteClient) QueryWorkflow(r *Route) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(route.Table, route.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, route.WorkflowTable, route.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRef queries the ref edge of a Route.
func (c *RouteClient) QueryRef(r *Route) *RefQuery {
	query := &RefQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := r.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(route.Table, route.FieldID, id),
			sqlgraph.To(ref.Table, ref.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, route.RefTable, route.RefColumn),
		)
		fromV = sqlgraph.Neighbors(r.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *RouteClient) Hooks() []Hook {
	return c.hooks.Route
}

// VarDataClient is a client for the VarData schema.
type VarDataClient struct {
	config
}

// NewVarDataClient returns a client for the VarData from the given config.
func NewVarDataClient(c config) *VarDataClient {
	return &VarDataClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `vardata.Hooks(f(g(h())))`.
func (c *VarDataClient) Use(hooks ...Hook) {
	c.hooks.VarData = append(c.hooks.VarData, hooks...)
}

// Create returns a create builder for VarData.
func (c *VarDataClient) Create() *VarDataCreate {
	mutation := newVarDataMutation(c.config, OpCreate)
	return &VarDataCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VarData entities.
func (c *VarDataClient) CreateBulk(builders ...*VarDataCreate) *VarDataCreateBulk {
	return &VarDataCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VarData.
func (c *VarDataClient) Update() *VarDataUpdate {
	mutation := newVarDataMutation(c.config, OpUpdate)
	return &VarDataUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VarDataClient) UpdateOne(vd *VarData) *VarDataUpdateOne {
	mutation := newVarDataMutation(c.config, OpUpdateOne, withVarData(vd))
	return &VarDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VarDataClient) UpdateOneID(id uuid.UUID) *VarDataUpdateOne {
	mutation := newVarDataMutation(c.config, OpUpdateOne, withVarDataID(id))
	return &VarDataUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VarData.
func (c *VarDataClient) Delete() *VarDataDelete {
	mutation := newVarDataMutation(c.config, OpDelete)
	return &VarDataDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *VarDataClient) DeleteOne(vd *VarData) *VarDataDeleteOne {
	return c.DeleteOneID(vd.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *VarDataClient) DeleteOneID(id uuid.UUID) *VarDataDeleteOne {
	builder := c.Delete().Where(vardata.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VarDataDeleteOne{builder}
}

// Query returns a query builder for VarData.
func (c *VarDataClient) Query() *VarDataQuery {
	return &VarDataQuery{
		config: c.config,
	}
}

// Get returns a VarData entity by its id.
func (c *VarDataClient) Get(ctx context.Context, id uuid.UUID) (*VarData, error) {
	return c.Query().Where(vardata.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VarDataClient) GetX(ctx context.Context, id uuid.UUID) *VarData {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVarrefs queries the varrefs edge of a VarData.
func (c *VarDataClient) QueryVarrefs(vd *VarData) *VarRefQuery {
	query := &VarRefQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vd.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(vardata.Table, vardata.FieldID, id),
			sqlgraph.To(varref.Table, varref.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, vardata.VarrefsTable, vardata.VarrefsColumn),
		)
		fromV = sqlgraph.Neighbors(vd.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VarDataClient) Hooks() []Hook {
	return c.hooks.VarData
}

// VarRefClient is a client for the VarRef schema.
type VarRefClient struct {
	config
}

// NewVarRefClient returns a client for the VarRef from the given config.
func NewVarRefClient(c config) *VarRefClient {
	return &VarRefClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `varref.Hooks(f(g(h())))`.
func (c *VarRefClient) Use(hooks ...Hook) {
	c.hooks.VarRef = append(c.hooks.VarRef, hooks...)
}

// Create returns a create builder for VarRef.
func (c *VarRefClient) Create() *VarRefCreate {
	mutation := newVarRefMutation(c.config, OpCreate)
	return &VarRefCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VarRef entities.
func (c *VarRefClient) CreateBulk(builders ...*VarRefCreate) *VarRefCreateBulk {
	return &VarRefCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VarRef.
func (c *VarRefClient) Update() *VarRefUpdate {
	mutation := newVarRefMutation(c.config, OpUpdate)
	return &VarRefUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VarRefClient) UpdateOne(vr *VarRef) *VarRefUpdateOne {
	mutation := newVarRefMutation(c.config, OpUpdateOne, withVarRef(vr))
	return &VarRefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VarRefClient) UpdateOneID(id uuid.UUID) *VarRefUpdateOne {
	mutation := newVarRefMutation(c.config, OpUpdateOne, withVarRefID(id))
	return &VarRefUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VarRef.
func (c *VarRefClient) Delete() *VarRefDelete {
	mutation := newVarRefMutation(c.config, OpDelete)
	return &VarRefDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *VarRefClient) DeleteOne(vr *VarRef) *VarRefDeleteOne {
	return c.DeleteOneID(vr.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *VarRefClient) DeleteOneID(id uuid.UUID) *VarRefDeleteOne {
	builder := c.Delete().Where(varref.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VarRefDeleteOne{builder}
}

// Query returns a query builder for VarRef.
func (c *VarRefClient) Query() *VarRefQuery {
	return &VarRefQuery{
		config: c.config,
	}
}

// Get returns a VarRef entity by its id.
func (c *VarRefClient) Get(ctx context.Context, id uuid.UUID) (*VarRef, error) {
	return c.Query().Where(varref.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VarRefClient) GetX(ctx context.Context, id uuid.UUID) *VarRef {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryVardata queries the vardata edge of a VarRef.
func (c *VarRefClient) QueryVardata(vr *VarRef) *VarDataQuery {
	query := &VarDataQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(varref.Table, varref.FieldID, id),
			sqlgraph.To(vardata.Table, vardata.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, varref.VardataTable, varref.VardataColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNamespace queries the namespace edge of a VarRef.
func (c *VarRefClient) QueryNamespace(vr *VarRef) *NamespaceQuery {
	query := &NamespaceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(varref.Table, varref.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, varref.NamespaceTable, varref.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkflow queries the workflow edge of a VarRef.
func (c *VarRefClient) QueryWorkflow(vr *VarRef) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(varref.Table, varref.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, varref.WorkflowTable, varref.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstance queries the instance edge of a VarRef.
func (c *VarRefClient) QueryInstance(vr *VarRef) *InstanceQuery {
	query := &InstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := vr.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(varref.Table, varref.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, varref.InstanceTable, varref.InstanceColumn),
		)
		fromV = sqlgraph.Neighbors(vr.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VarRefClient) Hooks() []Hook {
	return c.hooks.VarRef
}

// WorkflowClient is a client for the Workflow schema.
type WorkflowClient struct {
	config
}

// NewWorkflowClient returns a client for the Workflow from the given config.
func NewWorkflowClient(c config) *WorkflowClient {
	return &WorkflowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflow.Hooks(f(g(h())))`.
func (c *WorkflowClient) Use(hooks ...Hook) {
	c.hooks.Workflow = append(c.hooks.Workflow, hooks...)
}

// Create returns a create builder for Workflow.
func (c *WorkflowClient) Create() *WorkflowCreate {
	mutation := newWorkflowMutation(c.config, OpCreate)
	return &WorkflowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Workflow entities.
func (c *WorkflowClient) CreateBulk(builders ...*WorkflowCreate) *WorkflowCreateBulk {
	return &WorkflowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Workflow.
func (c *WorkflowClient) Update() *WorkflowUpdate {
	mutation := newWorkflowMutation(c.config, OpUpdate)
	return &WorkflowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowClient) UpdateOne(w *Workflow) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflow(w))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowClient) UpdateOneID(id uuid.UUID) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflowID(id))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Workflow.
func (c *WorkflowClient) Delete() *WorkflowDelete {
	mutation := newWorkflowMutation(c.config, OpDelete)
	return &WorkflowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *WorkflowClient) DeleteOne(w *Workflow) *WorkflowDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *WorkflowClient) DeleteOneID(id uuid.UUID) *WorkflowDeleteOne {
	builder := c.Delete().Where(workflow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowDeleteOne{builder}
}

// Query returns a query builder for Workflow.
func (c *WorkflowClient) Query() *WorkflowQuery {
	return &WorkflowQuery{
		config: c.config,
	}
}

// Get returns a Workflow entity by its id.
func (c *WorkflowClient) Get(ctx context.Context, id uuid.UUID) (*Workflow, error) {
	return c.Query().Where(workflow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowClient) GetX(ctx context.Context, id uuid.UUID) *Workflow {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryInode queries the inode edge of a Workflow.
func (c *WorkflowClient) QueryInode(w *Workflow) *InodeQuery {
	query := &InodeQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(inode.Table, inode.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, workflow.InodeTable, workflow.InodeColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryNamespace queries the namespace edge of a Workflow.
func (c *WorkflowClient) QueryNamespace(w *Workflow) *NamespaceQuery {
	query := &NamespaceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflow.NamespaceTable, workflow.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRevisions queries the revisions edge of a Workflow.
func (c *WorkflowClient) QueryRevisions(w *Workflow) *RevisionQuery {
	query := &RevisionQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(revision.Table, revision.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.RevisionsTable, workflow.RevisionsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRefs queries the refs edge of a Workflow.
func (c *WorkflowClient) QueryRefs(w *Workflow) *RefQuery {
	query := &RefQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(ref.Table, ref.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.RefsTable, workflow.RefsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a Workflow.
func (c *WorkflowClient) QueryInstances(w *Workflow) *InstanceQuery {
	query := &InstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(instance.Table, instance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.InstancesTable, workflow.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryRoutes queries the routes edge of a Workflow.
func (c *WorkflowClient) QueryRoutes(w *Workflow) *RouteQuery {
	query := &RouteQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(route.Table, route.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.RoutesTable, workflow.RoutesColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryLogs queries the logs edge of a Workflow.
func (c *WorkflowClient) QueryLogs(w *Workflow) *LogMsgQuery {
	query := &LogMsgQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(logmsg.Table, logmsg.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.LogsTable, workflow.LogsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVars queries the vars edge of a Workflow.
func (c *WorkflowClient) QueryVars(w *Workflow) *VarRefQuery {
	query := &VarRefQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(varref.Table, varref.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.VarsTable, workflow.VarsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWfevents queries the wfevents edge of a Workflow.
func (c *WorkflowClient) QueryWfevents(w *Workflow) *EventsQuery {
	query := &EventsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(events.Table, events.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.WfeventsTable, workflow.WfeventsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowClient) Hooks() []Hook {
	return c.hooks.Workflow
}
