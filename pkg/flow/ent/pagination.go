// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/direktiv/direktiv/pkg/flow/ent/cloudevents"
	"github.com/direktiv/direktiv/pkg/flow/ent/events"
	"github.com/direktiv/direktiv/pkg/flow/ent/eventswait"
	"github.com/direktiv/direktiv/pkg/flow/ent/inode"
	"github.com/direktiv/direktiv/pkg/flow/ent/instance"
	"github.com/direktiv/direktiv/pkg/flow/ent/instanceruntime"
	"github.com/direktiv/direktiv/pkg/flow/ent/logmsg"
	"github.com/direktiv/direktiv/pkg/flow/ent/namespace"
	"github.com/direktiv/direktiv/pkg/flow/ent/ref"
	"github.com/direktiv/direktiv/pkg/flow/ent/revision"
	"github.com/direktiv/direktiv/pkg/flow/ent/route"
	"github.com/direktiv/direktiv/pkg/flow/ent/vardata"
	"github.com/direktiv/direktiv/pkg/flow/ent/varref"
	"github.com/direktiv/direktiv/pkg/flow/ent/workflow"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    uuid.UUID `msgpack:"i"`
	Value Value     `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func getCollectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	field := fc.Field

walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Name == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return getCollectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

// CloudEventsEdge is the edge representation of CloudEvents.
type CloudEventsEdge struct {
	Node   *CloudEvents `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// CloudEventsConnection is the connection containing edges to CloudEvents.
type CloudEventsConnection struct {
	Edges      []*CloudEventsEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

// CloudEventsPaginateOption enables pagination customization.
type CloudEventsPaginateOption func(*cloudEventsPager) error

// WithCloudEventsOrder configures pagination ordering.
func WithCloudEventsOrder(order *CloudEventsOrder) CloudEventsPaginateOption {
	if order == nil {
		order = DefaultCloudEventsOrder
	}
	o := *order
	return func(pager *cloudEventsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCloudEventsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCloudEventsFilter configures pagination filter.
func WithCloudEventsFilter(filter func(*CloudEventsQuery) (*CloudEventsQuery, error)) CloudEventsPaginateOption {
	return func(pager *cloudEventsPager) error {
		if filter == nil {
			return errors.New("CloudEventsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type cloudEventsPager struct {
	order  *CloudEventsOrder
	filter func(*CloudEventsQuery) (*CloudEventsQuery, error)
}

func newCloudEventsPager(opts []CloudEventsPaginateOption) (*cloudEventsPager, error) {
	pager := &cloudEventsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCloudEventsOrder
	}
	return pager, nil
}

func (p *cloudEventsPager) applyFilter(query *CloudEventsQuery) (*CloudEventsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *cloudEventsPager) toCursor(ce *CloudEvents) Cursor {
	return p.order.Field.toCursor(ce)
}

func (p *cloudEventsPager) applyCursors(query *CloudEventsQuery, after, before *Cursor) *CloudEventsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCloudEventsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *cloudEventsPager) applyOrder(query *CloudEventsQuery, reverse bool) *CloudEventsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCloudEventsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCloudEventsOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to CloudEvents.
func (ce *CloudEventsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CloudEventsPaginateOption,
) (*CloudEventsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCloudEventsPager(opts)
	if err != nil {
		return nil, err
	}

	if ce, err = pager.applyFilter(ce); err != nil {
		return nil, err
	}

	conn := &CloudEventsConnection{Edges: []*CloudEventsEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ce.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ce.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ce = pager.applyCursors(ce, after, before)
	ce = pager.applyOrder(ce, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ce = ce.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ce = ce.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ce.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *CloudEvents
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CloudEvents {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CloudEvents {
			return nodes[i]
		}
	}

	conn.Edges = make([]*CloudEventsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &CloudEventsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// CloudEventsOrderFieldCreated orders CloudEvents by created.
	CloudEventsOrderFieldCreated = &CloudEventsOrderField{
		field: cloudevents.FieldCreated,
		toCursor: func(ce *CloudEvents) Cursor {
			return Cursor{
				ID:    ce.ID,
				Value: ce.Created,
			}
		},
	}
	// CloudEventsOrderFieldID orders CloudEvents by id.
	CloudEventsOrderFieldID = &CloudEventsOrderField{
		field: cloudevents.FieldID,
		toCursor: func(ce *CloudEvents) Cursor {
			return Cursor{
				ID:    ce.ID,
				Value: ce.ID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CloudEventsOrderField) String() string {
	var str string
	switch f.field {
	case cloudevents.FieldCreated:
		str = "RECEIVED"
	case cloudevents.FieldID:
		str = "ID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CloudEventsOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CloudEventsOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CloudEventsOrderField %T must be a string", v)
	}
	switch str {
	case "RECEIVED":
		*f = *CloudEventsOrderFieldCreated
	case "ID":
		*f = *CloudEventsOrderFieldID
	default:
		return fmt.Errorf("%s is not a valid CloudEventsOrderField", str)
	}
	return nil
}

// CloudEventsOrderField defines the ordering field of CloudEvents.
type CloudEventsOrderField struct {
	field    string
	toCursor func(*CloudEvents) Cursor
}

// CloudEventsOrder defines the ordering of CloudEvents.
type CloudEventsOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *CloudEventsOrderField `json:"field"`
}

// DefaultCloudEventsOrder is the default ordering of CloudEvents.
var DefaultCloudEventsOrder = &CloudEventsOrder{
	Direction: OrderDirectionAsc,
	Field: &CloudEventsOrderField{
		field: cloudevents.FieldID,
		toCursor: func(ce *CloudEvents) Cursor {
			return Cursor{ID: ce.ID}
		},
	},
}

// ToEdge converts CloudEvents into CloudEventsEdge.
func (ce *CloudEvents) ToEdge(order *CloudEventsOrder) *CloudEventsEdge {
	if order == nil {
		order = DefaultCloudEventsOrder
	}
	return &CloudEventsEdge{
		Node:   ce,
		Cursor: order.Field.toCursor(ce),
	}
}

// EventsEdge is the edge representation of Events.
type EventsEdge struct {
	Node   *Events `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// EventsConnection is the connection containing edges to Events.
type EventsConnection struct {
	Edges      []*EventsEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// EventsPaginateOption enables pagination customization.
type EventsPaginateOption func(*eventsPager) error

// WithEventsOrder configures pagination ordering.
func WithEventsOrder(order *EventsOrder) EventsPaginateOption {
	if order == nil {
		order = DefaultEventsOrder
	}
	o := *order
	return func(pager *eventsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEventsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEventsFilter configures pagination filter.
func WithEventsFilter(filter func(*EventsQuery) (*EventsQuery, error)) EventsPaginateOption {
	return func(pager *eventsPager) error {
		if filter == nil {
			return errors.New("EventsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventsPager struct {
	order  *EventsOrder
	filter func(*EventsQuery) (*EventsQuery, error)
}

func newEventsPager(opts []EventsPaginateOption) (*eventsPager, error) {
	pager := &eventsPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEventsOrder
	}
	return pager, nil
}

func (p *eventsPager) applyFilter(query *EventsQuery) (*EventsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventsPager) toCursor(e *Events) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *eventsPager) applyCursors(query *EventsQuery, after, before *Cursor) *EventsQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEventsOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *eventsPager) applyOrder(query *EventsQuery, reverse bool) *EventsQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEventsOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEventsOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Events.
func (e *EventsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventsPaginateOption,
) (*EventsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventsPager(opts)
	if err != nil {
		return nil, err
	}

	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}

	conn := &EventsConnection{Edges: []*EventsEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := e.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := e.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		e = e.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		e = e.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := e.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Events
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Events {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Events {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EventsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EventsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// EventsOrderFieldUpdatedAt orders Events by updated_at.
	EventsOrderFieldUpdatedAt = &EventsOrderField{
		field: events.FieldUpdatedAt,
		toCursor: func(e *Events) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.UpdatedAt,
			}
		},
	}
	// EventsOrderFieldID orders Events by id.
	EventsOrderFieldID = &EventsOrderField{
		field: events.FieldID,
		toCursor: func(e *Events) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.ID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EventsOrderField) String() string {
	var str string
	switch f.field {
	case events.FieldUpdatedAt:
		str = "UPDATED"
	case events.FieldID:
		str = "ID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EventsOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EventsOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EventsOrderField %T must be a string", v)
	}
	switch str {
	case "UPDATED":
		*f = *EventsOrderFieldUpdatedAt
	case "ID":
		*f = *EventsOrderFieldID
	default:
		return fmt.Errorf("%s is not a valid EventsOrderField", str)
	}
	return nil
}

// EventsOrderField defines the ordering field of Events.
type EventsOrderField struct {
	field    string
	toCursor func(*Events) Cursor
}

// EventsOrder defines the ordering of Events.
type EventsOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *EventsOrderField `json:"field"`
}

// DefaultEventsOrder is the default ordering of Events.
var DefaultEventsOrder = &EventsOrder{
	Direction: OrderDirectionAsc,
	Field: &EventsOrderField{
		field: events.FieldID,
		toCursor: func(e *Events) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Events into EventsEdge.
func (e *Events) ToEdge(order *EventsOrder) *EventsEdge {
	if order == nil {
		order = DefaultEventsOrder
	}
	return &EventsEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// EventsWaitEdge is the edge representation of EventsWait.
type EventsWaitEdge struct {
	Node   *EventsWait `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// EventsWaitConnection is the connection containing edges to EventsWait.
type EventsWaitConnection struct {
	Edges      []*EventsWaitEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

// EventsWaitPaginateOption enables pagination customization.
type EventsWaitPaginateOption func(*eventsWaitPager) error

// WithEventsWaitOrder configures pagination ordering.
func WithEventsWaitOrder(order *EventsWaitOrder) EventsWaitPaginateOption {
	if order == nil {
		order = DefaultEventsWaitOrder
	}
	o := *order
	return func(pager *eventsWaitPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEventsWaitOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEventsWaitFilter configures pagination filter.
func WithEventsWaitFilter(filter func(*EventsWaitQuery) (*EventsWaitQuery, error)) EventsWaitPaginateOption {
	return func(pager *eventsWaitPager) error {
		if filter == nil {
			return errors.New("EventsWaitQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type eventsWaitPager struct {
	order  *EventsWaitOrder
	filter func(*EventsWaitQuery) (*EventsWaitQuery, error)
}

func newEventsWaitPager(opts []EventsWaitPaginateOption) (*eventsWaitPager, error) {
	pager := &eventsWaitPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEventsWaitOrder
	}
	return pager, nil
}

func (p *eventsWaitPager) applyFilter(query *EventsWaitQuery) (*EventsWaitQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *eventsWaitPager) toCursor(ew *EventsWait) Cursor {
	return p.order.Field.toCursor(ew)
}

func (p *eventsWaitPager) applyCursors(query *EventsWaitQuery, after, before *Cursor) *EventsWaitQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEventsWaitOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *eventsWaitPager) applyOrder(query *EventsWaitQuery, reverse bool) *EventsWaitQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEventsWaitOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEventsWaitOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to EventsWait.
func (ew *EventsWaitQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EventsWaitPaginateOption,
) (*EventsWaitConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEventsWaitPager(opts)
	if err != nil {
		return nil, err
	}

	if ew, err = pager.applyFilter(ew); err != nil {
		return nil, err
	}

	conn := &EventsWaitConnection{Edges: []*EventsWaitEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ew.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ew.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ew = pager.applyCursors(ew, after, before)
	ew = pager.applyOrder(ew, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ew = ew.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ew = ew.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ew.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *EventsWait
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EventsWait {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EventsWait {
			return nodes[i]
		}
	}

	conn.Edges = make([]*EventsWaitEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &EventsWaitEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// EventsWaitOrderFieldID orders EventsWait by id.
	EventsWaitOrderFieldID = &EventsWaitOrderField{
		field: eventswait.FieldID,
		toCursor: func(ew *EventsWait) Cursor {
			return Cursor{
				ID:    ew.ID,
				Value: ew.ID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EventsWaitOrderField) String() string {
	var str string
	switch f.field {
	case eventswait.FieldID:
		str = "ID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EventsWaitOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EventsWaitOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EventsWaitOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *EventsWaitOrderFieldID
	default:
		return fmt.Errorf("%s is not a valid EventsWaitOrderField", str)
	}
	return nil
}

// EventsWaitOrderField defines the ordering field of EventsWait.
type EventsWaitOrderField struct {
	field    string
	toCursor func(*EventsWait) Cursor
}

// EventsWaitOrder defines the ordering of EventsWait.
type EventsWaitOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *EventsWaitOrderField `json:"field"`
}

// DefaultEventsWaitOrder is the default ordering of EventsWait.
var DefaultEventsWaitOrder = &EventsWaitOrder{
	Direction: OrderDirectionAsc,
	Field: &EventsWaitOrderField{
		field: eventswait.FieldID,
		toCursor: func(ew *EventsWait) Cursor {
			return Cursor{ID: ew.ID}
		},
	},
}

// ToEdge converts EventsWait into EventsWaitEdge.
func (ew *EventsWait) ToEdge(order *EventsWaitOrder) *EventsWaitEdge {
	if order == nil {
		order = DefaultEventsWaitOrder
	}
	return &EventsWaitEdge{
		Node:   ew,
		Cursor: order.Field.toCursor(ew),
	}
}

// InodeEdge is the edge representation of Inode.
type InodeEdge struct {
	Node   *Inode `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// InodeConnection is the connection containing edges to Inode.
type InodeConnection struct {
	Edges      []*InodeEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// InodePaginateOption enables pagination customization.
type InodePaginateOption func(*inodePager) error

// WithInodeOrder configures pagination ordering.
func WithInodeOrder(order *InodeOrder) InodePaginateOption {
	if order == nil {
		order = DefaultInodeOrder
	}
	o := *order
	return func(pager *inodePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInodeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInodeFilter configures pagination filter.
func WithInodeFilter(filter func(*InodeQuery) (*InodeQuery, error)) InodePaginateOption {
	return func(pager *inodePager) error {
		if filter == nil {
			return errors.New("InodeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type inodePager struct {
	order  *InodeOrder
	filter func(*InodeQuery) (*InodeQuery, error)
}

func newInodePager(opts []InodePaginateOption) (*inodePager, error) {
	pager := &inodePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInodeOrder
	}
	return pager, nil
}

func (p *inodePager) applyFilter(query *InodeQuery) (*InodeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *inodePager) toCursor(i *Inode) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *inodePager) applyCursors(query *InodeQuery, after, before *Cursor) *InodeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultInodeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *inodePager) applyOrder(query *InodeQuery, reverse bool) *InodeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultInodeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultInodeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Inode.
func (i *InodeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InodePaginateOption,
) (*InodeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInodePager(opts)
	if err != nil {
		return nil, err
	}

	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}

	conn := &InodeConnection{Edges: []*InodeEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := i.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := i.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	i = pager.applyCursors(i, after, before)
	i = pager.applyOrder(i, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		i = i.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		i = i.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := i.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Inode
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Inode {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Inode {
			return nodes[i]
		}
	}

	conn.Edges = make([]*InodeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &InodeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// InodeOrderFieldCreatedAt orders Inode by created_at.
	InodeOrderFieldCreatedAt = &InodeOrderField{
		field: inode.FieldCreatedAt,
		toCursor: func(i *Inode) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.CreatedAt,
			}
		},
	}
	// InodeOrderFieldUpdatedAt orders Inode by updated_at.
	InodeOrderFieldUpdatedAt = &InodeOrderField{
		field: inode.FieldUpdatedAt,
		toCursor: func(i *Inode) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.UpdatedAt,
			}
		},
	}
	// InodeOrderFieldName orders Inode by name.
	InodeOrderFieldName = &InodeOrderField{
		field: inode.FieldName,
		toCursor: func(i *Inode) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Name,
			}
		},
	}
	// InodeOrderFieldType orders Inode by type.
	InodeOrderFieldType = &InodeOrderField{
		field: inode.FieldType,
		toCursor: func(i *Inode) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Type,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InodeOrderField) String() string {
	var str string
	switch f.field {
	case inode.FieldCreatedAt:
		str = "CREATED"
	case inode.FieldUpdatedAt:
		str = "UPDATED"
	case inode.FieldName:
		str = "NAME"
	case inode.FieldType:
		str = "TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InodeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InodeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InodeOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *InodeOrderFieldCreatedAt
	case "UPDATED":
		*f = *InodeOrderFieldUpdatedAt
	case "NAME":
		*f = *InodeOrderFieldName
	case "TYPE":
		*f = *InodeOrderFieldType
	default:
		return fmt.Errorf("%s is not a valid InodeOrderField", str)
	}
	return nil
}

// InodeOrderField defines the ordering field of Inode.
type InodeOrderField struct {
	field    string
	toCursor func(*Inode) Cursor
}

// InodeOrder defines the ordering of Inode.
type InodeOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *InodeOrderField `json:"field"`
}

// DefaultInodeOrder is the default ordering of Inode.
var DefaultInodeOrder = &InodeOrder{
	Direction: OrderDirectionAsc,
	Field: &InodeOrderField{
		field: inode.FieldID,
		toCursor: func(i *Inode) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Inode into InodeEdge.
func (i *Inode) ToEdge(order *InodeOrder) *InodeEdge {
	if order == nil {
		order = DefaultInodeOrder
	}
	return &InodeEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// InstanceEdge is the edge representation of Instance.
type InstanceEdge struct {
	Node   *Instance `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// InstanceConnection is the connection containing edges to Instance.
type InstanceConnection struct {
	Edges      []*InstanceEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// InstancePaginateOption enables pagination customization.
type InstancePaginateOption func(*instancePager) error

// WithInstanceOrder configures pagination ordering.
func WithInstanceOrder(order *InstanceOrder) InstancePaginateOption {
	if order == nil {
		order = DefaultInstanceOrder
	}
	o := *order
	return func(pager *instancePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInstanceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInstanceFilter configures pagination filter.
func WithInstanceFilter(filter func(*InstanceQuery) (*InstanceQuery, error)) InstancePaginateOption {
	return func(pager *instancePager) error {
		if filter == nil {
			return errors.New("InstanceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type instancePager struct {
	order  *InstanceOrder
	filter func(*InstanceQuery) (*InstanceQuery, error)
}

func newInstancePager(opts []InstancePaginateOption) (*instancePager, error) {
	pager := &instancePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInstanceOrder
	}
	return pager, nil
}

func (p *instancePager) applyFilter(query *InstanceQuery) (*InstanceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *instancePager) toCursor(i *Instance) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *instancePager) applyCursors(query *InstanceQuery, after, before *Cursor) *InstanceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultInstanceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *instancePager) applyOrder(query *InstanceQuery, reverse bool) *InstanceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultInstanceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultInstanceOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Instance.
func (i *InstanceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InstancePaginateOption,
) (*InstanceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInstancePager(opts)
	if err != nil {
		return nil, err
	}

	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}

	conn := &InstanceConnection{Edges: []*InstanceEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := i.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := i.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	i = pager.applyCursors(i, after, before)
	i = pager.applyOrder(i, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		i = i.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		i = i.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := i.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Instance
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Instance {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Instance {
			return nodes[i]
		}
	}

	conn.Edges = make([]*InstanceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &InstanceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// InstanceOrderFieldCreatedAt orders Instance by created_at.
	InstanceOrderFieldCreatedAt = &InstanceOrderField{
		field: instance.FieldCreatedAt,
		toCursor: func(i *Instance) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.CreatedAt,
			}
		},
	}
	// InstanceOrderFieldID orders Instance by id.
	InstanceOrderFieldID = &InstanceOrderField{
		field: instance.FieldID,
		toCursor: func(i *Instance) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.ID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InstanceOrderField) String() string {
	var str string
	switch f.field {
	case instance.FieldCreatedAt:
		str = "CREATED"
	case instance.FieldID:
		str = "ID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InstanceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InstanceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InstanceOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *InstanceOrderFieldCreatedAt
	case "ID":
		*f = *InstanceOrderFieldID
	default:
		return fmt.Errorf("%s is not a valid InstanceOrderField", str)
	}
	return nil
}

// InstanceOrderField defines the ordering field of Instance.
type InstanceOrderField struct {
	field    string
	toCursor func(*Instance) Cursor
}

// InstanceOrder defines the ordering of Instance.
type InstanceOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *InstanceOrderField `json:"field"`
}

// DefaultInstanceOrder is the default ordering of Instance.
var DefaultInstanceOrder = &InstanceOrder{
	Direction: OrderDirectionAsc,
	Field: &InstanceOrderField{
		field: instance.FieldID,
		toCursor: func(i *Instance) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Instance into InstanceEdge.
func (i *Instance) ToEdge(order *InstanceOrder) *InstanceEdge {
	if order == nil {
		order = DefaultInstanceOrder
	}
	return &InstanceEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// InstanceRuntimeEdge is the edge representation of InstanceRuntime.
type InstanceRuntimeEdge struct {
	Node   *InstanceRuntime `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// InstanceRuntimeConnection is the connection containing edges to InstanceRuntime.
type InstanceRuntimeConnection struct {
	Edges      []*InstanceRuntimeEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

// InstanceRuntimePaginateOption enables pagination customization.
type InstanceRuntimePaginateOption func(*instanceRuntimePager) error

// WithInstanceRuntimeOrder configures pagination ordering.
func WithInstanceRuntimeOrder(order *InstanceRuntimeOrder) InstanceRuntimePaginateOption {
	if order == nil {
		order = DefaultInstanceRuntimeOrder
	}
	o := *order
	return func(pager *instanceRuntimePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInstanceRuntimeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInstanceRuntimeFilter configures pagination filter.
func WithInstanceRuntimeFilter(filter func(*InstanceRuntimeQuery) (*InstanceRuntimeQuery, error)) InstanceRuntimePaginateOption {
	return func(pager *instanceRuntimePager) error {
		if filter == nil {
			return errors.New("InstanceRuntimeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type instanceRuntimePager struct {
	order  *InstanceRuntimeOrder
	filter func(*InstanceRuntimeQuery) (*InstanceRuntimeQuery, error)
}

func newInstanceRuntimePager(opts []InstanceRuntimePaginateOption) (*instanceRuntimePager, error) {
	pager := &instanceRuntimePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInstanceRuntimeOrder
	}
	return pager, nil
}

func (p *instanceRuntimePager) applyFilter(query *InstanceRuntimeQuery) (*InstanceRuntimeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *instanceRuntimePager) toCursor(ir *InstanceRuntime) Cursor {
	return p.order.Field.toCursor(ir)
}

func (p *instanceRuntimePager) applyCursors(query *InstanceRuntimeQuery, after, before *Cursor) *InstanceRuntimeQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultInstanceRuntimeOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *instanceRuntimePager) applyOrder(query *InstanceRuntimeQuery, reverse bool) *InstanceRuntimeQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultInstanceRuntimeOrder.Field {
		query = query.Order(direction.orderFunc(DefaultInstanceRuntimeOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to InstanceRuntime.
func (ir *InstanceRuntimeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InstanceRuntimePaginateOption,
) (*InstanceRuntimeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInstanceRuntimePager(opts)
	if err != nil {
		return nil, err
	}

	if ir, err = pager.applyFilter(ir); err != nil {
		return nil, err
	}

	conn := &InstanceRuntimeConnection{Edges: []*InstanceRuntimeEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := ir.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := ir.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	ir = pager.applyCursors(ir, after, before)
	ir = pager.applyOrder(ir, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		ir = ir.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		ir = ir.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := ir.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *InstanceRuntime
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InstanceRuntime {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InstanceRuntime {
			return nodes[i]
		}
	}

	conn.Edges = make([]*InstanceRuntimeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &InstanceRuntimeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// InstanceRuntimeOrderFieldID orders InstanceRuntime by id.
	InstanceRuntimeOrderFieldID = &InstanceRuntimeOrderField{
		field: instanceruntime.FieldID,
		toCursor: func(ir *InstanceRuntime) Cursor {
			return Cursor{
				ID:    ir.ID,
				Value: ir.ID,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f InstanceRuntimeOrderField) String() string {
	var str string
	switch f.field {
	case instanceruntime.FieldID:
		str = "ID"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f InstanceRuntimeOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *InstanceRuntimeOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("InstanceRuntimeOrderField %T must be a string", v)
	}
	switch str {
	case "ID":
		*f = *InstanceRuntimeOrderFieldID
	default:
		return fmt.Errorf("%s is not a valid InstanceRuntimeOrderField", str)
	}
	return nil
}

// InstanceRuntimeOrderField defines the ordering field of InstanceRuntime.
type InstanceRuntimeOrderField struct {
	field    string
	toCursor func(*InstanceRuntime) Cursor
}

// InstanceRuntimeOrder defines the ordering of InstanceRuntime.
type InstanceRuntimeOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *InstanceRuntimeOrderField `json:"field"`
}

// DefaultInstanceRuntimeOrder is the default ordering of InstanceRuntime.
var DefaultInstanceRuntimeOrder = &InstanceRuntimeOrder{
	Direction: OrderDirectionAsc,
	Field: &InstanceRuntimeOrderField{
		field: instanceruntime.FieldID,
		toCursor: func(ir *InstanceRuntime) Cursor {
			return Cursor{ID: ir.ID}
		},
	},
}

// ToEdge converts InstanceRuntime into InstanceRuntimeEdge.
func (ir *InstanceRuntime) ToEdge(order *InstanceRuntimeOrder) *InstanceRuntimeEdge {
	if order == nil {
		order = DefaultInstanceRuntimeOrder
	}
	return &InstanceRuntimeEdge{
		Node:   ir,
		Cursor: order.Field.toCursor(ir),
	}
}

// LogMsgEdge is the edge representation of LogMsg.
type LogMsgEdge struct {
	Node   *LogMsg `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// LogMsgConnection is the connection containing edges to LogMsg.
type LogMsgConnection struct {
	Edges      []*LogMsgEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// LogMsgPaginateOption enables pagination customization.
type LogMsgPaginateOption func(*logMsgPager) error

// WithLogMsgOrder configures pagination ordering.
func WithLogMsgOrder(order *LogMsgOrder) LogMsgPaginateOption {
	if order == nil {
		order = DefaultLogMsgOrder
	}
	o := *order
	return func(pager *logMsgPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLogMsgOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLogMsgFilter configures pagination filter.
func WithLogMsgFilter(filter func(*LogMsgQuery) (*LogMsgQuery, error)) LogMsgPaginateOption {
	return func(pager *logMsgPager) error {
		if filter == nil {
			return errors.New("LogMsgQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type logMsgPager struct {
	order  *LogMsgOrder
	filter func(*LogMsgQuery) (*LogMsgQuery, error)
}

func newLogMsgPager(opts []LogMsgPaginateOption) (*logMsgPager, error) {
	pager := &logMsgPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLogMsgOrder
	}
	return pager, nil
}

func (p *logMsgPager) applyFilter(query *LogMsgQuery) (*LogMsgQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *logMsgPager) toCursor(lm *LogMsg) Cursor {
	return p.order.Field.toCursor(lm)
}

func (p *logMsgPager) applyCursors(query *LogMsgQuery, after, before *Cursor) *LogMsgQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultLogMsgOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *logMsgPager) applyOrder(query *LogMsgQuery, reverse bool) *LogMsgQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultLogMsgOrder.Field {
		query = query.Order(direction.orderFunc(DefaultLogMsgOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to LogMsg.
func (lm *LogMsgQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LogMsgPaginateOption,
) (*LogMsgConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLogMsgPager(opts)
	if err != nil {
		return nil, err
	}

	if lm, err = pager.applyFilter(lm); err != nil {
		return nil, err
	}

	conn := &LogMsgConnection{Edges: []*LogMsgEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := lm.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := lm.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	lm = pager.applyCursors(lm, after, before)
	lm = pager.applyOrder(lm, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		lm = lm.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		lm = lm.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := lm.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *LogMsg
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LogMsg {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LogMsg {
			return nodes[i]
		}
	}

	conn.Edges = make([]*LogMsgEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &LogMsgEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// LogMsgOrderFieldT orders LogMsg by t.
	LogMsgOrderFieldT = &LogMsgOrderField{
		field: logmsg.FieldT,
		toCursor: func(lm *LogMsg) Cursor {
			return Cursor{
				ID:    lm.ID,
				Value: lm.T,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LogMsgOrderField) String() string {
	var str string
	switch f.field {
	case logmsg.FieldT:
		str = "TIMESTAMP"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LogMsgOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LogMsgOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LogMsgOrderField %T must be a string", v)
	}
	switch str {
	case "TIMESTAMP":
		*f = *LogMsgOrderFieldT
	default:
		return fmt.Errorf("%s is not a valid LogMsgOrderField", str)
	}
	return nil
}

// LogMsgOrderField defines the ordering field of LogMsg.
type LogMsgOrderField struct {
	field    string
	toCursor func(*LogMsg) Cursor
}

// LogMsgOrder defines the ordering of LogMsg.
type LogMsgOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *LogMsgOrderField `json:"field"`
}

// DefaultLogMsgOrder is the default ordering of LogMsg.
var DefaultLogMsgOrder = &LogMsgOrder{
	Direction: OrderDirectionAsc,
	Field: &LogMsgOrderField{
		field: logmsg.FieldID,
		toCursor: func(lm *LogMsg) Cursor {
			return Cursor{ID: lm.ID}
		},
	},
}

// ToEdge converts LogMsg into LogMsgEdge.
func (lm *LogMsg) ToEdge(order *LogMsgOrder) *LogMsgEdge {
	if order == nil {
		order = DefaultLogMsgOrder
	}
	return &LogMsgEdge{
		Node:   lm,
		Cursor: order.Field.toCursor(lm),
	}
}

// NamespaceEdge is the edge representation of Namespace.
type NamespaceEdge struct {
	Node   *Namespace `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// NamespaceConnection is the connection containing edges to Namespace.
type NamespaceConnection struct {
	Edges      []*NamespaceEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

// NamespacePaginateOption enables pagination customization.
type NamespacePaginateOption func(*namespacePager) error

// WithNamespaceOrder configures pagination ordering.
func WithNamespaceOrder(order *NamespaceOrder) NamespacePaginateOption {
	if order == nil {
		order = DefaultNamespaceOrder
	}
	o := *order
	return func(pager *namespacePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNamespaceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNamespaceFilter configures pagination filter.
func WithNamespaceFilter(filter func(*NamespaceQuery) (*NamespaceQuery, error)) NamespacePaginateOption {
	return func(pager *namespacePager) error {
		if filter == nil {
			return errors.New("NamespaceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type namespacePager struct {
	order  *NamespaceOrder
	filter func(*NamespaceQuery) (*NamespaceQuery, error)
}

func newNamespacePager(opts []NamespacePaginateOption) (*namespacePager, error) {
	pager := &namespacePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNamespaceOrder
	}
	return pager, nil
}

func (p *namespacePager) applyFilter(query *NamespaceQuery) (*NamespaceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *namespacePager) toCursor(n *Namespace) Cursor {
	return p.order.Field.toCursor(n)
}

func (p *namespacePager) applyCursors(query *NamespaceQuery, after, before *Cursor) *NamespaceQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultNamespaceOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *namespacePager) applyOrder(query *NamespaceQuery, reverse bool) *NamespaceQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultNamespaceOrder.Field {
		query = query.Order(direction.orderFunc(DefaultNamespaceOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Namespace.
func (n *NamespaceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NamespacePaginateOption,
) (*NamespaceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNamespacePager(opts)
	if err != nil {
		return nil, err
	}

	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}

	conn := &NamespaceConnection{Edges: []*NamespaceEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := n.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := n.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	n = pager.applyCursors(n, after, before)
	n = pager.applyOrder(n, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		n = n.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		n = n.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := n.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Namespace
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Namespace {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Namespace {
			return nodes[i]
		}
	}

	conn.Edges = make([]*NamespaceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &NamespaceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// NamespaceOrderFieldName orders Namespace by name.
	NamespaceOrderFieldName = &NamespaceOrderField{
		field: namespace.FieldName,
		toCursor: func(n *Namespace) Cursor {
			return Cursor{
				ID:    n.ID,
				Value: n.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f NamespaceOrderField) String() string {
	var str string
	switch f.field {
	case namespace.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f NamespaceOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *NamespaceOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("NamespaceOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *NamespaceOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid NamespaceOrderField", str)
	}
	return nil
}

// NamespaceOrderField defines the ordering field of Namespace.
type NamespaceOrderField struct {
	field    string
	toCursor func(*Namespace) Cursor
}

// NamespaceOrder defines the ordering of Namespace.
type NamespaceOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *NamespaceOrderField `json:"field"`
}

// DefaultNamespaceOrder is the default ordering of Namespace.
var DefaultNamespaceOrder = &NamespaceOrder{
	Direction: OrderDirectionAsc,
	Field: &NamespaceOrderField{
		field: namespace.FieldID,
		toCursor: func(n *Namespace) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Namespace into NamespaceEdge.
func (n *Namespace) ToEdge(order *NamespaceOrder) *NamespaceEdge {
	if order == nil {
		order = DefaultNamespaceOrder
	}
	return &NamespaceEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// RefEdge is the edge representation of Ref.
type RefEdge struct {
	Node   *Ref   `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RefConnection is the connection containing edges to Ref.
type RefConnection struct {
	Edges      []*RefEdge `json:"edges"`
	PageInfo   PageInfo   `json:"pageInfo"`
	TotalCount int        `json:"totalCount"`
}

// RefPaginateOption enables pagination customization.
type RefPaginateOption func(*refPager) error

// WithRefOrder configures pagination ordering.
func WithRefOrder(order *RefOrder) RefPaginateOption {
	if order == nil {
		order = DefaultRefOrder
	}
	o := *order
	return func(pager *refPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRefOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRefFilter configures pagination filter.
func WithRefFilter(filter func(*RefQuery) (*RefQuery, error)) RefPaginateOption {
	return func(pager *refPager) error {
		if filter == nil {
			return errors.New("RefQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type refPager struct {
	order  *RefOrder
	filter func(*RefQuery) (*RefQuery, error)
}

func newRefPager(opts []RefPaginateOption) (*refPager, error) {
	pager := &refPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRefOrder
	}
	return pager, nil
}

func (p *refPager) applyFilter(query *RefQuery) (*RefQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *refPager) toCursor(r *Ref) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *refPager) applyCursors(query *RefQuery, after, before *Cursor) *RefQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRefOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *refPager) applyOrder(query *RefQuery, reverse bool) *RefQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRefOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRefOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Ref.
func (r *RefQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RefPaginateOption,
) (*RefConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRefPager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &RefConnection{Edges: []*RefEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Ref
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Ref {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Ref {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RefEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RefEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// RefOrderFieldName orders Ref by name.
	RefOrderFieldName = &RefOrderField{
		field: ref.FieldName,
		toCursor: func(r *Ref) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.Name,
			}
		},
	}
	// RefOrderFieldCreatedAt orders Ref by created_at.
	RefOrderFieldCreatedAt = &RefOrderField{
		field: ref.FieldCreatedAt,
		toCursor: func(r *Ref) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RefOrderField) String() string {
	var str string
	switch f.field {
	case ref.FieldName:
		str = "NAME"
	case ref.FieldCreatedAt:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RefOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RefOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RefOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *RefOrderFieldName
	case "CREATED":
		*f = *RefOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid RefOrderField", str)
	}
	return nil
}

// RefOrderField defines the ordering field of Ref.
type RefOrderField struct {
	field    string
	toCursor func(*Ref) Cursor
}

// RefOrder defines the ordering of Ref.
type RefOrder struct {
	Direction OrderDirection `json:"direction"`
	Field     *RefOrderField `json:"field"`
}

// DefaultRefOrder is the default ordering of Ref.
var DefaultRefOrder = &RefOrder{
	Direction: OrderDirectionAsc,
	Field: &RefOrderField{
		field: ref.FieldID,
		toCursor: func(r *Ref) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Ref into RefEdge.
func (r *Ref) ToEdge(order *RefOrder) *RefEdge {
	if order == nil {
		order = DefaultRefOrder
	}
	return &RefEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// RevisionEdge is the edge representation of Revision.
type RevisionEdge struct {
	Node   *Revision `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// RevisionConnection is the connection containing edges to Revision.
type RevisionConnection struct {
	Edges      []*RevisionEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// RevisionPaginateOption enables pagination customization.
type RevisionPaginateOption func(*revisionPager) error

// WithRevisionOrder configures pagination ordering.
func WithRevisionOrder(order *RevisionOrder) RevisionPaginateOption {
	if order == nil {
		order = DefaultRevisionOrder
	}
	o := *order
	return func(pager *revisionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRevisionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRevisionFilter configures pagination filter.
func WithRevisionFilter(filter func(*RevisionQuery) (*RevisionQuery, error)) RevisionPaginateOption {
	return func(pager *revisionPager) error {
		if filter == nil {
			return errors.New("RevisionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type revisionPager struct {
	order  *RevisionOrder
	filter func(*RevisionQuery) (*RevisionQuery, error)
}

func newRevisionPager(opts []RevisionPaginateOption) (*revisionPager, error) {
	pager := &revisionPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRevisionOrder
	}
	return pager, nil
}

func (p *revisionPager) applyFilter(query *RevisionQuery) (*RevisionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *revisionPager) toCursor(r *Revision) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *revisionPager) applyCursors(query *RevisionQuery, after, before *Cursor) *RevisionQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRevisionOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *revisionPager) applyOrder(query *RevisionQuery, reverse bool) *RevisionQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRevisionOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRevisionOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Revision.
func (r *RevisionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RevisionPaginateOption,
) (*RevisionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRevisionPager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &RevisionConnection{Edges: []*RevisionEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Revision
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Revision {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Revision {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RevisionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RevisionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// RevisionOrderFieldCreatedAt orders Revision by created_at.
	RevisionOrderFieldCreatedAt = &RevisionOrderField{
		field: revision.FieldCreatedAt,
		toCursor: func(r *Revision) Cursor {
			return Cursor{
				ID:    r.ID,
				Value: r.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f RevisionOrderField) String() string {
	var str string
	switch f.field {
	case revision.FieldCreatedAt:
		str = "CREATED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f RevisionOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *RevisionOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("RevisionOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED":
		*f = *RevisionOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid RevisionOrderField", str)
	}
	return nil
}

// RevisionOrderField defines the ordering field of Revision.
type RevisionOrderField struct {
	field    string
	toCursor func(*Revision) Cursor
}

// RevisionOrder defines the ordering of Revision.
type RevisionOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *RevisionOrderField `json:"field"`
}

// DefaultRevisionOrder is the default ordering of Revision.
var DefaultRevisionOrder = &RevisionOrder{
	Direction: OrderDirectionAsc,
	Field: &RevisionOrderField{
		field: revision.FieldID,
		toCursor: func(r *Revision) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Revision into RevisionEdge.
func (r *Revision) ToEdge(order *RevisionOrder) *RevisionEdge {
	if order == nil {
		order = DefaultRevisionOrder
	}
	return &RevisionEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// RouteEdge is the edge representation of Route.
type RouteEdge struct {
	Node   *Route `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// RouteConnection is the connection containing edges to Route.
type RouteConnection struct {
	Edges      []*RouteEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

// RoutePaginateOption enables pagination customization.
type RoutePaginateOption func(*routePager) error

// WithRouteOrder configures pagination ordering.
func WithRouteOrder(order *RouteOrder) RoutePaginateOption {
	if order == nil {
		order = DefaultRouteOrder
	}
	o := *order
	return func(pager *routePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultRouteOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithRouteFilter configures pagination filter.
func WithRouteFilter(filter func(*RouteQuery) (*RouteQuery, error)) RoutePaginateOption {
	return func(pager *routePager) error {
		if filter == nil {
			return errors.New("RouteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type routePager struct {
	order  *RouteOrder
	filter func(*RouteQuery) (*RouteQuery, error)
}

func newRoutePager(opts []RoutePaginateOption) (*routePager, error) {
	pager := &routePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultRouteOrder
	}
	return pager, nil
}

func (p *routePager) applyFilter(query *RouteQuery) (*RouteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *routePager) toCursor(r *Route) Cursor {
	return p.order.Field.toCursor(r)
}

func (p *routePager) applyCursors(query *RouteQuery, after, before *Cursor) *RouteQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultRouteOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *routePager) applyOrder(query *RouteQuery, reverse bool) *RouteQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultRouteOrder.Field {
		query = query.Order(direction.orderFunc(DefaultRouteOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Route.
func (r *RouteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...RoutePaginateOption,
) (*RouteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newRoutePager(opts)
	if err != nil {
		return nil, err
	}

	if r, err = pager.applyFilter(r); err != nil {
		return nil, err
	}

	conn := &RouteConnection{Edges: []*RouteEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := r.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := r.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	r = pager.applyCursors(r, after, before)
	r = pager.applyOrder(r, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		r = r.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		r = r.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := r.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Route
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Route {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Route {
			return nodes[i]
		}
	}

	conn.Edges = make([]*RouteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &RouteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// RouteOrderField defines the ordering field of Route.
type RouteOrderField struct {
	field    string
	toCursor func(*Route) Cursor
}

// RouteOrder defines the ordering of Route.
type RouteOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *RouteOrderField `json:"field"`
}

// DefaultRouteOrder is the default ordering of Route.
var DefaultRouteOrder = &RouteOrder{
	Direction: OrderDirectionAsc,
	Field: &RouteOrderField{
		field: route.FieldID,
		toCursor: func(r *Route) Cursor {
			return Cursor{ID: r.ID}
		},
	},
}

// ToEdge converts Route into RouteEdge.
func (r *Route) ToEdge(order *RouteOrder) *RouteEdge {
	if order == nil {
		order = DefaultRouteOrder
	}
	return &RouteEdge{
		Node:   r,
		Cursor: order.Field.toCursor(r),
	}
}

// VarDataEdge is the edge representation of VarData.
type VarDataEdge struct {
	Node   *VarData `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// VarDataConnection is the connection containing edges to VarData.
type VarDataConnection struct {
	Edges      []*VarDataEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

// VarDataPaginateOption enables pagination customization.
type VarDataPaginateOption func(*varDataPager) error

// WithVarDataOrder configures pagination ordering.
func WithVarDataOrder(order *VarDataOrder) VarDataPaginateOption {
	if order == nil {
		order = DefaultVarDataOrder
	}
	o := *order
	return func(pager *varDataPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVarDataOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVarDataFilter configures pagination filter.
func WithVarDataFilter(filter func(*VarDataQuery) (*VarDataQuery, error)) VarDataPaginateOption {
	return func(pager *varDataPager) error {
		if filter == nil {
			return errors.New("VarDataQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type varDataPager struct {
	order  *VarDataOrder
	filter func(*VarDataQuery) (*VarDataQuery, error)
}

func newVarDataPager(opts []VarDataPaginateOption) (*varDataPager, error) {
	pager := &varDataPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVarDataOrder
	}
	return pager, nil
}

func (p *varDataPager) applyFilter(query *VarDataQuery) (*VarDataQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *varDataPager) toCursor(vd *VarData) Cursor {
	return p.order.Field.toCursor(vd)
}

func (p *varDataPager) applyCursors(query *VarDataQuery, after, before *Cursor) *VarDataQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVarDataOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *varDataPager) applyOrder(query *VarDataQuery, reverse bool) *VarDataQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVarDataOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVarDataOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to VarData.
func (vd *VarDataQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VarDataPaginateOption,
) (*VarDataConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVarDataPager(opts)
	if err != nil {
		return nil, err
	}

	if vd, err = pager.applyFilter(vd); err != nil {
		return nil, err
	}

	conn := &VarDataConnection{Edges: []*VarDataEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := vd.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := vd.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	vd = pager.applyCursors(vd, after, before)
	vd = pager.applyOrder(vd, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		vd = vd.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		vd = vd.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := vd.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *VarData
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VarData {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VarData {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VarDataEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VarDataEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// VarDataOrderField defines the ordering field of VarData.
type VarDataOrderField struct {
	field    string
	toCursor func(*VarData) Cursor
}

// VarDataOrder defines the ordering of VarData.
type VarDataOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *VarDataOrderField `json:"field"`
}

// DefaultVarDataOrder is the default ordering of VarData.
var DefaultVarDataOrder = &VarDataOrder{
	Direction: OrderDirectionAsc,
	Field: &VarDataOrderField{
		field: vardata.FieldID,
		toCursor: func(vd *VarData) Cursor {
			return Cursor{ID: vd.ID}
		},
	},
}

// ToEdge converts VarData into VarDataEdge.
func (vd *VarData) ToEdge(order *VarDataOrder) *VarDataEdge {
	if order == nil {
		order = DefaultVarDataOrder
	}
	return &VarDataEdge{
		Node:   vd,
		Cursor: order.Field.toCursor(vd),
	}
}

// VarRefEdge is the edge representation of VarRef.
type VarRefEdge struct {
	Node   *VarRef `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// VarRefConnection is the connection containing edges to VarRef.
type VarRefConnection struct {
	Edges      []*VarRefEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

// VarRefPaginateOption enables pagination customization.
type VarRefPaginateOption func(*varRefPager) error

// WithVarRefOrder configures pagination ordering.
func WithVarRefOrder(order *VarRefOrder) VarRefPaginateOption {
	if order == nil {
		order = DefaultVarRefOrder
	}
	o := *order
	return func(pager *varRefPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVarRefOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVarRefFilter configures pagination filter.
func WithVarRefFilter(filter func(*VarRefQuery) (*VarRefQuery, error)) VarRefPaginateOption {
	return func(pager *varRefPager) error {
		if filter == nil {
			return errors.New("VarRefQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type varRefPager struct {
	order  *VarRefOrder
	filter func(*VarRefQuery) (*VarRefQuery, error)
}

func newVarRefPager(opts []VarRefPaginateOption) (*varRefPager, error) {
	pager := &varRefPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVarRefOrder
	}
	return pager, nil
}

func (p *varRefPager) applyFilter(query *VarRefQuery) (*VarRefQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *varRefPager) toCursor(vr *VarRef) Cursor {
	return p.order.Field.toCursor(vr)
}

func (p *varRefPager) applyCursors(query *VarRefQuery, after, before *Cursor) *VarRefQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVarRefOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *varRefPager) applyOrder(query *VarRefQuery, reverse bool) *VarRefQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVarRefOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVarRefOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to VarRef.
func (vr *VarRefQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VarRefPaginateOption,
) (*VarRefConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVarRefPager(opts)
	if err != nil {
		return nil, err
	}

	if vr, err = pager.applyFilter(vr); err != nil {
		return nil, err
	}

	conn := &VarRefConnection{Edges: []*VarRefEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := vr.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := vr.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	vr = pager.applyCursors(vr, after, before)
	vr = pager.applyOrder(vr, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		vr = vr.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		vr = vr.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := vr.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *VarRef
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *VarRef {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *VarRef {
			return nodes[i]
		}
	}

	conn.Edges = make([]*VarRefEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &VarRefEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

var (
	// VarRefOrderFieldName orders VarRef by name.
	VarRefOrderFieldName = &VarRefOrderField{
		field: varref.FieldName,
		toCursor: func(vr *VarRef) Cursor {
			return Cursor{
				ID:    vr.ID,
				Value: vr.Name,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VarRefOrderField) String() string {
	var str string
	switch f.field {
	case varref.FieldName:
		str = "NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VarRefOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VarRefOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VarRefOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *VarRefOrderFieldName
	default:
		return fmt.Errorf("%s is not a valid VarRefOrderField", str)
	}
	return nil
}

// VarRefOrderField defines the ordering field of VarRef.
type VarRefOrderField struct {
	field    string
	toCursor func(*VarRef) Cursor
}

// VarRefOrder defines the ordering of VarRef.
type VarRefOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *VarRefOrderField `json:"field"`
}

// DefaultVarRefOrder is the default ordering of VarRef.
var DefaultVarRefOrder = &VarRefOrder{
	Direction: OrderDirectionAsc,
	Field: &VarRefOrderField{
		field: varref.FieldID,
		toCursor: func(vr *VarRef) Cursor {
			return Cursor{ID: vr.ID}
		},
	},
}

// ToEdge converts VarRef into VarRefEdge.
func (vr *VarRef) ToEdge(order *VarRefOrder) *VarRefEdge {
	if order == nil {
		order = DefaultVarRefOrder
	}
	return &VarRefEdge{
		Node:   vr,
		Cursor: order.Field.toCursor(vr),
	}
}

// WorkflowEdge is the edge representation of Workflow.
type WorkflowEdge struct {
	Node   *Workflow `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// WorkflowConnection is the connection containing edges to Workflow.
type WorkflowConnection struct {
	Edges      []*WorkflowEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

// WorkflowPaginateOption enables pagination customization.
type WorkflowPaginateOption func(*workflowPager) error

// WithWorkflowOrder configures pagination ordering.
func WithWorkflowOrder(order *WorkflowOrder) WorkflowPaginateOption {
	if order == nil {
		order = DefaultWorkflowOrder
	}
	o := *order
	return func(pager *workflowPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkflowOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkflowFilter configures pagination filter.
func WithWorkflowFilter(filter func(*WorkflowQuery) (*WorkflowQuery, error)) WorkflowPaginateOption {
	return func(pager *workflowPager) error {
		if filter == nil {
			return errors.New("WorkflowQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workflowPager struct {
	order  *WorkflowOrder
	filter func(*WorkflowQuery) (*WorkflowQuery, error)
}

func newWorkflowPager(opts []WorkflowPaginateOption) (*workflowPager, error) {
	pager := &workflowPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkflowOrder
	}
	return pager, nil
}

func (p *workflowPager) applyFilter(query *WorkflowQuery) (*WorkflowQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workflowPager) toCursor(w *Workflow) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *workflowPager) applyCursors(query *WorkflowQuery, after, before *Cursor) *WorkflowQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWorkflowOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *workflowPager) applyOrder(query *WorkflowQuery, reverse bool) *WorkflowQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWorkflowOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWorkflowOrder.Field.field))
	}
	return query
}

// Paginate executes the query and returns a relay based cursor connection to Workflow.
func (w *WorkflowQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkflowPaginateOption,
) (*WorkflowConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkflowPager(opts)
	if err != nil {
		return nil, err
	}

	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}

	conn := &WorkflowConnection{Edges: []*WorkflowEdge{}}
	if !hasCollectedField(ctx, edgesField) || first != nil && *first == 0 || last != nil && *last == 0 {
		if hasCollectedField(ctx, totalCountField) ||
			hasCollectedField(ctx, pageInfoField) {
			count, err := w.Count(ctx)
			if err != nil {
				return nil, err
			}
			conn.TotalCount = count
			conn.PageInfo.HasNextPage = first != nil && count > 0
			conn.PageInfo.HasPreviousPage = last != nil && count > 0
		}
		return conn, nil
	}

	if (after != nil || first != nil || before != nil || last != nil) && hasCollectedField(ctx, totalCountField) {
		count, err := w.Clone().Count(ctx)
		if err != nil {
			return nil, err
		}
		conn.TotalCount = count
	}

	w = pager.applyCursors(w, after, before)
	w = pager.applyOrder(w, last != nil)
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	if limit > 0 {
		w = w.Limit(limit)
	}

	if field := getCollectedField(ctx, edgesField, nodeField); field != nil {
		w = w.collectField(graphql.GetOperationContext(ctx), *field)
	}

	nodes, err := w.All(ctx)
	if err != nil || len(nodes) == 0 {
		return conn, err
	}

	if len(nodes) == limit {
		conn.PageInfo.HasNextPage = first != nil
		conn.PageInfo.HasPreviousPage = last != nil
		nodes = nodes[:len(nodes)-1]
	}

	var nodeAt func(int) *Workflow
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Workflow {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Workflow {
			return nodes[i]
		}
	}

	conn.Edges = make([]*WorkflowEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		conn.Edges[i] = &WorkflowEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}

	conn.PageInfo.StartCursor = &conn.Edges[0].Cursor
	conn.PageInfo.EndCursor = &conn.Edges[len(conn.Edges)-1].Cursor
	if conn.TotalCount == 0 {
		conn.TotalCount = len(nodes)
	}

	return conn, nil
}

// WorkflowOrderField defines the ordering field of Workflow.
type WorkflowOrderField struct {
	field    string
	toCursor func(*Workflow) Cursor
}

// WorkflowOrder defines the ordering of Workflow.
type WorkflowOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *WorkflowOrderField `json:"field"`
}

// DefaultWorkflowOrder is the default ordering of Workflow.
var DefaultWorkflowOrder = &WorkflowOrder{
	Direction: OrderDirectionAsc,
	Field: &WorkflowOrderField{
		field: workflow.FieldID,
		toCursor: func(w *Workflow) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Workflow into WorkflowEdge.
func (w *Workflow) ToEdge(order *WorkflowOrder) *WorkflowEdge {
	if order == nil {
		order = DefaultWorkflowOrder
	}
	return &WorkflowEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}
