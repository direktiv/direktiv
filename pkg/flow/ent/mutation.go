// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/direktiv/direktiv/pkg/flow/ent/cloudeventfilters"
	"github.com/direktiv/direktiv/pkg/flow/ent/cloudevents"
	"github.com/direktiv/direktiv/pkg/flow/ent/events"
	"github.com/direktiv/direktiv/pkg/flow/ent/eventswait"
	"github.com/direktiv/direktiv/pkg/flow/ent/inode"
	"github.com/direktiv/direktiv/pkg/flow/ent/instance"
	"github.com/direktiv/direktiv/pkg/flow/ent/instanceruntime"
	"github.com/direktiv/direktiv/pkg/flow/ent/logmsg"
	"github.com/direktiv/direktiv/pkg/flow/ent/mirror"
	"github.com/direktiv/direktiv/pkg/flow/ent/mirroractivity"
	"github.com/direktiv/direktiv/pkg/flow/ent/namespace"
	"github.com/direktiv/direktiv/pkg/flow/ent/predicate"
	"github.com/direktiv/direktiv/pkg/flow/ent/ref"
	"github.com/direktiv/direktiv/pkg/flow/ent/revision"
	"github.com/direktiv/direktiv/pkg/flow/ent/route"
	"github.com/direktiv/direktiv/pkg/flow/ent/services"
	"github.com/direktiv/direktiv/pkg/flow/ent/vardata"
	"github.com/direktiv/direktiv/pkg/flow/ent/varref"
	"github.com/direktiv/direktiv/pkg/flow/ent/workflow"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCloudEventFilters = "CloudEventFilters"
	TypeCloudEvents       = "CloudEvents"
	TypeEvents            = "Events"
	TypeEventsWait        = "EventsWait"
	TypeInode             = "Inode"
	TypeInstance          = "Instance"
	TypeInstanceRuntime   = "InstanceRuntime"
	TypeLogMsg            = "LogMsg"
	TypeMirror            = "Mirror"
	TypeMirrorActivity    = "MirrorActivity"
	TypeNamespace         = "Namespace"
	TypeRef               = "Ref"
	TypeRevision          = "Revision"
	TypeRoute             = "Route"
	TypeServices          = "Services"
	TypeVarData           = "VarData"
	TypeVarRef            = "VarRef"
	TypeWorkflow          = "Workflow"
)

// CloudEventFiltersMutation represents an operation that mutates the CloudEventFilters nodes in the graph.
type CloudEventFiltersMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	jscode           *string
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	done             bool
	oldValue         func(context.Context) (*CloudEventFilters, error)
	predicates       []predicate.CloudEventFilters
}

var _ ent.Mutation = (*CloudEventFiltersMutation)(nil)

// cloudeventfiltersOption allows management of the mutation configuration using functional options.
type cloudeventfiltersOption func(*CloudEventFiltersMutation)

// newCloudEventFiltersMutation creates new mutation for the CloudEventFilters entity.
func newCloudEventFiltersMutation(c config, op Op, opts ...cloudeventfiltersOption) *CloudEventFiltersMutation {
	m := &CloudEventFiltersMutation{
		config:        c,
		op:            op,
		typ:           TypeCloudEventFilters,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCloudEventFiltersID sets the ID field of the mutation.
func withCloudEventFiltersID(id int) cloudeventfiltersOption {
	return func(m *CloudEventFiltersMutation) {
		var (
			err   error
			once  sync.Once
			value *CloudEventFilters
		)
		m.oldValue = func(ctx context.Context) (*CloudEventFilters, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CloudEventFilters.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCloudEventFilters sets the old CloudEventFilters of the mutation.
func withCloudEventFilters(node *CloudEventFilters) cloudeventfiltersOption {
	return func(m *CloudEventFiltersMutation) {
		m.oldValue = func(context.Context) (*CloudEventFilters, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CloudEventFiltersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CloudEventFiltersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CloudEventFiltersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CloudEventFiltersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CloudEventFilters.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CloudEventFiltersMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CloudEventFiltersMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CloudEventFilters entity.
// If the CloudEventFilters object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventFiltersMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CloudEventFiltersMutation) ResetName() {
	m.name = nil
}

// SetJscode sets the "jscode" field.
func (m *CloudEventFiltersMutation) SetJscode(s string) {
	m.jscode = &s
}

// Jscode returns the value of the "jscode" field in the mutation.
func (m *CloudEventFiltersMutation) Jscode() (r string, exists bool) {
	v := m.jscode
	if v == nil {
		return
	}
	return *v, true
}

// OldJscode returns the old "jscode" field's value of the CloudEventFilters entity.
// If the CloudEventFilters object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventFiltersMutation) OldJscode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJscode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJscode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJscode: %w", err)
	}
	return oldValue.Jscode, nil
}

// ResetJscode resets all changes to the "jscode" field.
func (m *CloudEventFiltersMutation) ResetJscode() {
	m.jscode = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *CloudEventFiltersMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *CloudEventFiltersMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *CloudEventFiltersMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *CloudEventFiltersMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *CloudEventFiltersMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *CloudEventFiltersMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the CloudEventFiltersMutation builder.
func (m *CloudEventFiltersMutation) Where(ps ...predicate.CloudEventFilters) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CloudEventFiltersMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CloudEventFilters).
func (m *CloudEventFiltersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CloudEventFiltersMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, cloudeventfilters.FieldName)
	}
	if m.jscode != nil {
		fields = append(fields, cloudeventfilters.FieldJscode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CloudEventFiltersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cloudeventfilters.FieldName:
		return m.Name()
	case cloudeventfilters.FieldJscode:
		return m.Jscode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CloudEventFiltersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cloudeventfilters.FieldName:
		return m.OldName(ctx)
	case cloudeventfilters.FieldJscode:
		return m.OldJscode(ctx)
	}
	return nil, fmt.Errorf("unknown CloudEventFilters field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventFiltersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cloudeventfilters.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cloudeventfilters.FieldJscode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJscode(v)
		return nil
	}
	return fmt.Errorf("unknown CloudEventFilters field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CloudEventFiltersMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CloudEventFiltersMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventFiltersMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CloudEventFilters numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CloudEventFiltersMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CloudEventFiltersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CloudEventFiltersMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CloudEventFilters nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CloudEventFiltersMutation) ResetField(name string) error {
	switch name {
	case cloudeventfilters.FieldName:
		m.ResetName()
		return nil
	case cloudeventfilters.FieldJscode:
		m.ResetJscode()
		return nil
	}
	return fmt.Errorf("unknown CloudEventFilters field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CloudEventFiltersMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespace != nil {
		edges = append(edges, cloudeventfilters.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CloudEventFiltersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cloudeventfilters.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CloudEventFiltersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CloudEventFiltersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CloudEventFiltersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespace {
		edges = append(edges, cloudeventfilters.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CloudEventFiltersMutation) EdgeCleared(name string) bool {
	switch name {
	case cloudeventfilters.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CloudEventFiltersMutation) ClearEdge(name string) error {
	switch name {
	case cloudeventfilters.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEventFilters unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CloudEventFiltersMutation) ResetEdge(name string) error {
	switch name {
	case cloudeventfilters.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEventFilters edge %s", name)
}

// CloudEventsMutation represents an operation that mutates the CloudEvents nodes in the graph.
type CloudEventsMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	eventId          *string
	event            *event.Event
	fire             *time.Time
	created          *time.Time
	processed        *bool
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	done             bool
	oldValue         func(context.Context) (*CloudEvents, error)
	predicates       []predicate.CloudEvents
}

var _ ent.Mutation = (*CloudEventsMutation)(nil)

// cloudeventsOption allows management of the mutation configuration using functional options.
type cloudeventsOption func(*CloudEventsMutation)

// newCloudEventsMutation creates new mutation for the CloudEvents entity.
func newCloudEventsMutation(c config, op Op, opts ...cloudeventsOption) *CloudEventsMutation {
	m := &CloudEventsMutation{
		config:        c,
		op:            op,
		typ:           TypeCloudEvents,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCloudEventsID sets the ID field of the mutation.
func withCloudEventsID(id uuid.UUID) cloudeventsOption {
	return func(m *CloudEventsMutation) {
		var (
			err   error
			once  sync.Once
			value *CloudEvents
		)
		m.oldValue = func(ctx context.Context) (*CloudEvents, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CloudEvents.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCloudEvents sets the old CloudEvents of the mutation.
func withCloudEvents(node *CloudEvents) cloudeventsOption {
	return func(m *CloudEventsMutation) {
		m.oldValue = func(context.Context) (*CloudEvents, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CloudEventsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CloudEventsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CloudEvents entities.
func (m *CloudEventsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CloudEventsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CloudEventsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CloudEvents.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventId sets the "eventId" field.
func (m *CloudEventsMutation) SetEventId(s string) {
	m.eventId = &s
}

// EventId returns the value of the "eventId" field in the mutation.
func (m *CloudEventsMutation) EventId() (r string, exists bool) {
	v := m.eventId
	if v == nil {
		return
	}
	return *v, true
}

// OldEventId returns the old "eventId" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldEventId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventId: %w", err)
	}
	return oldValue.EventId, nil
}

// ResetEventId resets all changes to the "eventId" field.
func (m *CloudEventsMutation) ResetEventId() {
	m.eventId = nil
}

// SetEvent sets the "event" field.
func (m *CloudEventsMutation) SetEvent(e event.Event) {
	m.event = &e
}

// Event returns the value of the "event" field in the mutation.
func (m *CloudEventsMutation) Event() (r event.Event, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEvent returns the old "event" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldEvent(ctx context.Context) (v event.Event, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvent: %w", err)
	}
	return oldValue.Event, nil
}

// ResetEvent resets all changes to the "event" field.
func (m *CloudEventsMutation) ResetEvent() {
	m.event = nil
}

// SetFire sets the "fire" field.
func (m *CloudEventsMutation) SetFire(t time.Time) {
	m.fire = &t
}

// Fire returns the value of the "fire" field in the mutation.
func (m *CloudEventsMutation) Fire() (r time.Time, exists bool) {
	v := m.fire
	if v == nil {
		return
	}
	return *v, true
}

// OldFire returns the old "fire" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldFire(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFire is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFire requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFire: %w", err)
	}
	return oldValue.Fire, nil
}

// ResetFire resets all changes to the "fire" field.
func (m *CloudEventsMutation) ResetFire() {
	m.fire = nil
}

// SetCreated sets the "created" field.
func (m *CloudEventsMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *CloudEventsMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *CloudEventsMutation) ResetCreated() {
	m.created = nil
}

// SetProcessed sets the "processed" field.
func (m *CloudEventsMutation) SetProcessed(b bool) {
	m.processed = &b
}

// Processed returns the value of the "processed" field in the mutation.
func (m *CloudEventsMutation) Processed() (r bool, exists bool) {
	v := m.processed
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessed returns the old "processed" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldProcessed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessed: %w", err)
	}
	return oldValue.Processed, nil
}

// ResetProcessed resets all changes to the "processed" field.
func (m *CloudEventsMutation) ResetProcessed() {
	m.processed = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *CloudEventsMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *CloudEventsMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *CloudEventsMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *CloudEventsMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *CloudEventsMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *CloudEventsMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the CloudEventsMutation builder.
func (m *CloudEventsMutation) Where(ps ...predicate.CloudEvents) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CloudEventsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CloudEvents).
func (m *CloudEventsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CloudEventsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.eventId != nil {
		fields = append(fields, cloudevents.FieldEventId)
	}
	if m.event != nil {
		fields = append(fields, cloudevents.FieldEvent)
	}
	if m.fire != nil {
		fields = append(fields, cloudevents.FieldFire)
	}
	if m.created != nil {
		fields = append(fields, cloudevents.FieldCreated)
	}
	if m.processed != nil {
		fields = append(fields, cloudevents.FieldProcessed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CloudEventsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cloudevents.FieldEventId:
		return m.EventId()
	case cloudevents.FieldEvent:
		return m.Event()
	case cloudevents.FieldFire:
		return m.Fire()
	case cloudevents.FieldCreated:
		return m.Created()
	case cloudevents.FieldProcessed:
		return m.Processed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CloudEventsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cloudevents.FieldEventId:
		return m.OldEventId(ctx)
	case cloudevents.FieldEvent:
		return m.OldEvent(ctx)
	case cloudevents.FieldFire:
		return m.OldFire(ctx)
	case cloudevents.FieldCreated:
		return m.OldCreated(ctx)
	case cloudevents.FieldProcessed:
		return m.OldProcessed(ctx)
	}
	return nil, fmt.Errorf("unknown CloudEvents field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cloudevents.FieldEventId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventId(v)
		return nil
	case cloudevents.FieldEvent:
		v, ok := value.(event.Event)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvent(v)
		return nil
	case cloudevents.FieldFire:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFire(v)
		return nil
	case cloudevents.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case cloudevents.FieldProcessed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessed(v)
		return nil
	}
	return fmt.Errorf("unknown CloudEvents field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CloudEventsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CloudEventsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CloudEvents numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CloudEventsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CloudEventsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CloudEventsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CloudEvents nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CloudEventsMutation) ResetField(name string) error {
	switch name {
	case cloudevents.FieldEventId:
		m.ResetEventId()
		return nil
	case cloudevents.FieldEvent:
		m.ResetEvent()
		return nil
	case cloudevents.FieldFire:
		m.ResetFire()
		return nil
	case cloudevents.FieldCreated:
		m.ResetCreated()
		return nil
	case cloudevents.FieldProcessed:
		m.ResetProcessed()
		return nil
	}
	return fmt.Errorf("unknown CloudEvents field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CloudEventsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespace != nil {
		edges = append(edges, cloudevents.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CloudEventsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cloudevents.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CloudEventsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CloudEventsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CloudEventsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespace {
		edges = append(edges, cloudevents.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CloudEventsMutation) EdgeCleared(name string) bool {
	switch name {
	case cloudevents.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CloudEventsMutation) ClearEdge(name string) error {
	switch name {
	case cloudevents.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEvents unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CloudEventsMutation) ResetEdge(name string) error {
	switch name {
	case cloudevents.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEvents edge %s", name)
}

// EventsMutation represents an operation that mutates the Events nodes in the graph.
type EventsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	events              *[]map[string]interface{}
	appendevents        []map[string]interface{}
	correlations        *[]string
	appendcorrelations  []string
	signature           *[]byte
	count               *int
	addcount            *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	workflow            *uuid.UUID
	clearedworkflow     bool
	wfeventswait        map[uuid.UUID]struct{}
	removedwfeventswait map[uuid.UUID]struct{}
	clearedwfeventswait bool
	instance            *uuid.UUID
	clearedinstance     bool
	namespace           *uuid.UUID
	clearednamespace    bool
	done                bool
	oldValue            func(context.Context) (*Events, error)
	predicates          []predicate.Events
}

var _ ent.Mutation = (*EventsMutation)(nil)

// eventsOption allows management of the mutation configuration using functional options.
type eventsOption func(*EventsMutation)

// newEventsMutation creates new mutation for the Events entity.
func newEventsMutation(c config, op Op, opts ...eventsOption) *EventsMutation {
	m := &EventsMutation{
		config:        c,
		op:            op,
		typ:           TypeEvents,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventsID sets the ID field of the mutation.
func withEventsID(id uuid.UUID) eventsOption {
	return func(m *EventsMutation) {
		var (
			err   error
			once  sync.Once
			value *Events
		)
		m.oldValue = func(ctx context.Context) (*Events, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Events.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvents sets the old Events of the mutation.
func withEvents(node *Events) eventsOption {
	return func(m *EventsMutation) {
		m.oldValue = func(context.Context) (*Events, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Events entities.
func (m *EventsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Events.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEvents sets the "events" field.
func (m *EventsMutation) SetEvents(value []map[string]interface{}) {
	m.events = &value
	m.appendevents = nil
}

// Events returns the value of the "events" field in the mutation.
func (m *EventsMutation) Events() (r []map[string]interface{}, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldEvents(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// AppendEvents adds value to the "events" field.
func (m *EventsMutation) AppendEvents(value []map[string]interface{}) {
	m.appendevents = append(m.appendevents, value...)
}

// AppendedEvents returns the list of values that were appended to the "events" field in this mutation.
func (m *EventsMutation) AppendedEvents() ([]map[string]interface{}, bool) {
	if len(m.appendevents) == 0 {
		return nil, false
	}
	return m.appendevents, true
}

// ResetEvents resets all changes to the "events" field.
func (m *EventsMutation) ResetEvents() {
	m.events = nil
	m.appendevents = nil
}

// SetCorrelations sets the "correlations" field.
func (m *EventsMutation) SetCorrelations(s []string) {
	m.correlations = &s
	m.appendcorrelations = nil
}

// Correlations returns the value of the "correlations" field in the mutation.
func (m *EventsMutation) Correlations() (r []string, exists bool) {
	v := m.correlations
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelations returns the old "correlations" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldCorrelations(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelations: %w", err)
	}
	return oldValue.Correlations, nil
}

// AppendCorrelations adds s to the "correlations" field.
func (m *EventsMutation) AppendCorrelations(s []string) {
	m.appendcorrelations = append(m.appendcorrelations, s...)
}

// AppendedCorrelations returns the list of values that were appended to the "correlations" field in this mutation.
func (m *EventsMutation) AppendedCorrelations() ([]string, bool) {
	if len(m.appendcorrelations) == 0 {
		return nil, false
	}
	return m.appendcorrelations, true
}

// ResetCorrelations resets all changes to the "correlations" field.
func (m *EventsMutation) ResetCorrelations() {
	m.correlations = nil
	m.appendcorrelations = nil
}

// SetSignature sets the "signature" field.
func (m *EventsMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *EventsMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *EventsMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[events.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *EventsMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[events.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *EventsMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, events.FieldSignature)
}

// SetCount sets the "count" field.
func (m *EventsMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *EventsMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *EventsMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *EventsMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *EventsMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *EventsMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *EventsMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *EventsMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *EventsMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *EventsMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *EventsMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddWfeventswaitIDs adds the "wfeventswait" edge to the EventsWait entity by ids.
func (m *EventsMutation) AddWfeventswaitIDs(ids ...uuid.UUID) {
	if m.wfeventswait == nil {
		m.wfeventswait = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.wfeventswait[ids[i]] = struct{}{}
	}
}

// ClearWfeventswait clears the "wfeventswait" edge to the EventsWait entity.
func (m *EventsMutation) ClearWfeventswait() {
	m.clearedwfeventswait = true
}

// WfeventswaitCleared reports if the "wfeventswait" edge to the EventsWait entity was cleared.
func (m *EventsMutation) WfeventswaitCleared() bool {
	return m.clearedwfeventswait
}

// RemoveWfeventswaitIDs removes the "wfeventswait" edge to the EventsWait entity by IDs.
func (m *EventsMutation) RemoveWfeventswaitIDs(ids ...uuid.UUID) {
	if m.removedwfeventswait == nil {
		m.removedwfeventswait = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.wfeventswait, ids[i])
		m.removedwfeventswait[ids[i]] = struct{}{}
	}
}

// RemovedWfeventswait returns the removed IDs of the "wfeventswait" edge to the EventsWait entity.
func (m *EventsMutation) RemovedWfeventswaitIDs() (ids []uuid.UUID) {
	for id := range m.removedwfeventswait {
		ids = append(ids, id)
	}
	return
}

// WfeventswaitIDs returns the "wfeventswait" edge IDs in the mutation.
func (m *EventsMutation) WfeventswaitIDs() (ids []uuid.UUID) {
	for id := range m.wfeventswait {
		ids = append(ids, id)
	}
	return
}

// ResetWfeventswait resets all changes to the "wfeventswait" edge.
func (m *EventsMutation) ResetWfeventswait() {
	m.wfeventswait = nil
	m.clearedwfeventswait = false
	m.removedwfeventswait = nil
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *EventsMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *EventsMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *EventsMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *EventsMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *EventsMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *EventsMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *EventsMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *EventsMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *EventsMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *EventsMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *EventsMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *EventsMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the EventsMutation builder.
func (m *EventsMutation) Where(ps ...predicate.Events) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Events).
func (m *EventsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.events != nil {
		fields = append(fields, events.FieldEvents)
	}
	if m.correlations != nil {
		fields = append(fields, events.FieldCorrelations)
	}
	if m.signature != nil {
		fields = append(fields, events.FieldSignature)
	}
	if m.count != nil {
		fields = append(fields, events.FieldCount)
	}
	if m.created_at != nil {
		fields = append(fields, events.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, events.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case events.FieldEvents:
		return m.Events()
	case events.FieldCorrelations:
		return m.Correlations()
	case events.FieldSignature:
		return m.Signature()
	case events.FieldCount:
		return m.Count()
	case events.FieldCreatedAt:
		return m.CreatedAt()
	case events.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case events.FieldEvents:
		return m.OldEvents(ctx)
	case events.FieldCorrelations:
		return m.OldCorrelations(ctx)
	case events.FieldSignature:
		return m.OldSignature(ctx)
	case events.FieldCount:
		return m.OldCount(ctx)
	case events.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case events.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Events field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case events.FieldEvents:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	case events.FieldCorrelations:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelations(v)
		return nil
	case events.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case events.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case events.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case events.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Events field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventsMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, events.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case events.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case events.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown Events numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(events.FieldSignature) {
		fields = append(fields, events.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventsMutation) ClearField(name string) error {
	switch name {
	case events.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown Events nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventsMutation) ResetField(name string) error {
	switch name {
	case events.FieldEvents:
		m.ResetEvents()
		return nil
	case events.FieldCorrelations:
		m.ResetCorrelations()
		return nil
	case events.FieldSignature:
		m.ResetSignature()
		return nil
	case events.FieldCount:
		m.ResetCount()
		return nil
	case events.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case events.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Events field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.workflow != nil {
		edges = append(edges, events.EdgeWorkflow)
	}
	if m.wfeventswait != nil {
		edges = append(edges, events.EdgeWfeventswait)
	}
	if m.instance != nil {
		edges = append(edges, events.EdgeInstance)
	}
	if m.namespace != nil {
		edges = append(edges, events.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case events.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case events.EdgeWfeventswait:
		ids := make([]ent.Value, 0, len(m.wfeventswait))
		for id := range m.wfeventswait {
			ids = append(ids, id)
		}
		return ids
	case events.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	case events.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedwfeventswait != nil {
		edges = append(edges, events.EdgeWfeventswait)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case events.EdgeWfeventswait:
		ids := make([]ent.Value, 0, len(m.removedwfeventswait))
		for id := range m.removedwfeventswait {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedworkflow {
		edges = append(edges, events.EdgeWorkflow)
	}
	if m.clearedwfeventswait {
		edges = append(edges, events.EdgeWfeventswait)
	}
	if m.clearedinstance {
		edges = append(edges, events.EdgeInstance)
	}
	if m.clearednamespace {
		edges = append(edges, events.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventsMutation) EdgeCleared(name string) bool {
	switch name {
	case events.EdgeWorkflow:
		return m.clearedworkflow
	case events.EdgeWfeventswait:
		return m.clearedwfeventswait
	case events.EdgeInstance:
		return m.clearedinstance
	case events.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventsMutation) ClearEdge(name string) error {
	switch name {
	case events.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case events.EdgeInstance:
		m.ClearInstance()
		return nil
	case events.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Events unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventsMutation) ResetEdge(name string) error {
	switch name {
	case events.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case events.EdgeWfeventswait:
		m.ResetWfeventswait()
		return nil
	case events.EdgeInstance:
		m.ResetInstance()
		return nil
	case events.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown Events edge %s", name)
}

// EventsWaitMutation represents an operation that mutates the EventsWait nodes in the graph.
type EventsWaitMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	events               *map[string]interface{}
	clearedFields        map[string]struct{}
	workflowevent        *uuid.UUID
	clearedworkflowevent bool
	done                 bool
	oldValue             func(context.Context) (*EventsWait, error)
	predicates           []predicate.EventsWait
}

var _ ent.Mutation = (*EventsWaitMutation)(nil)

// eventswaitOption allows management of the mutation configuration using functional options.
type eventswaitOption func(*EventsWaitMutation)

// newEventsWaitMutation creates new mutation for the EventsWait entity.
func newEventsWaitMutation(c config, op Op, opts ...eventswaitOption) *EventsWaitMutation {
	m := &EventsWaitMutation{
		config:        c,
		op:            op,
		typ:           TypeEventsWait,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventsWaitID sets the ID field of the mutation.
func withEventsWaitID(id uuid.UUID) eventswaitOption {
	return func(m *EventsWaitMutation) {
		var (
			err   error
			once  sync.Once
			value *EventsWait
		)
		m.oldValue = func(ctx context.Context) (*EventsWait, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventsWait.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventsWait sets the old EventsWait of the mutation.
func withEventsWait(node *EventsWait) eventswaitOption {
	return func(m *EventsWaitMutation) {
		m.oldValue = func(context.Context) (*EventsWait, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventsWaitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventsWaitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventsWait entities.
func (m *EventsWaitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventsWaitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventsWaitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventsWait.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEvents sets the "events" field.
func (m *EventsWaitMutation) SetEvents(value map[string]interface{}) {
	m.events = &value
}

// Events returns the value of the "events" field in the mutation.
func (m *EventsWaitMutation) Events() (r map[string]interface{}, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the EventsWait entity.
// If the EventsWait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsWaitMutation) OldEvents(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// ResetEvents resets all changes to the "events" field.
func (m *EventsWaitMutation) ResetEvents() {
	m.events = nil
}

// SetWorkfloweventID sets the "workflowevent" edge to the Events entity by id.
func (m *EventsWaitMutation) SetWorkfloweventID(id uuid.UUID) {
	m.workflowevent = &id
}

// ClearWorkflowevent clears the "workflowevent" edge to the Events entity.
func (m *EventsWaitMutation) ClearWorkflowevent() {
	m.clearedworkflowevent = true
}

// WorkfloweventCleared reports if the "workflowevent" edge to the Events entity was cleared.
func (m *EventsWaitMutation) WorkfloweventCleared() bool {
	return m.clearedworkflowevent
}

// WorkfloweventID returns the "workflowevent" edge ID in the mutation.
func (m *EventsWaitMutation) WorkfloweventID() (id uuid.UUID, exists bool) {
	if m.workflowevent != nil {
		return *m.workflowevent, true
	}
	return
}

// WorkfloweventIDs returns the "workflowevent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkfloweventID instead. It exists only for internal usage by the builders.
func (m *EventsWaitMutation) WorkfloweventIDs() (ids []uuid.UUID) {
	if id := m.workflowevent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowevent resets all changes to the "workflowevent" edge.
func (m *EventsWaitMutation) ResetWorkflowevent() {
	m.workflowevent = nil
	m.clearedworkflowevent = false
}

// Where appends a list predicates to the EventsWaitMutation builder.
func (m *EventsWaitMutation) Where(ps ...predicate.EventsWait) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventsWaitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EventsWait).
func (m *EventsWaitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventsWaitMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.events != nil {
		fields = append(fields, eventswait.FieldEvents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventsWaitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventswait.FieldEvents:
		return m.Events()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventsWaitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventswait.FieldEvents:
		return m.OldEvents(ctx)
	}
	return nil, fmt.Errorf("unknown EventsWait field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsWaitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventswait.FieldEvents:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	}
	return fmt.Errorf("unknown EventsWait field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventsWaitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventsWaitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsWaitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventsWait numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventsWaitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventsWaitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventsWaitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventsWait nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventsWaitMutation) ResetField(name string) error {
	switch name {
	case eventswait.FieldEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown EventsWait field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventsWaitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflowevent != nil {
		edges = append(edges, eventswait.EdgeWorkflowevent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventsWaitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventswait.EdgeWorkflowevent:
		if id := m.workflowevent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventsWaitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventsWaitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventsWaitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflowevent {
		edges = append(edges, eventswait.EdgeWorkflowevent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventsWaitMutation) EdgeCleared(name string) bool {
	switch name {
	case eventswait.EdgeWorkflowevent:
		return m.clearedworkflowevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventsWaitMutation) ClearEdge(name string) error {
	switch name {
	case eventswait.EdgeWorkflowevent:
		m.ClearWorkflowevent()
		return nil
	}
	return fmt.Errorf("unknown EventsWait unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventsWaitMutation) ResetEdge(name string) error {
	switch name {
	case eventswait.EdgeWorkflowevent:
		m.ResetWorkflowevent()
		return nil
	}
	return fmt.Errorf("unknown EventsWait edge %s", name)
}

// InodeMutation represents an operation that mutates the Inode nodes in the graph.
type InodeMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	_type            *string
	attributes       *[]string
	appendattributes []string
	extended_type    *string
	readOnly         *bool
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	children         map[uuid.UUID]struct{}
	removedchildren  map[uuid.UUID]struct{}
	clearedchildren  bool
	parent           *uuid.UUID
	clearedparent    bool
	workflow         *uuid.UUID
	clearedworkflow  bool
	mirror           *uuid.UUID
	clearedmirror    bool
	done             bool
	oldValue         func(context.Context) (*Inode, error)
	predicates       []predicate.Inode
}

var _ ent.Mutation = (*InodeMutation)(nil)

// inodeOption allows management of the mutation configuration using functional options.
type inodeOption func(*InodeMutation)

// newInodeMutation creates new mutation for the Inode entity.
func newInodeMutation(c config, op Op, opts ...inodeOption) *InodeMutation {
	m := &InodeMutation{
		config:        c,
		op:            op,
		typ:           TypeInode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInodeID sets the ID field of the mutation.
func withInodeID(id uuid.UUID) inodeOption {
	return func(m *InodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Inode
		)
		m.oldValue = func(ctx context.Context) (*Inode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInode sets the old Inode of the mutation.
func withInode(node *Inode) inodeOption {
	return func(m *InodeMutation) {
		m.oldValue = func(context.Context) (*Inode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Inode entities.
func (m *InodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *InodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *InodeMutation) ClearName() {
	m.name = nil
	m.clearedFields[inode.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *InodeMutation) NameCleared() bool {
	_, ok := m.clearedFields[inode.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *InodeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, inode.FieldName)
}

// SetType sets the "type" field.
func (m *InodeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *InodeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InodeMutation) ResetType() {
	m._type = nil
}

// SetAttributes sets the "attributes" field.
func (m *InodeMutation) SetAttributes(s []string) {
	m.attributes = &s
	m.appendattributes = nil
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *InodeMutation) Attributes() (r []string, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldAttributes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// AppendAttributes adds s to the "attributes" field.
func (m *InodeMutation) AppendAttributes(s []string) {
	m.appendattributes = append(m.appendattributes, s...)
}

// AppendedAttributes returns the list of values that were appended to the "attributes" field in this mutation.
func (m *InodeMutation) AppendedAttributes() ([]string, bool) {
	if len(m.appendattributes) == 0 {
		return nil, false
	}
	return m.appendattributes, true
}

// ClearAttributes clears the value of the "attributes" field.
func (m *InodeMutation) ClearAttributes() {
	m.attributes = nil
	m.appendattributes = nil
	m.clearedFields[inode.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *InodeMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[inode.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *InodeMutation) ResetAttributes() {
	m.attributes = nil
	m.appendattributes = nil
	delete(m.clearedFields, inode.FieldAttributes)
}

// SetExtendedType sets the "extended_type" field.
func (m *InodeMutation) SetExtendedType(s string) {
	m.extended_type = &s
}

// ExtendedType returns the value of the "extended_type" field in the mutation.
func (m *InodeMutation) ExtendedType() (r string, exists bool) {
	v := m.extended_type
	if v == nil {
		return
	}
	return *v, true
}

// OldExtendedType returns the old "extended_type" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldExtendedType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtendedType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtendedType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtendedType: %w", err)
	}
	return oldValue.ExtendedType, nil
}

// ClearExtendedType clears the value of the "extended_type" field.
func (m *InodeMutation) ClearExtendedType() {
	m.extended_type = nil
	m.clearedFields[inode.FieldExtendedType] = struct{}{}
}

// ExtendedTypeCleared returns if the "extended_type" field was cleared in this mutation.
func (m *InodeMutation) ExtendedTypeCleared() bool {
	_, ok := m.clearedFields[inode.FieldExtendedType]
	return ok
}

// ResetExtendedType resets all changes to the "extended_type" field.
func (m *InodeMutation) ResetExtendedType() {
	m.extended_type = nil
	delete(m.clearedFields, inode.FieldExtendedType)
}

// SetReadOnly sets the "readOnly" field.
func (m *InodeMutation) SetReadOnly(b bool) {
	m.readOnly = &b
}

// ReadOnly returns the value of the "readOnly" field in the mutation.
func (m *InodeMutation) ReadOnly() (r bool, exists bool) {
	v := m.readOnly
	if v == nil {
		return
	}
	return *v, true
}

// OldReadOnly returns the old "readOnly" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldReadOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadOnly: %w", err)
	}
	return oldValue.ReadOnly, nil
}

// ClearReadOnly clears the value of the "readOnly" field.
func (m *InodeMutation) ClearReadOnly() {
	m.readOnly = nil
	m.clearedFields[inode.FieldReadOnly] = struct{}{}
}

// ReadOnlyCleared returns if the "readOnly" field was cleared in this mutation.
func (m *InodeMutation) ReadOnlyCleared() bool {
	_, ok := m.clearedFields[inode.FieldReadOnly]
	return ok
}

// ResetReadOnly resets all changes to the "readOnly" field.
func (m *InodeMutation) ResetReadOnly() {
	m.readOnly = nil
	delete(m.clearedFields, inode.FieldReadOnly)
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *InodeMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *InodeMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *InodeMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *InodeMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *InodeMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *InodeMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddChildIDs adds the "children" edge to the Inode entity by ids.
func (m *InodeMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Inode entity.
func (m *InodeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Inode entity was cleared.
func (m *InodeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Inode entity by IDs.
func (m *InodeMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Inode entity.
func (m *InodeMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *InodeMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *InodeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentID sets the "parent" edge to the Inode entity by id.
func (m *InodeMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Inode entity.
func (m *InodeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Inode entity was cleared.
func (m *InodeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *InodeMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *InodeMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *InodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *InodeMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *InodeMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *InodeMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *InodeMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *InodeMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *InodeMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetMirrorID sets the "mirror" edge to the Mirror entity by id.
func (m *InodeMutation) SetMirrorID(id uuid.UUID) {
	m.mirror = &id
}

// ClearMirror clears the "mirror" edge to the Mirror entity.
func (m *InodeMutation) ClearMirror() {
	m.clearedmirror = true
}

// MirrorCleared reports if the "mirror" edge to the Mirror entity was cleared.
func (m *InodeMutation) MirrorCleared() bool {
	return m.clearedmirror
}

// MirrorID returns the "mirror" edge ID in the mutation.
func (m *InodeMutation) MirrorID() (id uuid.UUID, exists bool) {
	if m.mirror != nil {
		return *m.mirror, true
	}
	return
}

// MirrorIDs returns the "mirror" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MirrorID instead. It exists only for internal usage by the builders.
func (m *InodeMutation) MirrorIDs() (ids []uuid.UUID) {
	if id := m.mirror; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMirror resets all changes to the "mirror" edge.
func (m *InodeMutation) ResetMirror() {
	m.mirror = nil
	m.clearedmirror = false
}

// Where appends a list predicates to the InodeMutation builder.
func (m *InodeMutation) Where(ps ...predicate.Inode) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Inode).
func (m *InodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InodeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, inode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inode.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, inode.FieldName)
	}
	if m._type != nil {
		fields = append(fields, inode.FieldType)
	}
	if m.attributes != nil {
		fields = append(fields, inode.FieldAttributes)
	}
	if m.extended_type != nil {
		fields = append(fields, inode.FieldExtendedType)
	}
	if m.readOnly != nil {
		fields = append(fields, inode.FieldReadOnly)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inode.FieldCreatedAt:
		return m.CreatedAt()
	case inode.FieldUpdatedAt:
		return m.UpdatedAt()
	case inode.FieldName:
		return m.Name()
	case inode.FieldType:
		return m.GetType()
	case inode.FieldAttributes:
		return m.Attributes()
	case inode.FieldExtendedType:
		return m.ExtendedType()
	case inode.FieldReadOnly:
		return m.ReadOnly()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inode.FieldName:
		return m.OldName(ctx)
	case inode.FieldType:
		return m.OldType(ctx)
	case inode.FieldAttributes:
		return m.OldAttributes(ctx)
	case inode.FieldExtendedType:
		return m.OldExtendedType(ctx)
	case inode.FieldReadOnly:
		return m.OldReadOnly(ctx)
	}
	return nil, fmt.Errorf("unknown Inode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inode.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inode.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case inode.FieldAttributes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	case inode.FieldExtendedType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtendedType(v)
		return nil
	case inode.FieldReadOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadOnly(v)
		return nil
	}
	return fmt.Errorf("unknown Inode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Inode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inode.FieldName) {
		fields = append(fields, inode.FieldName)
	}
	if m.FieldCleared(inode.FieldAttributes) {
		fields = append(fields, inode.FieldAttributes)
	}
	if m.FieldCleared(inode.FieldExtendedType) {
		fields = append(fields, inode.FieldExtendedType)
	}
	if m.FieldCleared(inode.FieldReadOnly) {
		fields = append(fields, inode.FieldReadOnly)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InodeMutation) ClearField(name string) error {
	switch name {
	case inode.FieldName:
		m.ClearName()
		return nil
	case inode.FieldAttributes:
		m.ClearAttributes()
		return nil
	case inode.FieldExtendedType:
		m.ClearExtendedType()
		return nil
	case inode.FieldReadOnly:
		m.ClearReadOnly()
		return nil
	}
	return fmt.Errorf("unknown Inode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InodeMutation) ResetField(name string) error {
	switch name {
	case inode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inode.FieldName:
		m.ResetName()
		return nil
	case inode.FieldType:
		m.ResetType()
		return nil
	case inode.FieldAttributes:
		m.ResetAttributes()
		return nil
	case inode.FieldExtendedType:
		m.ResetExtendedType()
		return nil
	case inode.FieldReadOnly:
		m.ResetReadOnly()
		return nil
	}
	return fmt.Errorf("unknown Inode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.namespace != nil {
		edges = append(edges, inode.EdgeNamespace)
	}
	if m.children != nil {
		edges = append(edges, inode.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, inode.EdgeParent)
	}
	if m.workflow != nil {
		edges = append(edges, inode.EdgeWorkflow)
	}
	if m.mirror != nil {
		edges = append(edges, inode.EdgeMirror)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inode.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case inode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case inode.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case inode.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case inode.EdgeMirror:
		if id := m.mirror; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedchildren != nil {
		edges = append(edges, inode.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearednamespace {
		edges = append(edges, inode.EdgeNamespace)
	}
	if m.clearedchildren {
		edges = append(edges, inode.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, inode.EdgeParent)
	}
	if m.clearedworkflow {
		edges = append(edges, inode.EdgeWorkflow)
	}
	if m.clearedmirror {
		edges = append(edges, inode.EdgeMirror)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InodeMutation) EdgeCleared(name string) bool {
	switch name {
	case inode.EdgeNamespace:
		return m.clearednamespace
	case inode.EdgeChildren:
		return m.clearedchildren
	case inode.EdgeParent:
		return m.clearedparent
	case inode.EdgeWorkflow:
		return m.clearedworkflow
	case inode.EdgeMirror:
		return m.clearedmirror
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InodeMutation) ClearEdge(name string) error {
	switch name {
	case inode.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case inode.EdgeParent:
		m.ClearParent()
		return nil
	case inode.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case inode.EdgeMirror:
		m.ClearMirror()
		return nil
	}
	return fmt.Errorf("unknown Inode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InodeMutation) ResetEdge(name string) error {
	switch name {
	case inode.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case inode.EdgeChildren:
		m.ResetChildren()
		return nil
	case inode.EdgeParent:
		m.ResetParent()
		return nil
	case inode.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case inode.EdgeMirror:
		m.ResetMirror()
		return nil
	}
	return fmt.Errorf("unknown Inode edge %s", name)
}

// InstanceMutation represents an operation that mutates the Instance nodes in the graph.
type InstanceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	end_at                *time.Time
	status                *string
	as                    *string
	errorCode             *string
	errorMessage          *string
	invoker               *string
	clearedFields         map[string]struct{}
	namespace             *uuid.UUID
	clearednamespace      bool
	workflow              *uuid.UUID
	clearedworkflow       bool
	revision              *uuid.UUID
	clearedrevision       bool
	logs                  map[uuid.UUID]struct{}
	removedlogs           map[uuid.UUID]struct{}
	clearedlogs           bool
	vars                  map[uuid.UUID]struct{}
	removedvars           map[uuid.UUID]struct{}
	clearedvars           bool
	runtime               *uuid.UUID
	clearedruntime        bool
	children              map[uuid.UUID]struct{}
	removedchildren       map[uuid.UUID]struct{}
	clearedchildren       bool
	eventlisteners        map[uuid.UUID]struct{}
	removedeventlisteners map[uuid.UUID]struct{}
	clearedeventlisteners bool
	done                  bool
	oldValue              func(context.Context) (*Instance, error)
	predicates            []predicate.Instance
}

var _ ent.Mutation = (*InstanceMutation)(nil)

// instanceOption allows management of the mutation configuration using functional options.
type instanceOption func(*InstanceMutation)

// newInstanceMutation creates new mutation for the Instance entity.
func newInstanceMutation(c config, op Op, opts ...instanceOption) *InstanceMutation {
	m := &InstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceID sets the ID field of the mutation.
func withInstanceID(id uuid.UUID) instanceOption {
	return func(m *InstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Instance
		)
		m.oldValue = func(ctx context.Context) (*Instance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Instance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstance sets the old Instance of the mutation.
func withInstance(node *Instance) instanceOption {
	return func(m *InstanceMutation) {
		m.oldValue = func(context.Context) (*Instance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Instance entities.
func (m *InstanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Instance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *InstanceMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *InstanceMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *InstanceMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[instance.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *InstanceMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[instance.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *InstanceMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, instance.FieldEndAt)
}

// SetStatus sets the "status" field.
func (m *InstanceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *InstanceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InstanceMutation) ResetStatus() {
	m.status = nil
}

// SetAs sets the "as" field.
func (m *InstanceMutation) SetAs(s string) {
	m.as = &s
}

// As returns the value of the "as" field in the mutation.
func (m *InstanceMutation) As() (r string, exists bool) {
	v := m.as
	if v == nil {
		return
	}
	return *v, true
}

// OldAs returns the old "as" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldAs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAs: %w", err)
	}
	return oldValue.As, nil
}

// ResetAs resets all changes to the "as" field.
func (m *InstanceMutation) ResetAs() {
	m.as = nil
}

// SetErrorCode sets the "errorCode" field.
func (m *InstanceMutation) SetErrorCode(s string) {
	m.errorCode = &s
}

// ErrorCode returns the value of the "errorCode" field in the mutation.
func (m *InstanceMutation) ErrorCode() (r string, exists bool) {
	v := m.errorCode
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "errorCode" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// ClearErrorCode clears the value of the "errorCode" field.
func (m *InstanceMutation) ClearErrorCode() {
	m.errorCode = nil
	m.clearedFields[instance.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "errorCode" field was cleared in this mutation.
func (m *InstanceMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[instance.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "errorCode" field.
func (m *InstanceMutation) ResetErrorCode() {
	m.errorCode = nil
	delete(m.clearedFields, instance.FieldErrorCode)
}

// SetErrorMessage sets the "errorMessage" field.
func (m *InstanceMutation) SetErrorMessage(s string) {
	m.errorMessage = &s
}

// ErrorMessage returns the value of the "errorMessage" field in the mutation.
func (m *InstanceMutation) ErrorMessage() (r string, exists bool) {
	v := m.errorMessage
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "errorMessage" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "errorMessage" field.
func (m *InstanceMutation) ClearErrorMessage() {
	m.errorMessage = nil
	m.clearedFields[instance.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "errorMessage" field was cleared in this mutation.
func (m *InstanceMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[instance.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "errorMessage" field.
func (m *InstanceMutation) ResetErrorMessage() {
	m.errorMessage = nil
	delete(m.clearedFields, instance.FieldErrorMessage)
}

// SetInvoker sets the "invoker" field.
func (m *InstanceMutation) SetInvoker(s string) {
	m.invoker = &s
}

// Invoker returns the value of the "invoker" field in the mutation.
func (m *InstanceMutation) Invoker() (r string, exists bool) {
	v := m.invoker
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoker returns the old "invoker" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldInvoker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoker: %w", err)
	}
	return oldValue.Invoker, nil
}

// ClearInvoker clears the value of the "invoker" field.
func (m *InstanceMutation) ClearInvoker() {
	m.invoker = nil
	m.clearedFields[instance.FieldInvoker] = struct{}{}
}

// InvokerCleared returns if the "invoker" field was cleared in this mutation.
func (m *InstanceMutation) InvokerCleared() bool {
	_, ok := m.clearedFields[instance.FieldInvoker]
	return ok
}

// ResetInvoker resets all changes to the "invoker" field.
func (m *InstanceMutation) ResetInvoker() {
	m.invoker = nil
	delete(m.clearedFields, instance.FieldInvoker)
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *InstanceMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *InstanceMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *InstanceMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *InstanceMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *InstanceMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *InstanceMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *InstanceMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *InstanceMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *InstanceMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *InstanceMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetRevisionID sets the "revision" edge to the Revision entity by id.
func (m *InstanceMutation) SetRevisionID(id uuid.UUID) {
	m.revision = &id
}

// ClearRevision clears the "revision" edge to the Revision entity.
func (m *InstanceMutation) ClearRevision() {
	m.clearedrevision = true
}

// RevisionCleared reports if the "revision" edge to the Revision entity was cleared.
func (m *InstanceMutation) RevisionCleared() bool {
	return m.clearedrevision
}

// RevisionID returns the "revision" edge ID in the mutation.
func (m *InstanceMutation) RevisionID() (id uuid.UUID, exists bool) {
	if m.revision != nil {
		return *m.revision, true
	}
	return
}

// RevisionIDs returns the "revision" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevisionID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) RevisionIDs() (ids []uuid.UUID) {
	if id := m.revision; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevision resets all changes to the "revision" edge.
func (m *InstanceMutation) ResetRevision() {
	m.revision = nil
	m.clearedrevision = false
}

// AddLogIDs adds the "logs" edge to the LogMsg entity by ids.
func (m *InstanceMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the LogMsg entity.
func (m *InstanceMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the LogMsg entity was cleared.
func (m *InstanceMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the LogMsg entity by IDs.
func (m *InstanceMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the LogMsg entity.
func (m *InstanceMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *InstanceMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *InstanceMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddVarIDs adds the "vars" edge to the VarRef entity by ids.
func (m *InstanceMutation) AddVarIDs(ids ...uuid.UUID) {
	if m.vars == nil {
		m.vars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vars[ids[i]] = struct{}{}
	}
}

// ClearVars clears the "vars" edge to the VarRef entity.
func (m *InstanceMutation) ClearVars() {
	m.clearedvars = true
}

// VarsCleared reports if the "vars" edge to the VarRef entity was cleared.
func (m *InstanceMutation) VarsCleared() bool {
	return m.clearedvars
}

// RemoveVarIDs removes the "vars" edge to the VarRef entity by IDs.
func (m *InstanceMutation) RemoveVarIDs(ids ...uuid.UUID) {
	if m.removedvars == nil {
		m.removedvars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vars, ids[i])
		m.removedvars[ids[i]] = struct{}{}
	}
}

// RemovedVars returns the removed IDs of the "vars" edge to the VarRef entity.
func (m *InstanceMutation) RemovedVarsIDs() (ids []uuid.UUID) {
	for id := range m.removedvars {
		ids = append(ids, id)
	}
	return
}

// VarsIDs returns the "vars" edge IDs in the mutation.
func (m *InstanceMutation) VarsIDs() (ids []uuid.UUID) {
	for id := range m.vars {
		ids = append(ids, id)
	}
	return
}

// ResetVars resets all changes to the "vars" edge.
func (m *InstanceMutation) ResetVars() {
	m.vars = nil
	m.clearedvars = false
	m.removedvars = nil
}

// SetRuntimeID sets the "runtime" edge to the InstanceRuntime entity by id.
func (m *InstanceMutation) SetRuntimeID(id uuid.UUID) {
	m.runtime = &id
}

// ClearRuntime clears the "runtime" edge to the InstanceRuntime entity.
func (m *InstanceMutation) ClearRuntime() {
	m.clearedruntime = true
}

// RuntimeCleared reports if the "runtime" edge to the InstanceRuntime entity was cleared.
func (m *InstanceMutation) RuntimeCleared() bool {
	return m.clearedruntime
}

// RuntimeID returns the "runtime" edge ID in the mutation.
func (m *InstanceMutation) RuntimeID() (id uuid.UUID, exists bool) {
	if m.runtime != nil {
		return *m.runtime, true
	}
	return
}

// RuntimeIDs returns the "runtime" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuntimeID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) RuntimeIDs() (ids []uuid.UUID) {
	if id := m.runtime; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRuntime resets all changes to the "runtime" edge.
func (m *InstanceMutation) ResetRuntime() {
	m.runtime = nil
	m.clearedruntime = false
}

// AddChildIDs adds the "children" edge to the InstanceRuntime entity by ids.
func (m *InstanceMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the InstanceRuntime entity.
func (m *InstanceMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the InstanceRuntime entity was cleared.
func (m *InstanceMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the InstanceRuntime entity by IDs.
func (m *InstanceMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the InstanceRuntime entity.
func (m *InstanceMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *InstanceMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *InstanceMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddEventlistenerIDs adds the "eventlisteners" edge to the Events entity by ids.
func (m *InstanceMutation) AddEventlistenerIDs(ids ...uuid.UUID) {
	if m.eventlisteners == nil {
		m.eventlisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.eventlisteners[ids[i]] = struct{}{}
	}
}

// ClearEventlisteners clears the "eventlisteners" edge to the Events entity.
func (m *InstanceMutation) ClearEventlisteners() {
	m.clearedeventlisteners = true
}

// EventlistenersCleared reports if the "eventlisteners" edge to the Events entity was cleared.
func (m *InstanceMutation) EventlistenersCleared() bool {
	return m.clearedeventlisteners
}

// RemoveEventlistenerIDs removes the "eventlisteners" edge to the Events entity by IDs.
func (m *InstanceMutation) RemoveEventlistenerIDs(ids ...uuid.UUID) {
	if m.removedeventlisteners == nil {
		m.removedeventlisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.eventlisteners, ids[i])
		m.removedeventlisteners[ids[i]] = struct{}{}
	}
}

// RemovedEventlisteners returns the removed IDs of the "eventlisteners" edge to the Events entity.
func (m *InstanceMutation) RemovedEventlistenersIDs() (ids []uuid.UUID) {
	for id := range m.removedeventlisteners {
		ids = append(ids, id)
	}
	return
}

// EventlistenersIDs returns the "eventlisteners" edge IDs in the mutation.
func (m *InstanceMutation) EventlistenersIDs() (ids []uuid.UUID) {
	for id := range m.eventlisteners {
		ids = append(ids, id)
	}
	return
}

// ResetEventlisteners resets all changes to the "eventlisteners" edge.
func (m *InstanceMutation) ResetEventlisteners() {
	m.eventlisteners = nil
	m.clearedeventlisteners = false
	m.removedeventlisteners = nil
}

// Where appends a list predicates to the InstanceMutation builder.
func (m *InstanceMutation) Where(ps ...predicate.Instance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Instance).
func (m *InstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, instance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, instance.FieldUpdatedAt)
	}
	if m.end_at != nil {
		fields = append(fields, instance.FieldEndAt)
	}
	if m.status != nil {
		fields = append(fields, instance.FieldStatus)
	}
	if m.as != nil {
		fields = append(fields, instance.FieldAs)
	}
	if m.errorCode != nil {
		fields = append(fields, instance.FieldErrorCode)
	}
	if m.errorMessage != nil {
		fields = append(fields, instance.FieldErrorMessage)
	}
	if m.invoker != nil {
		fields = append(fields, instance.FieldInvoker)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instance.FieldCreatedAt:
		return m.CreatedAt()
	case instance.FieldUpdatedAt:
		return m.UpdatedAt()
	case instance.FieldEndAt:
		return m.EndAt()
	case instance.FieldStatus:
		return m.Status()
	case instance.FieldAs:
		return m.As()
	case instance.FieldErrorCode:
		return m.ErrorCode()
	case instance.FieldErrorMessage:
		return m.ErrorMessage()
	case instance.FieldInvoker:
		return m.Invoker()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case instance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case instance.FieldEndAt:
		return m.OldEndAt(ctx)
	case instance.FieldStatus:
		return m.OldStatus(ctx)
	case instance.FieldAs:
		return m.OldAs(ctx)
	case instance.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case instance.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case instance.FieldInvoker:
		return m.OldInvoker(ctx)
	}
	return nil, fmt.Errorf("unknown Instance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case instance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case instance.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case instance.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case instance.FieldAs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAs(v)
		return nil
	case instance.FieldErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case instance.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case instance.FieldInvoker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoker(v)
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Instance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(instance.FieldEndAt) {
		fields = append(fields, instance.FieldEndAt)
	}
	if m.FieldCleared(instance.FieldErrorCode) {
		fields = append(fields, instance.FieldErrorCode)
	}
	if m.FieldCleared(instance.FieldErrorMessage) {
		fields = append(fields, instance.FieldErrorMessage)
	}
	if m.FieldCleared(instance.FieldInvoker) {
		fields = append(fields, instance.FieldInvoker)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceMutation) ClearField(name string) error {
	switch name {
	case instance.FieldEndAt:
		m.ClearEndAt()
		return nil
	case instance.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case instance.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case instance.FieldInvoker:
		m.ClearInvoker()
		return nil
	}
	return fmt.Errorf("unknown Instance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceMutation) ResetField(name string) error {
	switch name {
	case instance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case instance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case instance.FieldEndAt:
		m.ResetEndAt()
		return nil
	case instance.FieldStatus:
		m.ResetStatus()
		return nil
	case instance.FieldAs:
		m.ResetAs()
		return nil
	case instance.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case instance.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case instance.FieldInvoker:
		m.ResetInvoker()
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.namespace != nil {
		edges = append(edges, instance.EdgeNamespace)
	}
	if m.workflow != nil {
		edges = append(edges, instance.EdgeWorkflow)
	}
	if m.revision != nil {
		edges = append(edges, instance.EdgeRevision)
	}
	if m.logs != nil {
		edges = append(edges, instance.EdgeLogs)
	}
	if m.vars != nil {
		edges = append(edges, instance.EdgeVars)
	}
	if m.runtime != nil {
		edges = append(edges, instance.EdgeRuntime)
	}
	if m.children != nil {
		edges = append(edges, instance.EdgeChildren)
	}
	if m.eventlisteners != nil {
		edges = append(edges, instance.EdgeEventlisteners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeRevision:
		if id := m.revision; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeVars:
		ids := make([]ent.Value, 0, len(m.vars))
		for id := range m.vars {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeRuntime:
		if id := m.runtime; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeEventlisteners:
		ids := make([]ent.Value, 0, len(m.eventlisteners))
		for id := range m.eventlisteners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedlogs != nil {
		edges = append(edges, instance.EdgeLogs)
	}
	if m.removedvars != nil {
		edges = append(edges, instance.EdgeVars)
	}
	if m.removedchildren != nil {
		edges = append(edges, instance.EdgeChildren)
	}
	if m.removedeventlisteners != nil {
		edges = append(edges, instance.EdgeEventlisteners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeVars:
		ids := make([]ent.Value, 0, len(m.removedvars))
		for id := range m.removedvars {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeEventlisteners:
		ids := make([]ent.Value, 0, len(m.removedeventlisteners))
		for id := range m.removedeventlisteners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearednamespace {
		edges = append(edges, instance.EdgeNamespace)
	}
	if m.clearedworkflow {
		edges = append(edges, instance.EdgeWorkflow)
	}
	if m.clearedrevision {
		edges = append(edges, instance.EdgeRevision)
	}
	if m.clearedlogs {
		edges = append(edges, instance.EdgeLogs)
	}
	if m.clearedvars {
		edges = append(edges, instance.EdgeVars)
	}
	if m.clearedruntime {
		edges = append(edges, instance.EdgeRuntime)
	}
	if m.clearedchildren {
		edges = append(edges, instance.EdgeChildren)
	}
	if m.clearedeventlisteners {
		edges = append(edges, instance.EdgeEventlisteners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case instance.EdgeNamespace:
		return m.clearednamespace
	case instance.EdgeWorkflow:
		return m.clearedworkflow
	case instance.EdgeRevision:
		return m.clearedrevision
	case instance.EdgeLogs:
		return m.clearedlogs
	case instance.EdgeVars:
		return m.clearedvars
	case instance.EdgeRuntime:
		return m.clearedruntime
	case instance.EdgeChildren:
		return m.clearedchildren
	case instance.EdgeEventlisteners:
		return m.clearedeventlisteners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceMutation) ClearEdge(name string) error {
	switch name {
	case instance.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case instance.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case instance.EdgeRevision:
		m.ClearRevision()
		return nil
	case instance.EdgeRuntime:
		m.ClearRuntime()
		return nil
	}
	return fmt.Errorf("unknown Instance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceMutation) ResetEdge(name string) error {
	switch name {
	case instance.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case instance.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case instance.EdgeRevision:
		m.ResetRevision()
		return nil
	case instance.EdgeLogs:
		m.ResetLogs()
		return nil
	case instance.EdgeVars:
		m.ResetVars()
		return nil
	case instance.EdgeRuntime:
		m.ResetRuntime()
		return nil
	case instance.EdgeChildren:
		m.ResetChildren()
		return nil
	case instance.EdgeEventlisteners:
		m.ResetEventlisteners()
		return nil
	}
	return fmt.Errorf("unknown Instance edge %s", name)
}

// InstanceRuntimeMutation represents an operation that mutates the InstanceRuntime nodes in the graph.
type InstanceRuntimeMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	input           *[]byte
	data            *string
	controller      *string
	memory          *string
	flow            *[]string
	appendflow      []string
	output          *string
	stateBeginTime  *time.Time
	deadline        *time.Time
	attempts        *int
	addattempts     *int
	caller_data     *string
	instanceContext *string
	stateContext    *string
	metadata        *string
	clearedFields   map[string]struct{}
	instance        *uuid.UUID
	clearedinstance bool
	caller          *uuid.UUID
	clearedcaller   bool
	done            bool
	oldValue        func(context.Context) (*InstanceRuntime, error)
	predicates      []predicate.InstanceRuntime
}

var _ ent.Mutation = (*InstanceRuntimeMutation)(nil)

// instanceruntimeOption allows management of the mutation configuration using functional options.
type instanceruntimeOption func(*InstanceRuntimeMutation)

// newInstanceRuntimeMutation creates new mutation for the InstanceRuntime entity.
func newInstanceRuntimeMutation(c config, op Op, opts ...instanceruntimeOption) *InstanceRuntimeMutation {
	m := &InstanceRuntimeMutation{
		config:        c,
		op:            op,
		typ:           TypeInstanceRuntime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceRuntimeID sets the ID field of the mutation.
func withInstanceRuntimeID(id uuid.UUID) instanceruntimeOption {
	return func(m *InstanceRuntimeMutation) {
		var (
			err   error
			once  sync.Once
			value *InstanceRuntime
		)
		m.oldValue = func(ctx context.Context) (*InstanceRuntime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstanceRuntime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstanceRuntime sets the old InstanceRuntime of the mutation.
func withInstanceRuntime(node *InstanceRuntime) instanceruntimeOption {
	return func(m *InstanceRuntimeMutation) {
		m.oldValue = func(context.Context) (*InstanceRuntime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceRuntimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceRuntimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstanceRuntime entities.
func (m *InstanceRuntimeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceRuntimeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceRuntimeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstanceRuntime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInput sets the "input" field.
func (m *InstanceRuntimeMutation) SetInput(b []byte) {
	m.input = &b
}

// Input returns the value of the "input" field in the mutation.
func (m *InstanceRuntimeMutation) Input() (r []byte, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldInput(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *InstanceRuntimeMutation) ResetInput() {
	m.input = nil
}

// SetData sets the "data" field.
func (m *InstanceRuntimeMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *InstanceRuntimeMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *InstanceRuntimeMutation) ResetData() {
	m.data = nil
}

// SetController sets the "controller" field.
func (m *InstanceRuntimeMutation) SetController(s string) {
	m.controller = &s
}

// Controller returns the value of the "controller" field in the mutation.
func (m *InstanceRuntimeMutation) Controller() (r string, exists bool) {
	v := m.controller
	if v == nil {
		return
	}
	return *v, true
}

// OldController returns the old "controller" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldController(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldController: %w", err)
	}
	return oldValue.Controller, nil
}

// ClearController clears the value of the "controller" field.
func (m *InstanceRuntimeMutation) ClearController() {
	m.controller = nil
	m.clearedFields[instanceruntime.FieldController] = struct{}{}
}

// ControllerCleared returns if the "controller" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) ControllerCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldController]
	return ok
}

// ResetController resets all changes to the "controller" field.
func (m *InstanceRuntimeMutation) ResetController() {
	m.controller = nil
	delete(m.clearedFields, instanceruntime.FieldController)
}

// SetMemory sets the "memory" field.
func (m *InstanceRuntimeMutation) SetMemory(s string) {
	m.memory = &s
}

// Memory returns the value of the "memory" field in the mutation.
func (m *InstanceRuntimeMutation) Memory() (r string, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldMemory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// ClearMemory clears the value of the "memory" field.
func (m *InstanceRuntimeMutation) ClearMemory() {
	m.memory = nil
	m.clearedFields[instanceruntime.FieldMemory] = struct{}{}
}

// MemoryCleared returns if the "memory" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) MemoryCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldMemory]
	return ok
}

// ResetMemory resets all changes to the "memory" field.
func (m *InstanceRuntimeMutation) ResetMemory() {
	m.memory = nil
	delete(m.clearedFields, instanceruntime.FieldMemory)
}

// SetFlow sets the "flow" field.
func (m *InstanceRuntimeMutation) SetFlow(s []string) {
	m.flow = &s
	m.appendflow = nil
}

// Flow returns the value of the "flow" field in the mutation.
func (m *InstanceRuntimeMutation) Flow() (r []string, exists bool) {
	v := m.flow
	if v == nil {
		return
	}
	return *v, true
}

// OldFlow returns the old "flow" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldFlow(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlow: %w", err)
	}
	return oldValue.Flow, nil
}

// AppendFlow adds s to the "flow" field.
func (m *InstanceRuntimeMutation) AppendFlow(s []string) {
	m.appendflow = append(m.appendflow, s...)
}

// AppendedFlow returns the list of values that were appended to the "flow" field in this mutation.
func (m *InstanceRuntimeMutation) AppendedFlow() ([]string, bool) {
	if len(m.appendflow) == 0 {
		return nil, false
	}
	return m.appendflow, true
}

// ClearFlow clears the value of the "flow" field.
func (m *InstanceRuntimeMutation) ClearFlow() {
	m.flow = nil
	m.appendflow = nil
	m.clearedFields[instanceruntime.FieldFlow] = struct{}{}
}

// FlowCleared returns if the "flow" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) FlowCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldFlow]
	return ok
}

// ResetFlow resets all changes to the "flow" field.
func (m *InstanceRuntimeMutation) ResetFlow() {
	m.flow = nil
	m.appendflow = nil
	delete(m.clearedFields, instanceruntime.FieldFlow)
}

// SetOutput sets the "output" field.
func (m *InstanceRuntimeMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *InstanceRuntimeMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *InstanceRuntimeMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[instanceruntime.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) OutputCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *InstanceRuntimeMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, instanceruntime.FieldOutput)
}

// SetStateBeginTime sets the "stateBeginTime" field.
func (m *InstanceRuntimeMutation) SetStateBeginTime(t time.Time) {
	m.stateBeginTime = &t
}

// StateBeginTime returns the value of the "stateBeginTime" field in the mutation.
func (m *InstanceRuntimeMutation) StateBeginTime() (r time.Time, exists bool) {
	v := m.stateBeginTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStateBeginTime returns the old "stateBeginTime" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldStateBeginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateBeginTime: %w", err)
	}
	return oldValue.StateBeginTime, nil
}

// ClearStateBeginTime clears the value of the "stateBeginTime" field.
func (m *InstanceRuntimeMutation) ClearStateBeginTime() {
	m.stateBeginTime = nil
	m.clearedFields[instanceruntime.FieldStateBeginTime] = struct{}{}
}

// StateBeginTimeCleared returns if the "stateBeginTime" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) StateBeginTimeCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldStateBeginTime]
	return ok
}

// ResetStateBeginTime resets all changes to the "stateBeginTime" field.
func (m *InstanceRuntimeMutation) ResetStateBeginTime() {
	m.stateBeginTime = nil
	delete(m.clearedFields, instanceruntime.FieldStateBeginTime)
}

// SetDeadline sets the "deadline" field.
func (m *InstanceRuntimeMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *InstanceRuntimeMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ClearDeadline clears the value of the "deadline" field.
func (m *InstanceRuntimeMutation) ClearDeadline() {
	m.deadline = nil
	m.clearedFields[instanceruntime.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *InstanceRuntimeMutation) ResetDeadline() {
	m.deadline = nil
	delete(m.clearedFields, instanceruntime.FieldDeadline)
}

// SetAttempts sets the "attempts" field.
func (m *InstanceRuntimeMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *InstanceRuntimeMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *InstanceRuntimeMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *InstanceRuntimeMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ClearAttempts clears the value of the "attempts" field.
func (m *InstanceRuntimeMutation) ClearAttempts() {
	m.attempts = nil
	m.addattempts = nil
	m.clearedFields[instanceruntime.FieldAttempts] = struct{}{}
}

// AttemptsCleared returns if the "attempts" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) AttemptsCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldAttempts]
	return ok
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *InstanceRuntimeMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
	delete(m.clearedFields, instanceruntime.FieldAttempts)
}

// SetCallerData sets the "caller_data" field.
func (m *InstanceRuntimeMutation) SetCallerData(s string) {
	m.caller_data = &s
}

// CallerData returns the value of the "caller_data" field in the mutation.
func (m *InstanceRuntimeMutation) CallerData() (r string, exists bool) {
	v := m.caller_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCallerData returns the old "caller_data" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldCallerData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallerData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallerData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallerData: %w", err)
	}
	return oldValue.CallerData, nil
}

// ClearCallerData clears the value of the "caller_data" field.
func (m *InstanceRuntimeMutation) ClearCallerData() {
	m.caller_data = nil
	m.clearedFields[instanceruntime.FieldCallerData] = struct{}{}
}

// CallerDataCleared returns if the "caller_data" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) CallerDataCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldCallerData]
	return ok
}

// ResetCallerData resets all changes to the "caller_data" field.
func (m *InstanceRuntimeMutation) ResetCallerData() {
	m.caller_data = nil
	delete(m.clearedFields, instanceruntime.FieldCallerData)
}

// SetInstanceContext sets the "instanceContext" field.
func (m *InstanceRuntimeMutation) SetInstanceContext(s string) {
	m.instanceContext = &s
}

// InstanceContext returns the value of the "instanceContext" field in the mutation.
func (m *InstanceRuntimeMutation) InstanceContext() (r string, exists bool) {
	v := m.instanceContext
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceContext returns the old "instanceContext" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldInstanceContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceContext: %w", err)
	}
	return oldValue.InstanceContext, nil
}

// ClearInstanceContext clears the value of the "instanceContext" field.
func (m *InstanceRuntimeMutation) ClearInstanceContext() {
	m.instanceContext = nil
	m.clearedFields[instanceruntime.FieldInstanceContext] = struct{}{}
}

// InstanceContextCleared returns if the "instanceContext" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) InstanceContextCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldInstanceContext]
	return ok
}

// ResetInstanceContext resets all changes to the "instanceContext" field.
func (m *InstanceRuntimeMutation) ResetInstanceContext() {
	m.instanceContext = nil
	delete(m.clearedFields, instanceruntime.FieldInstanceContext)
}

// SetStateContext sets the "stateContext" field.
func (m *InstanceRuntimeMutation) SetStateContext(s string) {
	m.stateContext = &s
}

// StateContext returns the value of the "stateContext" field in the mutation.
func (m *InstanceRuntimeMutation) StateContext() (r string, exists bool) {
	v := m.stateContext
	if v == nil {
		return
	}
	return *v, true
}

// OldStateContext returns the old "stateContext" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldStateContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateContext: %w", err)
	}
	return oldValue.StateContext, nil
}

// ClearStateContext clears the value of the "stateContext" field.
func (m *InstanceRuntimeMutation) ClearStateContext() {
	m.stateContext = nil
	m.clearedFields[instanceruntime.FieldStateContext] = struct{}{}
}

// StateContextCleared returns if the "stateContext" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) StateContextCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldStateContext]
	return ok
}

// ResetStateContext resets all changes to the "stateContext" field.
func (m *InstanceRuntimeMutation) ResetStateContext() {
	m.stateContext = nil
	delete(m.clearedFields, instanceruntime.FieldStateContext)
}

// SetMetadata sets the "metadata" field.
func (m *InstanceRuntimeMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *InstanceRuntimeMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *InstanceRuntimeMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[instanceruntime.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *InstanceRuntimeMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, instanceruntime.FieldMetadata)
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *InstanceRuntimeMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *InstanceRuntimeMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *InstanceRuntimeMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *InstanceRuntimeMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *InstanceRuntimeMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *InstanceRuntimeMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// SetCallerID sets the "caller" edge to the Instance entity by id.
func (m *InstanceRuntimeMutation) SetCallerID(id uuid.UUID) {
	m.caller = &id
}

// ClearCaller clears the "caller" edge to the Instance entity.
func (m *InstanceRuntimeMutation) ClearCaller() {
	m.clearedcaller = true
}

// CallerCleared reports if the "caller" edge to the Instance entity was cleared.
func (m *InstanceRuntimeMutation) CallerCleared() bool {
	return m.clearedcaller
}

// CallerID returns the "caller" edge ID in the mutation.
func (m *InstanceRuntimeMutation) CallerID() (id uuid.UUID, exists bool) {
	if m.caller != nil {
		return *m.caller, true
	}
	return
}

// CallerIDs returns the "caller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallerID instead. It exists only for internal usage by the builders.
func (m *InstanceRuntimeMutation) CallerIDs() (ids []uuid.UUID) {
	if id := m.caller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCaller resets all changes to the "caller" edge.
func (m *InstanceRuntimeMutation) ResetCaller() {
	m.caller = nil
	m.clearedcaller = false
}

// Where appends a list predicates to the InstanceRuntimeMutation builder.
func (m *InstanceRuntimeMutation) Where(ps ...predicate.InstanceRuntime) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InstanceRuntimeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InstanceRuntime).
func (m *InstanceRuntimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceRuntimeMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.input != nil {
		fields = append(fields, instanceruntime.FieldInput)
	}
	if m.data != nil {
		fields = append(fields, instanceruntime.FieldData)
	}
	if m.controller != nil {
		fields = append(fields, instanceruntime.FieldController)
	}
	if m.memory != nil {
		fields = append(fields, instanceruntime.FieldMemory)
	}
	if m.flow != nil {
		fields = append(fields, instanceruntime.FieldFlow)
	}
	if m.output != nil {
		fields = append(fields, instanceruntime.FieldOutput)
	}
	if m.stateBeginTime != nil {
		fields = append(fields, instanceruntime.FieldStateBeginTime)
	}
	if m.deadline != nil {
		fields = append(fields, instanceruntime.FieldDeadline)
	}
	if m.attempts != nil {
		fields = append(fields, instanceruntime.FieldAttempts)
	}
	if m.caller_data != nil {
		fields = append(fields, instanceruntime.FieldCallerData)
	}
	if m.instanceContext != nil {
		fields = append(fields, instanceruntime.FieldInstanceContext)
	}
	if m.stateContext != nil {
		fields = append(fields, instanceruntime.FieldStateContext)
	}
	if m.metadata != nil {
		fields = append(fields, instanceruntime.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceRuntimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instanceruntime.FieldInput:
		return m.Input()
	case instanceruntime.FieldData:
		return m.Data()
	case instanceruntime.FieldController:
		return m.Controller()
	case instanceruntime.FieldMemory:
		return m.Memory()
	case instanceruntime.FieldFlow:
		return m.Flow()
	case instanceruntime.FieldOutput:
		return m.Output()
	case instanceruntime.FieldStateBeginTime:
		return m.StateBeginTime()
	case instanceruntime.FieldDeadline:
		return m.Deadline()
	case instanceruntime.FieldAttempts:
		return m.Attempts()
	case instanceruntime.FieldCallerData:
		return m.CallerData()
	case instanceruntime.FieldInstanceContext:
		return m.InstanceContext()
	case instanceruntime.FieldStateContext:
		return m.StateContext()
	case instanceruntime.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceRuntimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instanceruntime.FieldInput:
		return m.OldInput(ctx)
	case instanceruntime.FieldData:
		return m.OldData(ctx)
	case instanceruntime.FieldController:
		return m.OldController(ctx)
	case instanceruntime.FieldMemory:
		return m.OldMemory(ctx)
	case instanceruntime.FieldFlow:
		return m.OldFlow(ctx)
	case instanceruntime.FieldOutput:
		return m.OldOutput(ctx)
	case instanceruntime.FieldStateBeginTime:
		return m.OldStateBeginTime(ctx)
	case instanceruntime.FieldDeadline:
		return m.OldDeadline(ctx)
	case instanceruntime.FieldAttempts:
		return m.OldAttempts(ctx)
	case instanceruntime.FieldCallerData:
		return m.OldCallerData(ctx)
	case instanceruntime.FieldInstanceContext:
		return m.OldInstanceContext(ctx)
	case instanceruntime.FieldStateContext:
		return m.OldStateContext(ctx)
	case instanceruntime.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown InstanceRuntime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceRuntimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instanceruntime.FieldInput:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case instanceruntime.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case instanceruntime.FieldController:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetController(v)
		return nil
	case instanceruntime.FieldMemory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case instanceruntime.FieldFlow:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlow(v)
		return nil
	case instanceruntime.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case instanceruntime.FieldStateBeginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateBeginTime(v)
		return nil
	case instanceruntime.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case instanceruntime.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case instanceruntime.FieldCallerData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallerData(v)
		return nil
	case instanceruntime.FieldInstanceContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceContext(v)
		return nil
	case instanceruntime.FieldStateContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateContext(v)
		return nil
	case instanceruntime.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceRuntimeMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, instanceruntime.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceRuntimeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case instanceruntime.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceRuntimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case instanceruntime.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceRuntimeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(instanceruntime.FieldController) {
		fields = append(fields, instanceruntime.FieldController)
	}
	if m.FieldCleared(instanceruntime.FieldMemory) {
		fields = append(fields, instanceruntime.FieldMemory)
	}
	if m.FieldCleared(instanceruntime.FieldFlow) {
		fields = append(fields, instanceruntime.FieldFlow)
	}
	if m.FieldCleared(instanceruntime.FieldOutput) {
		fields = append(fields, instanceruntime.FieldOutput)
	}
	if m.FieldCleared(instanceruntime.FieldStateBeginTime) {
		fields = append(fields, instanceruntime.FieldStateBeginTime)
	}
	if m.FieldCleared(instanceruntime.FieldDeadline) {
		fields = append(fields, instanceruntime.FieldDeadline)
	}
	if m.FieldCleared(instanceruntime.FieldAttempts) {
		fields = append(fields, instanceruntime.FieldAttempts)
	}
	if m.FieldCleared(instanceruntime.FieldCallerData) {
		fields = append(fields, instanceruntime.FieldCallerData)
	}
	if m.FieldCleared(instanceruntime.FieldInstanceContext) {
		fields = append(fields, instanceruntime.FieldInstanceContext)
	}
	if m.FieldCleared(instanceruntime.FieldStateContext) {
		fields = append(fields, instanceruntime.FieldStateContext)
	}
	if m.FieldCleared(instanceruntime.FieldMetadata) {
		fields = append(fields, instanceruntime.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceRuntimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceRuntimeMutation) ClearField(name string) error {
	switch name {
	case instanceruntime.FieldController:
		m.ClearController()
		return nil
	case instanceruntime.FieldMemory:
		m.ClearMemory()
		return nil
	case instanceruntime.FieldFlow:
		m.ClearFlow()
		return nil
	case instanceruntime.FieldOutput:
		m.ClearOutput()
		return nil
	case instanceruntime.FieldStateBeginTime:
		m.ClearStateBeginTime()
		return nil
	case instanceruntime.FieldDeadline:
		m.ClearDeadline()
		return nil
	case instanceruntime.FieldAttempts:
		m.ClearAttempts()
		return nil
	case instanceruntime.FieldCallerData:
		m.ClearCallerData()
		return nil
	case instanceruntime.FieldInstanceContext:
		m.ClearInstanceContext()
		return nil
	case instanceruntime.FieldStateContext:
		m.ClearStateContext()
		return nil
	case instanceruntime.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceRuntimeMutation) ResetField(name string) error {
	switch name {
	case instanceruntime.FieldInput:
		m.ResetInput()
		return nil
	case instanceruntime.FieldData:
		m.ResetData()
		return nil
	case instanceruntime.FieldController:
		m.ResetController()
		return nil
	case instanceruntime.FieldMemory:
		m.ResetMemory()
		return nil
	case instanceruntime.FieldFlow:
		m.ResetFlow()
		return nil
	case instanceruntime.FieldOutput:
		m.ResetOutput()
		return nil
	case instanceruntime.FieldStateBeginTime:
		m.ResetStateBeginTime()
		return nil
	case instanceruntime.FieldDeadline:
		m.ResetDeadline()
		return nil
	case instanceruntime.FieldAttempts:
		m.ResetAttempts()
		return nil
	case instanceruntime.FieldCallerData:
		m.ResetCallerData()
		return nil
	case instanceruntime.FieldInstanceContext:
		m.ResetInstanceContext()
		return nil
	case instanceruntime.FieldStateContext:
		m.ResetStateContext()
		return nil
	case instanceruntime.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceRuntimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.instance != nil {
		edges = append(edges, instanceruntime.EdgeInstance)
	}
	if m.caller != nil {
		edges = append(edges, instanceruntime.EdgeCaller)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceRuntimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instanceruntime.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	case instanceruntime.EdgeCaller:
		if id := m.caller; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceRuntimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceRuntimeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceRuntimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinstance {
		edges = append(edges, instanceruntime.EdgeInstance)
	}
	if m.clearedcaller {
		edges = append(edges, instanceruntime.EdgeCaller)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceRuntimeMutation) EdgeCleared(name string) bool {
	switch name {
	case instanceruntime.EdgeInstance:
		return m.clearedinstance
	case instanceruntime.EdgeCaller:
		return m.clearedcaller
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceRuntimeMutation) ClearEdge(name string) error {
	switch name {
	case instanceruntime.EdgeInstance:
		m.ClearInstance()
		return nil
	case instanceruntime.EdgeCaller:
		m.ClearCaller()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceRuntimeMutation) ResetEdge(name string) error {
	switch name {
	case instanceruntime.EdgeInstance:
		m.ResetInstance()
		return nil
	case instanceruntime.EdgeCaller:
		m.ResetCaller()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime edge %s", name)
}

// LogMsgMutation represents an operation that mutates the LogMsg nodes in the graph.
type LogMsgMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	t                *time.Time
	msg              *string
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	workflow         *uuid.UUID
	clearedworkflow  bool
	instance         *uuid.UUID
	clearedinstance  bool
	activity         *uuid.UUID
	clearedactivity  bool
	done             bool
	oldValue         func(context.Context) (*LogMsg, error)
	predicates       []predicate.LogMsg
}

var _ ent.Mutation = (*LogMsgMutation)(nil)

// logmsgOption allows management of the mutation configuration using functional options.
type logmsgOption func(*LogMsgMutation)

// newLogMsgMutation creates new mutation for the LogMsg entity.
func newLogMsgMutation(c config, op Op, opts ...logmsgOption) *LogMsgMutation {
	m := &LogMsgMutation{
		config:        c,
		op:            op,
		typ:           TypeLogMsg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogMsgID sets the ID field of the mutation.
func withLogMsgID(id uuid.UUID) logmsgOption {
	return func(m *LogMsgMutation) {
		var (
			err   error
			once  sync.Once
			value *LogMsg
		)
		m.oldValue = func(ctx context.Context) (*LogMsg, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LogMsg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogMsg sets the old LogMsg of the mutation.
func withLogMsg(node *LogMsg) logmsgOption {
	return func(m *LogMsgMutation) {
		m.oldValue = func(context.Context) (*LogMsg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogMsgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogMsgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LogMsg entities.
func (m *LogMsgMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogMsgMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogMsgMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LogMsg.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetT sets the "t" field.
func (m *LogMsgMutation) SetT(t time.Time) {
	m.t = &t
}

// T returns the value of the "t" field in the mutation.
func (m *LogMsgMutation) T() (r time.Time, exists bool) {
	v := m.t
	if v == nil {
		return
	}
	return *v, true
}

// OldT returns the old "t" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldT(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldT: %w", err)
	}
	return oldValue.T, nil
}

// ResetT resets all changes to the "t" field.
func (m *LogMsgMutation) ResetT() {
	m.t = nil
}

// SetMsg sets the "msg" field.
func (m *LogMsgMutation) SetMsg(s string) {
	m.msg = &s
}

// Msg returns the value of the "msg" field in the mutation.
func (m *LogMsgMutation) Msg() (r string, exists bool) {
	v := m.msg
	if v == nil {
		return
	}
	return *v, true
}

// OldMsg returns the old "msg" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsg: %w", err)
	}
	return oldValue.Msg, nil
}

// ResetMsg resets all changes to the "msg" field.
func (m *LogMsgMutation) ResetMsg() {
	m.msg = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *LogMsgMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *LogMsgMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *LogMsgMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *LogMsgMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *LogMsgMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *LogMsgMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *LogMsgMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *LogMsgMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *LogMsgMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *LogMsgMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *LogMsgMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *LogMsgMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *LogMsgMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *LogMsgMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *LogMsgMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *LogMsgMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *LogMsgMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *LogMsgMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// SetActivityID sets the "activity" edge to the MirrorActivity entity by id.
func (m *LogMsgMutation) SetActivityID(id uuid.UUID) {
	m.activity = &id
}

// ClearActivity clears the "activity" edge to the MirrorActivity entity.
func (m *LogMsgMutation) ClearActivity() {
	m.clearedactivity = true
}

// ActivityCleared reports if the "activity" edge to the MirrorActivity entity was cleared.
func (m *LogMsgMutation) ActivityCleared() bool {
	return m.clearedactivity
}

// ActivityID returns the "activity" edge ID in the mutation.
func (m *LogMsgMutation) ActivityID() (id uuid.UUID, exists bool) {
	if m.activity != nil {
		return *m.activity, true
	}
	return
}

// ActivityIDs returns the "activity" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ActivityID instead. It exists only for internal usage by the builders.
func (m *LogMsgMutation) ActivityIDs() (ids []uuid.UUID) {
	if id := m.activity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetActivity resets all changes to the "activity" edge.
func (m *LogMsgMutation) ResetActivity() {
	m.activity = nil
	m.clearedactivity = false
}

// Where appends a list predicates to the LogMsgMutation builder.
func (m *LogMsgMutation) Where(ps ...predicate.LogMsg) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LogMsgMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LogMsg).
func (m *LogMsgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogMsgMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.t != nil {
		fields = append(fields, logmsg.FieldT)
	}
	if m.msg != nil {
		fields = append(fields, logmsg.FieldMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogMsgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logmsg.FieldT:
		return m.T()
	case logmsg.FieldMsg:
		return m.Msg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogMsgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logmsg.FieldT:
		return m.OldT(ctx)
	case logmsg.FieldMsg:
		return m.OldMsg(ctx)
	}
	return nil, fmt.Errorf("unknown LogMsg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogMsgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logmsg.FieldT:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetT(v)
		return nil
	case logmsg.FieldMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsg(v)
		return nil
	}
	return fmt.Errorf("unknown LogMsg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogMsgMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogMsgMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogMsgMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LogMsg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogMsgMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogMsgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogMsgMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LogMsg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogMsgMutation) ResetField(name string) error {
	switch name {
	case logmsg.FieldT:
		m.ResetT()
		return nil
	case logmsg.FieldMsg:
		m.ResetMsg()
		return nil
	}
	return fmt.Errorf("unknown LogMsg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogMsgMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.namespace != nil {
		edges = append(edges, logmsg.EdgeNamespace)
	}
	if m.workflow != nil {
		edges = append(edges, logmsg.EdgeWorkflow)
	}
	if m.instance != nil {
		edges = append(edges, logmsg.EdgeInstance)
	}
	if m.activity != nil {
		edges = append(edges, logmsg.EdgeActivity)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogMsgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case logmsg.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case logmsg.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case logmsg.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	case logmsg.EdgeActivity:
		if id := m.activity; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogMsgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogMsgMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogMsgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearednamespace {
		edges = append(edges, logmsg.EdgeNamespace)
	}
	if m.clearedworkflow {
		edges = append(edges, logmsg.EdgeWorkflow)
	}
	if m.clearedinstance {
		edges = append(edges, logmsg.EdgeInstance)
	}
	if m.clearedactivity {
		edges = append(edges, logmsg.EdgeActivity)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogMsgMutation) EdgeCleared(name string) bool {
	switch name {
	case logmsg.EdgeNamespace:
		return m.clearednamespace
	case logmsg.EdgeWorkflow:
		return m.clearedworkflow
	case logmsg.EdgeInstance:
		return m.clearedinstance
	case logmsg.EdgeActivity:
		return m.clearedactivity
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogMsgMutation) ClearEdge(name string) error {
	switch name {
	case logmsg.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case logmsg.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case logmsg.EdgeInstance:
		m.ClearInstance()
		return nil
	case logmsg.EdgeActivity:
		m.ClearActivity()
		return nil
	}
	return fmt.Errorf("unknown LogMsg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogMsgMutation) ResetEdge(name string) error {
	switch name {
	case logmsg.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case logmsg.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case logmsg.EdgeInstance:
		m.ResetInstance()
		return nil
	case logmsg.EdgeActivity:
		m.ResetActivity()
		return nil
	}
	return fmt.Errorf("unknown LogMsg edge %s", name)
}

// MirrorMutation represents an operation that mutates the Mirror nodes in the graph.
type MirrorMutation struct {
	config
	op                Op
	typ               string
	id                *uuid.UUID
	url               *string
	ref               *string
	cron              *string
	public_key        *string
	private_key       *string
	passphrase        *string
	commit            *string
	last_sync         *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	namespace         *uuid.UUID
	clearednamespace  bool
	inode             *uuid.UUID
	clearedinode      bool
	activities        map[uuid.UUID]struct{}
	removedactivities map[uuid.UUID]struct{}
	clearedactivities bool
	done              bool
	oldValue          func(context.Context) (*Mirror, error)
	predicates        []predicate.Mirror
}

var _ ent.Mutation = (*MirrorMutation)(nil)

// mirrorOption allows management of the mutation configuration using functional options.
type mirrorOption func(*MirrorMutation)

// newMirrorMutation creates new mutation for the Mirror entity.
func newMirrorMutation(c config, op Op, opts ...mirrorOption) *MirrorMutation {
	m := &MirrorMutation{
		config:        c,
		op:            op,
		typ:           TypeMirror,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMirrorID sets the ID field of the mutation.
func withMirrorID(id uuid.UUID) mirrorOption {
	return func(m *MirrorMutation) {
		var (
			err   error
			once  sync.Once
			value *Mirror
		)
		m.oldValue = func(ctx context.Context) (*Mirror, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mirror.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMirror sets the old Mirror of the mutation.
func withMirror(node *Mirror) mirrorOption {
	return func(m *MirrorMutation) {
		m.oldValue = func(context.Context) (*Mirror, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MirrorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MirrorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mirror entities.
func (m *MirrorMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MirrorMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MirrorMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mirror.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetURL sets the "url" field.
func (m *MirrorMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *MirrorMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Mirror entity.
// If the Mirror object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *MirrorMutation) ResetURL() {
	m.url = nil
}

// SetRef sets the "ref" field.
func (m *MirrorMutation) SetRef(s string) {
	m.ref = &s
}

// Ref returns the value of the "ref" field in the mutation.
func (m *MirrorMutation) Ref() (r string, exists bool) {
	v := m.ref
	if v == nil {
		return
	}
	return *v, true
}

// OldRef returns the old "ref" field's value of the Mirror entity.
// If the Mirror object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorMutation) OldRef(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRef is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRef requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRef: %w", err)
	}
	return oldValue.Ref, nil
}

// ResetRef resets all changes to the "ref" field.
func (m *MirrorMutation) ResetRef() {
	m.ref = nil
}

// SetCron sets the "cron" field.
func (m *MirrorMutation) SetCron(s string) {
	m.cron = &s
}

// Cron returns the value of the "cron" field in the mutation.
func (m *MirrorMutation) Cron() (r string, exists bool) {
	v := m.cron
	if v == nil {
		return
	}
	return *v, true
}

// OldCron returns the old "cron" field's value of the Mirror entity.
// If the Mirror object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorMutation) OldCron(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCron is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCron requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCron: %w", err)
	}
	return oldValue.Cron, nil
}

// ResetCron resets all changes to the "cron" field.
func (m *MirrorMutation) ResetCron() {
	m.cron = nil
}

// SetPublicKey sets the "public_key" field.
func (m *MirrorMutation) SetPublicKey(s string) {
	m.public_key = &s
}

// PublicKey returns the value of the "public_key" field in the mutation.
func (m *MirrorMutation) PublicKey() (r string, exists bool) {
	v := m.public_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicKey returns the old "public_key" field's value of the Mirror entity.
// If the Mirror object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorMutation) OldPublicKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicKey: %w", err)
	}
	return oldValue.PublicKey, nil
}

// ResetPublicKey resets all changes to the "public_key" field.
func (m *MirrorMutation) ResetPublicKey() {
	m.public_key = nil
}

// SetPrivateKey sets the "private_key" field.
func (m *MirrorMutation) SetPrivateKey(s string) {
	m.private_key = &s
}

// PrivateKey returns the value of the "private_key" field in the mutation.
func (m *MirrorMutation) PrivateKey() (r string, exists bool) {
	v := m.private_key
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivateKey returns the old "private_key" field's value of the Mirror entity.
// If the Mirror object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorMutation) OldPrivateKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivateKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivateKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivateKey: %w", err)
	}
	return oldValue.PrivateKey, nil
}

// ResetPrivateKey resets all changes to the "private_key" field.
func (m *MirrorMutation) ResetPrivateKey() {
	m.private_key = nil
}

// SetPassphrase sets the "passphrase" field.
func (m *MirrorMutation) SetPassphrase(s string) {
	m.passphrase = &s
}

// Passphrase returns the value of the "passphrase" field in the mutation.
func (m *MirrorMutation) Passphrase() (r string, exists bool) {
	v := m.passphrase
	if v == nil {
		return
	}
	return *v, true
}

// OldPassphrase returns the old "passphrase" field's value of the Mirror entity.
// If the Mirror object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorMutation) OldPassphrase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassphrase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassphrase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassphrase: %w", err)
	}
	return oldValue.Passphrase, nil
}

// ResetPassphrase resets all changes to the "passphrase" field.
func (m *MirrorMutation) ResetPassphrase() {
	m.passphrase = nil
}

// SetCommit sets the "commit" field.
func (m *MirrorMutation) SetCommit(s string) {
	m.commit = &s
}

// Commit returns the value of the "commit" field in the mutation.
func (m *MirrorMutation) Commit() (r string, exists bool) {
	v := m.commit
	if v == nil {
		return
	}
	return *v, true
}

// OldCommit returns the old "commit" field's value of the Mirror entity.
// If the Mirror object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorMutation) OldCommit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommit: %w", err)
	}
	return oldValue.Commit, nil
}

// ResetCommit resets all changes to the "commit" field.
func (m *MirrorMutation) ResetCommit() {
	m.commit = nil
}

// SetLastSync sets the "last_sync" field.
func (m *MirrorMutation) SetLastSync(t time.Time) {
	m.last_sync = &t
}

// LastSync returns the value of the "last_sync" field in the mutation.
func (m *MirrorMutation) LastSync() (r time.Time, exists bool) {
	v := m.last_sync
	if v == nil {
		return
	}
	return *v, true
}

// OldLastSync returns the old "last_sync" field's value of the Mirror entity.
// If the Mirror object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorMutation) OldLastSync(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastSync is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastSync requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastSync: %w", err)
	}
	return oldValue.LastSync, nil
}

// ClearLastSync clears the value of the "last_sync" field.
func (m *MirrorMutation) ClearLastSync() {
	m.last_sync = nil
	m.clearedFields[mirror.FieldLastSync] = struct{}{}
}

// LastSyncCleared returns if the "last_sync" field was cleared in this mutation.
func (m *MirrorMutation) LastSyncCleared() bool {
	_, ok := m.clearedFields[mirror.FieldLastSync]
	return ok
}

// ResetLastSync resets all changes to the "last_sync" field.
func (m *MirrorMutation) ResetLastSync() {
	m.last_sync = nil
	delete(m.clearedFields, mirror.FieldLastSync)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MirrorMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MirrorMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Mirror entity.
// If the Mirror object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MirrorMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[mirror.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MirrorMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[mirror.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MirrorMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, mirror.FieldUpdatedAt)
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *MirrorMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *MirrorMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *MirrorMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *MirrorMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *MirrorMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *MirrorMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetInodeID sets the "inode" edge to the Inode entity by id.
func (m *MirrorMutation) SetInodeID(id uuid.UUID) {
	m.inode = &id
}

// ClearInode clears the "inode" edge to the Inode entity.
func (m *MirrorMutation) ClearInode() {
	m.clearedinode = true
}

// InodeCleared reports if the "inode" edge to the Inode entity was cleared.
func (m *MirrorMutation) InodeCleared() bool {
	return m.clearedinode
}

// InodeID returns the "inode" edge ID in the mutation.
func (m *MirrorMutation) InodeID() (id uuid.UUID, exists bool) {
	if m.inode != nil {
		return *m.inode, true
	}
	return
}

// InodeIDs returns the "inode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InodeID instead. It exists only for internal usage by the builders.
func (m *MirrorMutation) InodeIDs() (ids []uuid.UUID) {
	if id := m.inode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInode resets all changes to the "inode" edge.
func (m *MirrorMutation) ResetInode() {
	m.inode = nil
	m.clearedinode = false
}

// AddActivityIDs adds the "activities" edge to the MirrorActivity entity by ids.
func (m *MirrorMutation) AddActivityIDs(ids ...uuid.UUID) {
	if m.activities == nil {
		m.activities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.activities[ids[i]] = struct{}{}
	}
}

// ClearActivities clears the "activities" edge to the MirrorActivity entity.
func (m *MirrorMutation) ClearActivities() {
	m.clearedactivities = true
}

// ActivitiesCleared reports if the "activities" edge to the MirrorActivity entity was cleared.
func (m *MirrorMutation) ActivitiesCleared() bool {
	return m.clearedactivities
}

// RemoveActivityIDs removes the "activities" edge to the MirrorActivity entity by IDs.
func (m *MirrorMutation) RemoveActivityIDs(ids ...uuid.UUID) {
	if m.removedactivities == nil {
		m.removedactivities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.activities, ids[i])
		m.removedactivities[ids[i]] = struct{}{}
	}
}

// RemovedActivities returns the removed IDs of the "activities" edge to the MirrorActivity entity.
func (m *MirrorMutation) RemovedActivitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedactivities {
		ids = append(ids, id)
	}
	return
}

// ActivitiesIDs returns the "activities" edge IDs in the mutation.
func (m *MirrorMutation) ActivitiesIDs() (ids []uuid.UUID) {
	for id := range m.activities {
		ids = append(ids, id)
	}
	return
}

// ResetActivities resets all changes to the "activities" edge.
func (m *MirrorMutation) ResetActivities() {
	m.activities = nil
	m.clearedactivities = false
	m.removedactivities = nil
}

// Where appends a list predicates to the MirrorMutation builder.
func (m *MirrorMutation) Where(ps ...predicate.Mirror) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MirrorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Mirror).
func (m *MirrorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MirrorMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.url != nil {
		fields = append(fields, mirror.FieldURL)
	}
	if m.ref != nil {
		fields = append(fields, mirror.FieldRef)
	}
	if m.cron != nil {
		fields = append(fields, mirror.FieldCron)
	}
	if m.public_key != nil {
		fields = append(fields, mirror.FieldPublicKey)
	}
	if m.private_key != nil {
		fields = append(fields, mirror.FieldPrivateKey)
	}
	if m.passphrase != nil {
		fields = append(fields, mirror.FieldPassphrase)
	}
	if m.commit != nil {
		fields = append(fields, mirror.FieldCommit)
	}
	if m.last_sync != nil {
		fields = append(fields, mirror.FieldLastSync)
	}
	if m.updated_at != nil {
		fields = append(fields, mirror.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MirrorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mirror.FieldURL:
		return m.URL()
	case mirror.FieldRef:
		return m.Ref()
	case mirror.FieldCron:
		return m.Cron()
	case mirror.FieldPublicKey:
		return m.PublicKey()
	case mirror.FieldPrivateKey:
		return m.PrivateKey()
	case mirror.FieldPassphrase:
		return m.Passphrase()
	case mirror.FieldCommit:
		return m.Commit()
	case mirror.FieldLastSync:
		return m.LastSync()
	case mirror.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MirrorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mirror.FieldURL:
		return m.OldURL(ctx)
	case mirror.FieldRef:
		return m.OldRef(ctx)
	case mirror.FieldCron:
		return m.OldCron(ctx)
	case mirror.FieldPublicKey:
		return m.OldPublicKey(ctx)
	case mirror.FieldPrivateKey:
		return m.OldPrivateKey(ctx)
	case mirror.FieldPassphrase:
		return m.OldPassphrase(ctx)
	case mirror.FieldCommit:
		return m.OldCommit(ctx)
	case mirror.FieldLastSync:
		return m.OldLastSync(ctx)
	case mirror.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Mirror field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MirrorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mirror.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case mirror.FieldRef:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRef(v)
		return nil
	case mirror.FieldCron:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCron(v)
		return nil
	case mirror.FieldPublicKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicKey(v)
		return nil
	case mirror.FieldPrivateKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivateKey(v)
		return nil
	case mirror.FieldPassphrase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassphrase(v)
		return nil
	case mirror.FieldCommit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommit(v)
		return nil
	case mirror.FieldLastSync:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSync(v)
		return nil
	case mirror.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Mirror field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MirrorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MirrorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MirrorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Mirror numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MirrorMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mirror.FieldLastSync) {
		fields = append(fields, mirror.FieldLastSync)
	}
	if m.FieldCleared(mirror.FieldUpdatedAt) {
		fields = append(fields, mirror.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MirrorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MirrorMutation) ClearField(name string) error {
	switch name {
	case mirror.FieldLastSync:
		m.ClearLastSync()
		return nil
	case mirror.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Mirror nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MirrorMutation) ResetField(name string) error {
	switch name {
	case mirror.FieldURL:
		m.ResetURL()
		return nil
	case mirror.FieldRef:
		m.ResetRef()
		return nil
	case mirror.FieldCron:
		m.ResetCron()
		return nil
	case mirror.FieldPublicKey:
		m.ResetPublicKey()
		return nil
	case mirror.FieldPrivateKey:
		m.ResetPrivateKey()
		return nil
	case mirror.FieldPassphrase:
		m.ResetPassphrase()
		return nil
	case mirror.FieldCommit:
		m.ResetCommit()
		return nil
	case mirror.FieldLastSync:
		m.ResetLastSync()
		return nil
	case mirror.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Mirror field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MirrorMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.namespace != nil {
		edges = append(edges, mirror.EdgeNamespace)
	}
	if m.inode != nil {
		edges = append(edges, mirror.EdgeInode)
	}
	if m.activities != nil {
		edges = append(edges, mirror.EdgeActivities)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MirrorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mirror.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case mirror.EdgeInode:
		if id := m.inode; id != nil {
			return []ent.Value{*id}
		}
	case mirror.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.activities))
		for id := range m.activities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MirrorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedactivities != nil {
		edges = append(edges, mirror.EdgeActivities)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MirrorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mirror.EdgeActivities:
		ids := make([]ent.Value, 0, len(m.removedactivities))
		for id := range m.removedactivities {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MirrorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearednamespace {
		edges = append(edges, mirror.EdgeNamespace)
	}
	if m.clearedinode {
		edges = append(edges, mirror.EdgeInode)
	}
	if m.clearedactivities {
		edges = append(edges, mirror.EdgeActivities)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MirrorMutation) EdgeCleared(name string) bool {
	switch name {
	case mirror.EdgeNamespace:
		return m.clearednamespace
	case mirror.EdgeInode:
		return m.clearedinode
	case mirror.EdgeActivities:
		return m.clearedactivities
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MirrorMutation) ClearEdge(name string) error {
	switch name {
	case mirror.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case mirror.EdgeInode:
		m.ClearInode()
		return nil
	}
	return fmt.Errorf("unknown Mirror unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MirrorMutation) ResetEdge(name string) error {
	switch name {
	case mirror.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case mirror.EdgeInode:
		m.ResetInode()
		return nil
	case mirror.EdgeActivities:
		m.ResetActivities()
		return nil
	}
	return fmt.Errorf("unknown Mirror edge %s", name)
}

// MirrorActivityMutation represents an operation that mutates the MirrorActivity nodes in the graph.
type MirrorActivityMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	_type            *string
	status           *string
	created_at       *time.Time
	updated_at       *time.Time
	end_at           *time.Time
	controller       *string
	deadline         *time.Time
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	mirror           *uuid.UUID
	clearedmirror    bool
	logs             map[uuid.UUID]struct{}
	removedlogs      map[uuid.UUID]struct{}
	clearedlogs      bool
	done             bool
	oldValue         func(context.Context) (*MirrorActivity, error)
	predicates       []predicate.MirrorActivity
}

var _ ent.Mutation = (*MirrorActivityMutation)(nil)

// mirroractivityOption allows management of the mutation configuration using functional options.
type mirroractivityOption func(*MirrorActivityMutation)

// newMirrorActivityMutation creates new mutation for the MirrorActivity entity.
func newMirrorActivityMutation(c config, op Op, opts ...mirroractivityOption) *MirrorActivityMutation {
	m := &MirrorActivityMutation{
		config:        c,
		op:            op,
		typ:           TypeMirrorActivity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMirrorActivityID sets the ID field of the mutation.
func withMirrorActivityID(id uuid.UUID) mirroractivityOption {
	return func(m *MirrorActivityMutation) {
		var (
			err   error
			once  sync.Once
			value *MirrorActivity
		)
		m.oldValue = func(ctx context.Context) (*MirrorActivity, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MirrorActivity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMirrorActivity sets the old MirrorActivity of the mutation.
func withMirrorActivity(node *MirrorActivity) mirroractivityOption {
	return func(m *MirrorActivityMutation) {
		m.oldValue = func(context.Context) (*MirrorActivity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MirrorActivityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MirrorActivityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MirrorActivity entities.
func (m *MirrorActivityMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MirrorActivityMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MirrorActivityMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MirrorActivity.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *MirrorActivityMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *MirrorActivityMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the MirrorActivity entity.
// If the MirrorActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorActivityMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *MirrorActivityMutation) ResetType() {
	m._type = nil
}

// SetStatus sets the "status" field.
func (m *MirrorActivityMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *MirrorActivityMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MirrorActivity entity.
// If the MirrorActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorActivityMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *MirrorActivityMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MirrorActivityMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MirrorActivityMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MirrorActivity entity.
// If the MirrorActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorActivityMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MirrorActivityMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MirrorActivityMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MirrorActivityMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MirrorActivity entity.
// If the MirrorActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorActivityMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MirrorActivityMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *MirrorActivityMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *MirrorActivityMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the MirrorActivity entity.
// If the MirrorActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorActivityMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *MirrorActivityMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[mirroractivity.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *MirrorActivityMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[mirroractivity.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *MirrorActivityMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, mirroractivity.FieldEndAt)
}

// SetController sets the "controller" field.
func (m *MirrorActivityMutation) SetController(s string) {
	m.controller = &s
}

// Controller returns the value of the "controller" field in the mutation.
func (m *MirrorActivityMutation) Controller() (r string, exists bool) {
	v := m.controller
	if v == nil {
		return
	}
	return *v, true
}

// OldController returns the old "controller" field's value of the MirrorActivity entity.
// If the MirrorActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorActivityMutation) OldController(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldController: %w", err)
	}
	return oldValue.Controller, nil
}

// ClearController clears the value of the "controller" field.
func (m *MirrorActivityMutation) ClearController() {
	m.controller = nil
	m.clearedFields[mirroractivity.FieldController] = struct{}{}
}

// ControllerCleared returns if the "controller" field was cleared in this mutation.
func (m *MirrorActivityMutation) ControllerCleared() bool {
	_, ok := m.clearedFields[mirroractivity.FieldController]
	return ok
}

// ResetController resets all changes to the "controller" field.
func (m *MirrorActivityMutation) ResetController() {
	m.controller = nil
	delete(m.clearedFields, mirroractivity.FieldController)
}

// SetDeadline sets the "deadline" field.
func (m *MirrorActivityMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *MirrorActivityMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the MirrorActivity entity.
// If the MirrorActivity object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MirrorActivityMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ClearDeadline clears the value of the "deadline" field.
func (m *MirrorActivityMutation) ClearDeadline() {
	m.deadline = nil
	m.clearedFields[mirroractivity.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *MirrorActivityMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[mirroractivity.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *MirrorActivityMutation) ResetDeadline() {
	m.deadline = nil
	delete(m.clearedFields, mirroractivity.FieldDeadline)
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *MirrorActivityMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *MirrorActivityMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *MirrorActivityMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *MirrorActivityMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *MirrorActivityMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *MirrorActivityMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetMirrorID sets the "mirror" edge to the Mirror entity by id.
func (m *MirrorActivityMutation) SetMirrorID(id uuid.UUID) {
	m.mirror = &id
}

// ClearMirror clears the "mirror" edge to the Mirror entity.
func (m *MirrorActivityMutation) ClearMirror() {
	m.clearedmirror = true
}

// MirrorCleared reports if the "mirror" edge to the Mirror entity was cleared.
func (m *MirrorActivityMutation) MirrorCleared() bool {
	return m.clearedmirror
}

// MirrorID returns the "mirror" edge ID in the mutation.
func (m *MirrorActivityMutation) MirrorID() (id uuid.UUID, exists bool) {
	if m.mirror != nil {
		return *m.mirror, true
	}
	return
}

// MirrorIDs returns the "mirror" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MirrorID instead. It exists only for internal usage by the builders.
func (m *MirrorActivityMutation) MirrorIDs() (ids []uuid.UUID) {
	if id := m.mirror; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMirror resets all changes to the "mirror" edge.
func (m *MirrorActivityMutation) ResetMirror() {
	m.mirror = nil
	m.clearedmirror = false
}

// AddLogIDs adds the "logs" edge to the LogMsg entity by ids.
func (m *MirrorActivityMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the LogMsg entity.
func (m *MirrorActivityMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the LogMsg entity was cleared.
func (m *MirrorActivityMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the LogMsg entity by IDs.
func (m *MirrorActivityMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the LogMsg entity.
func (m *MirrorActivityMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *MirrorActivityMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *MirrorActivityMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// Where appends a list predicates to the MirrorActivityMutation builder.
func (m *MirrorActivityMutation) Where(ps ...predicate.MirrorActivity) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MirrorActivityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MirrorActivity).
func (m *MirrorActivityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MirrorActivityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._type != nil {
		fields = append(fields, mirroractivity.FieldType)
	}
	if m.status != nil {
		fields = append(fields, mirroractivity.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, mirroractivity.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mirroractivity.FieldUpdatedAt)
	}
	if m.end_at != nil {
		fields = append(fields, mirroractivity.FieldEndAt)
	}
	if m.controller != nil {
		fields = append(fields, mirroractivity.FieldController)
	}
	if m.deadline != nil {
		fields = append(fields, mirroractivity.FieldDeadline)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MirrorActivityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mirroractivity.FieldType:
		return m.GetType()
	case mirroractivity.FieldStatus:
		return m.Status()
	case mirroractivity.FieldCreatedAt:
		return m.CreatedAt()
	case mirroractivity.FieldUpdatedAt:
		return m.UpdatedAt()
	case mirroractivity.FieldEndAt:
		return m.EndAt()
	case mirroractivity.FieldController:
		return m.Controller()
	case mirroractivity.FieldDeadline:
		return m.Deadline()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MirrorActivityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mirroractivity.FieldType:
		return m.OldType(ctx)
	case mirroractivity.FieldStatus:
		return m.OldStatus(ctx)
	case mirroractivity.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mirroractivity.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mirroractivity.FieldEndAt:
		return m.OldEndAt(ctx)
	case mirroractivity.FieldController:
		return m.OldController(ctx)
	case mirroractivity.FieldDeadline:
		return m.OldDeadline(ctx)
	}
	return nil, fmt.Errorf("unknown MirrorActivity field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MirrorActivityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mirroractivity.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case mirroractivity.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case mirroractivity.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mirroractivity.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mirroractivity.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case mirroractivity.FieldController:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetController(v)
		return nil
	case mirroractivity.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	}
	return fmt.Errorf("unknown MirrorActivity field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MirrorActivityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MirrorActivityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MirrorActivityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MirrorActivity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MirrorActivityMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mirroractivity.FieldEndAt) {
		fields = append(fields, mirroractivity.FieldEndAt)
	}
	if m.FieldCleared(mirroractivity.FieldController) {
		fields = append(fields, mirroractivity.FieldController)
	}
	if m.FieldCleared(mirroractivity.FieldDeadline) {
		fields = append(fields, mirroractivity.FieldDeadline)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MirrorActivityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MirrorActivityMutation) ClearField(name string) error {
	switch name {
	case mirroractivity.FieldEndAt:
		m.ClearEndAt()
		return nil
	case mirroractivity.FieldController:
		m.ClearController()
		return nil
	case mirroractivity.FieldDeadline:
		m.ClearDeadline()
		return nil
	}
	return fmt.Errorf("unknown MirrorActivity nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MirrorActivityMutation) ResetField(name string) error {
	switch name {
	case mirroractivity.FieldType:
		m.ResetType()
		return nil
	case mirroractivity.FieldStatus:
		m.ResetStatus()
		return nil
	case mirroractivity.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mirroractivity.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mirroractivity.FieldEndAt:
		m.ResetEndAt()
		return nil
	case mirroractivity.FieldController:
		m.ResetController()
		return nil
	case mirroractivity.FieldDeadline:
		m.ResetDeadline()
		return nil
	}
	return fmt.Errorf("unknown MirrorActivity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MirrorActivityMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.namespace != nil {
		edges = append(edges, mirroractivity.EdgeNamespace)
	}
	if m.mirror != nil {
		edges = append(edges, mirroractivity.EdgeMirror)
	}
	if m.logs != nil {
		edges = append(edges, mirroractivity.EdgeLogs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MirrorActivityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mirroractivity.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case mirroractivity.EdgeMirror:
		if id := m.mirror; id != nil {
			return []ent.Value{*id}
		}
	case mirroractivity.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MirrorActivityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedlogs != nil {
		edges = append(edges, mirroractivity.EdgeLogs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MirrorActivityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case mirroractivity.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MirrorActivityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearednamespace {
		edges = append(edges, mirroractivity.EdgeNamespace)
	}
	if m.clearedmirror {
		edges = append(edges, mirroractivity.EdgeMirror)
	}
	if m.clearedlogs {
		edges = append(edges, mirroractivity.EdgeLogs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MirrorActivityMutation) EdgeCleared(name string) bool {
	switch name {
	case mirroractivity.EdgeNamespace:
		return m.clearednamespace
	case mirroractivity.EdgeMirror:
		return m.clearedmirror
	case mirroractivity.EdgeLogs:
		return m.clearedlogs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MirrorActivityMutation) ClearEdge(name string) error {
	switch name {
	case mirroractivity.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case mirroractivity.EdgeMirror:
		m.ClearMirror()
		return nil
	}
	return fmt.Errorf("unknown MirrorActivity unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MirrorActivityMutation) ResetEdge(name string) error {
	switch name {
	case mirroractivity.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case mirroractivity.EdgeMirror:
		m.ResetMirror()
		return nil
	case mirroractivity.EdgeLogs:
		m.ResetLogs()
		return nil
	}
	return fmt.Errorf("unknown MirrorActivity edge %s", name)
}

// NamespaceMutation represents an operation that mutates the Namespace nodes in the graph.
type NamespaceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	_config                   *string
	name                      *string
	clearedFields             map[string]struct{}
	inodes                    map[uuid.UUID]struct{}
	removedinodes             map[uuid.UUID]struct{}
	clearedinodes             bool
	workflows                 map[uuid.UUID]struct{}
	removedworkflows          map[uuid.UUID]struct{}
	clearedworkflows          bool
	mirrors                   map[uuid.UUID]struct{}
	removedmirrors            map[uuid.UUID]struct{}
	clearedmirrors            bool
	mirror_activities         map[uuid.UUID]struct{}
	removedmirror_activities  map[uuid.UUID]struct{}
	clearedmirror_activities  bool
	instances                 map[uuid.UUID]struct{}
	removedinstances          map[uuid.UUID]struct{}
	clearedinstances          bool
	logs                      map[uuid.UUID]struct{}
	removedlogs               map[uuid.UUID]struct{}
	clearedlogs               bool
	vars                      map[uuid.UUID]struct{}
	removedvars               map[uuid.UUID]struct{}
	clearedvars               bool
	cloudevents               map[uuid.UUID]struct{}
	removedcloudevents        map[uuid.UUID]struct{}
	clearedcloudevents        bool
	namespacelisteners        map[uuid.UUID]struct{}
	removednamespacelisteners map[uuid.UUID]struct{}
	clearednamespacelisteners bool
	cloudeventfilters         map[int]struct{}
	removedcloudeventfilters  map[int]struct{}
	clearedcloudeventfilters  bool
	services                  map[uuid.UUID]struct{}
	removedservices           map[uuid.UUID]struct{}
	clearedservices           bool
	done                      bool
	oldValue                  func(context.Context) (*Namespace, error)
	predicates                []predicate.Namespace
}

var _ ent.Mutation = (*NamespaceMutation)(nil)

// namespaceOption allows management of the mutation configuration using functional options.
type namespaceOption func(*NamespaceMutation)

// newNamespaceMutation creates new mutation for the Namespace entity.
func newNamespaceMutation(c config, op Op, opts ...namespaceOption) *NamespaceMutation {
	m := &NamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceID sets the ID field of the mutation.
func withNamespaceID(id uuid.UUID) namespaceOption {
	return func(m *NamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Namespace
		)
		m.oldValue = func(ctx context.Context) (*Namespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Namespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespace sets the old Namespace of the mutation.
func withNamespace(node *Namespace) namespaceOption {
	return func(m *NamespaceMutation) {
		m.oldValue = func(context.Context) (*Namespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Namespace entities.
func (m *NamespaceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamespaceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NamespaceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Namespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NamespaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NamespaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NamespaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NamespaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NamespaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NamespaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetConfig sets the "config" field.
func (m *NamespaceMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *NamespaceMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NamespaceMutation) ResetConfig() {
	m._config = nil
}

// SetName sets the "name" field.
func (m *NamespaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NamespaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NamespaceMutation) ResetName() {
	m.name = nil
}

// AddInodeIDs adds the "inodes" edge to the Inode entity by ids.
func (m *NamespaceMutation) AddInodeIDs(ids ...uuid.UUID) {
	if m.inodes == nil {
		m.inodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.inodes[ids[i]] = struct{}{}
	}
}

// ClearInodes clears the "inodes" edge to the Inode entity.
func (m *NamespaceMutation) ClearInodes() {
	m.clearedinodes = true
}

// InodesCleared reports if the "inodes" edge to the Inode entity was cleared.
func (m *NamespaceMutation) InodesCleared() bool {
	return m.clearedinodes
}

// RemoveInodeIDs removes the "inodes" edge to the Inode entity by IDs.
func (m *NamespaceMutation) RemoveInodeIDs(ids ...uuid.UUID) {
	if m.removedinodes == nil {
		m.removedinodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.inodes, ids[i])
		m.removedinodes[ids[i]] = struct{}{}
	}
}

// RemovedInodes returns the removed IDs of the "inodes" edge to the Inode entity.
func (m *NamespaceMutation) RemovedInodesIDs() (ids []uuid.UUID) {
	for id := range m.removedinodes {
		ids = append(ids, id)
	}
	return
}

// InodesIDs returns the "inodes" edge IDs in the mutation.
func (m *NamespaceMutation) InodesIDs() (ids []uuid.UUID) {
	for id := range m.inodes {
		ids = append(ids, id)
	}
	return
}

// ResetInodes resets all changes to the "inodes" edge.
func (m *NamespaceMutation) ResetInodes() {
	m.inodes = nil
	m.clearedinodes = false
	m.removedinodes = nil
}

// AddWorkflowIDs adds the "workflows" edge to the Workflow entity by ids.
func (m *NamespaceMutation) AddWorkflowIDs(ids ...uuid.UUID) {
	if m.workflows == nil {
		m.workflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflow entity.
func (m *NamespaceMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflow entity was cleared.
func (m *NamespaceMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflow entity by IDs.
func (m *NamespaceMutation) RemoveWorkflowIDs(ids ...uuid.UUID) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflow entity.
func (m *NamespaceMutation) RemovedWorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *NamespaceMutation) WorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *NamespaceMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// AddMirrorIDs adds the "mirrors" edge to the Mirror entity by ids.
func (m *NamespaceMutation) AddMirrorIDs(ids ...uuid.UUID) {
	if m.mirrors == nil {
		m.mirrors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.mirrors[ids[i]] = struct{}{}
	}
}

// ClearMirrors clears the "mirrors" edge to the Mirror entity.
func (m *NamespaceMutation) ClearMirrors() {
	m.clearedmirrors = true
}

// MirrorsCleared reports if the "mirrors" edge to the Mirror entity was cleared.
func (m *NamespaceMutation) MirrorsCleared() bool {
	return m.clearedmirrors
}

// RemoveMirrorIDs removes the "mirrors" edge to the Mirror entity by IDs.
func (m *NamespaceMutation) RemoveMirrorIDs(ids ...uuid.UUID) {
	if m.removedmirrors == nil {
		m.removedmirrors = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.mirrors, ids[i])
		m.removedmirrors[ids[i]] = struct{}{}
	}
}

// RemovedMirrors returns the removed IDs of the "mirrors" edge to the Mirror entity.
func (m *NamespaceMutation) RemovedMirrorsIDs() (ids []uuid.UUID) {
	for id := range m.removedmirrors {
		ids = append(ids, id)
	}
	return
}

// MirrorsIDs returns the "mirrors" edge IDs in the mutation.
func (m *NamespaceMutation) MirrorsIDs() (ids []uuid.UUID) {
	for id := range m.mirrors {
		ids = append(ids, id)
	}
	return
}

// ResetMirrors resets all changes to the "mirrors" edge.
func (m *NamespaceMutation) ResetMirrors() {
	m.mirrors = nil
	m.clearedmirrors = false
	m.removedmirrors = nil
}

// AddMirrorActivityIDs adds the "mirror_activities" edge to the MirrorActivity entity by ids.
func (m *NamespaceMutation) AddMirrorActivityIDs(ids ...uuid.UUID) {
	if m.mirror_activities == nil {
		m.mirror_activities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.mirror_activities[ids[i]] = struct{}{}
	}
}

// ClearMirrorActivities clears the "mirror_activities" edge to the MirrorActivity entity.
func (m *NamespaceMutation) ClearMirrorActivities() {
	m.clearedmirror_activities = true
}

// MirrorActivitiesCleared reports if the "mirror_activities" edge to the MirrorActivity entity was cleared.
func (m *NamespaceMutation) MirrorActivitiesCleared() bool {
	return m.clearedmirror_activities
}

// RemoveMirrorActivityIDs removes the "mirror_activities" edge to the MirrorActivity entity by IDs.
func (m *NamespaceMutation) RemoveMirrorActivityIDs(ids ...uuid.UUID) {
	if m.removedmirror_activities == nil {
		m.removedmirror_activities = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.mirror_activities, ids[i])
		m.removedmirror_activities[ids[i]] = struct{}{}
	}
}

// RemovedMirrorActivities returns the removed IDs of the "mirror_activities" edge to the MirrorActivity entity.
func (m *NamespaceMutation) RemovedMirrorActivitiesIDs() (ids []uuid.UUID) {
	for id := range m.removedmirror_activities {
		ids = append(ids, id)
	}
	return
}

// MirrorActivitiesIDs returns the "mirror_activities" edge IDs in the mutation.
func (m *NamespaceMutation) MirrorActivitiesIDs() (ids []uuid.UUID) {
	for id := range m.mirror_activities {
		ids = append(ids, id)
	}
	return
}

// ResetMirrorActivities resets all changes to the "mirror_activities" edge.
func (m *NamespaceMutation) ResetMirrorActivities() {
	m.mirror_activities = nil
	m.clearedmirror_activities = false
	m.removedmirror_activities = nil
}

// AddInstanceIDs adds the "instances" edge to the Instance entity by ids.
func (m *NamespaceMutation) AddInstanceIDs(ids ...uuid.UUID) {
	if m.instances == nil {
		m.instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the Instance entity.
func (m *NamespaceMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the Instance entity was cleared.
func (m *NamespaceMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the Instance entity by IDs.
func (m *NamespaceMutation) RemoveInstanceIDs(ids ...uuid.UUID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the Instance entity.
func (m *NamespaceMutation) RemovedInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *NamespaceMutation) InstancesIDs() (ids []uuid.UUID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *NamespaceMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// AddLogIDs adds the "logs" edge to the LogMsg entity by ids.
func (m *NamespaceMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the LogMsg entity.
func (m *NamespaceMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the LogMsg entity was cleared.
func (m *NamespaceMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the LogMsg entity by IDs.
func (m *NamespaceMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the LogMsg entity.
func (m *NamespaceMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *NamespaceMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *NamespaceMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddVarIDs adds the "vars" edge to the VarRef entity by ids.
func (m *NamespaceMutation) AddVarIDs(ids ...uuid.UUID) {
	if m.vars == nil {
		m.vars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vars[ids[i]] = struct{}{}
	}
}

// ClearVars clears the "vars" edge to the VarRef entity.
func (m *NamespaceMutation) ClearVars() {
	m.clearedvars = true
}

// VarsCleared reports if the "vars" edge to the VarRef entity was cleared.
func (m *NamespaceMutation) VarsCleared() bool {
	return m.clearedvars
}

// RemoveVarIDs removes the "vars" edge to the VarRef entity by IDs.
func (m *NamespaceMutation) RemoveVarIDs(ids ...uuid.UUID) {
	if m.removedvars == nil {
		m.removedvars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vars, ids[i])
		m.removedvars[ids[i]] = struct{}{}
	}
}

// RemovedVars returns the removed IDs of the "vars" edge to the VarRef entity.
func (m *NamespaceMutation) RemovedVarsIDs() (ids []uuid.UUID) {
	for id := range m.removedvars {
		ids = append(ids, id)
	}
	return
}

// VarsIDs returns the "vars" edge IDs in the mutation.
func (m *NamespaceMutation) VarsIDs() (ids []uuid.UUID) {
	for id := range m.vars {
		ids = append(ids, id)
	}
	return
}

// ResetVars resets all changes to the "vars" edge.
func (m *NamespaceMutation) ResetVars() {
	m.vars = nil
	m.clearedvars = false
	m.removedvars = nil
}

// AddCloudeventIDs adds the "cloudevents" edge to the CloudEvents entity by ids.
func (m *NamespaceMutation) AddCloudeventIDs(ids ...uuid.UUID) {
	if m.cloudevents == nil {
		m.cloudevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cloudevents[ids[i]] = struct{}{}
	}
}

// ClearCloudevents clears the "cloudevents" edge to the CloudEvents entity.
func (m *NamespaceMutation) ClearCloudevents() {
	m.clearedcloudevents = true
}

// CloudeventsCleared reports if the "cloudevents" edge to the CloudEvents entity was cleared.
func (m *NamespaceMutation) CloudeventsCleared() bool {
	return m.clearedcloudevents
}

// RemoveCloudeventIDs removes the "cloudevents" edge to the CloudEvents entity by IDs.
func (m *NamespaceMutation) RemoveCloudeventIDs(ids ...uuid.UUID) {
	if m.removedcloudevents == nil {
		m.removedcloudevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cloudevents, ids[i])
		m.removedcloudevents[ids[i]] = struct{}{}
	}
}

// RemovedCloudevents returns the removed IDs of the "cloudevents" edge to the CloudEvents entity.
func (m *NamespaceMutation) RemovedCloudeventsIDs() (ids []uuid.UUID) {
	for id := range m.removedcloudevents {
		ids = append(ids, id)
	}
	return
}

// CloudeventsIDs returns the "cloudevents" edge IDs in the mutation.
func (m *NamespaceMutation) CloudeventsIDs() (ids []uuid.UUID) {
	for id := range m.cloudevents {
		ids = append(ids, id)
	}
	return
}

// ResetCloudevents resets all changes to the "cloudevents" edge.
func (m *NamespaceMutation) ResetCloudevents() {
	m.cloudevents = nil
	m.clearedcloudevents = false
	m.removedcloudevents = nil
}

// AddNamespacelistenerIDs adds the "namespacelisteners" edge to the Events entity by ids.
func (m *NamespaceMutation) AddNamespacelistenerIDs(ids ...uuid.UUID) {
	if m.namespacelisteners == nil {
		m.namespacelisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.namespacelisteners[ids[i]] = struct{}{}
	}
}

// ClearNamespacelisteners clears the "namespacelisteners" edge to the Events entity.
func (m *NamespaceMutation) ClearNamespacelisteners() {
	m.clearednamespacelisteners = true
}

// NamespacelistenersCleared reports if the "namespacelisteners" edge to the Events entity was cleared.
func (m *NamespaceMutation) NamespacelistenersCleared() bool {
	return m.clearednamespacelisteners
}

// RemoveNamespacelistenerIDs removes the "namespacelisteners" edge to the Events entity by IDs.
func (m *NamespaceMutation) RemoveNamespacelistenerIDs(ids ...uuid.UUID) {
	if m.removednamespacelisteners == nil {
		m.removednamespacelisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.namespacelisteners, ids[i])
		m.removednamespacelisteners[ids[i]] = struct{}{}
	}
}

// RemovedNamespacelisteners returns the removed IDs of the "namespacelisteners" edge to the Events entity.
func (m *NamespaceMutation) RemovedNamespacelistenersIDs() (ids []uuid.UUID) {
	for id := range m.removednamespacelisteners {
		ids = append(ids, id)
	}
	return
}

// NamespacelistenersIDs returns the "namespacelisteners" edge IDs in the mutation.
func (m *NamespaceMutation) NamespacelistenersIDs() (ids []uuid.UUID) {
	for id := range m.namespacelisteners {
		ids = append(ids, id)
	}
	return
}

// ResetNamespacelisteners resets all changes to the "namespacelisteners" edge.
func (m *NamespaceMutation) ResetNamespacelisteners() {
	m.namespacelisteners = nil
	m.clearednamespacelisteners = false
	m.removednamespacelisteners = nil
}

// AddCloudeventfilterIDs adds the "cloudeventfilters" edge to the CloudEventFilters entity by ids.
func (m *NamespaceMutation) AddCloudeventfilterIDs(ids ...int) {
	if m.cloudeventfilters == nil {
		m.cloudeventfilters = make(map[int]struct{})
	}
	for i := range ids {
		m.cloudeventfilters[ids[i]] = struct{}{}
	}
}

// ClearCloudeventfilters clears the "cloudeventfilters" edge to the CloudEventFilters entity.
func (m *NamespaceMutation) ClearCloudeventfilters() {
	m.clearedcloudeventfilters = true
}

// CloudeventfiltersCleared reports if the "cloudeventfilters" edge to the CloudEventFilters entity was cleared.
func (m *NamespaceMutation) CloudeventfiltersCleared() bool {
	return m.clearedcloudeventfilters
}

// RemoveCloudeventfilterIDs removes the "cloudeventfilters" edge to the CloudEventFilters entity by IDs.
func (m *NamespaceMutation) RemoveCloudeventfilterIDs(ids ...int) {
	if m.removedcloudeventfilters == nil {
		m.removedcloudeventfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cloudeventfilters, ids[i])
		m.removedcloudeventfilters[ids[i]] = struct{}{}
	}
}

// RemovedCloudeventfilters returns the removed IDs of the "cloudeventfilters" edge to the CloudEventFilters entity.
func (m *NamespaceMutation) RemovedCloudeventfiltersIDs() (ids []int) {
	for id := range m.removedcloudeventfilters {
		ids = append(ids, id)
	}
	return
}

// CloudeventfiltersIDs returns the "cloudeventfilters" edge IDs in the mutation.
func (m *NamespaceMutation) CloudeventfiltersIDs() (ids []int) {
	for id := range m.cloudeventfilters {
		ids = append(ids, id)
	}
	return
}

// ResetCloudeventfilters resets all changes to the "cloudeventfilters" edge.
func (m *NamespaceMutation) ResetCloudeventfilters() {
	m.cloudeventfilters = nil
	m.clearedcloudeventfilters = false
	m.removedcloudeventfilters = nil
}

// AddServiceIDs adds the "services" edge to the Services entity by ids.
func (m *NamespaceMutation) AddServiceIDs(ids ...uuid.UUID) {
	if m.services == nil {
		m.services = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Services entity.
func (m *NamespaceMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Services entity was cleared.
func (m *NamespaceMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Services entity by IDs.
func (m *NamespaceMutation) RemoveServiceIDs(ids ...uuid.UUID) {
	if m.removedservices == nil {
		m.removedservices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Services entity.
func (m *NamespaceMutation) RemovedServicesIDs() (ids []uuid.UUID) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *NamespaceMutation) ServicesIDs() (ids []uuid.UUID) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *NamespaceMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// Where appends a list predicates to the NamespaceMutation builder.
func (m *NamespaceMutation) Where(ps ...predicate.Namespace) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NamespaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Namespace).
func (m *NamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamespaceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, namespace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, namespace.FieldUpdatedAt)
	}
	if m._config != nil {
		fields = append(fields, namespace.FieldConfig)
	}
	if m.name != nil {
		fields = append(fields, namespace.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.CreatedAt()
	case namespace.FieldUpdatedAt:
		return m.UpdatedAt()
	case namespace.FieldConfig:
		return m.Config()
	case namespace.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case namespace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case namespace.FieldConfig:
		return m.OldConfig(ctx)
	case namespace.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Namespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case namespace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case namespace.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case namespace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamespaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamespaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Namespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamespaceMutation) ResetField(name string) error {
	switch name {
	case namespace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case namespace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case namespace.FieldConfig:
		m.ResetConfig()
		return nil
	case namespace.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 11)
	if m.inodes != nil {
		edges = append(edges, namespace.EdgeInodes)
	}
	if m.workflows != nil {
		edges = append(edges, namespace.EdgeWorkflows)
	}
	if m.mirrors != nil {
		edges = append(edges, namespace.EdgeMirrors)
	}
	if m.mirror_activities != nil {
		edges = append(edges, namespace.EdgeMirrorActivities)
	}
	if m.instances != nil {
		edges = append(edges, namespace.EdgeInstances)
	}
	if m.logs != nil {
		edges = append(edges, namespace.EdgeLogs)
	}
	if m.vars != nil {
		edges = append(edges, namespace.EdgeVars)
	}
	if m.cloudevents != nil {
		edges = append(edges, namespace.EdgeCloudevents)
	}
	if m.namespacelisteners != nil {
		edges = append(edges, namespace.EdgeNamespacelisteners)
	}
	if m.cloudeventfilters != nil {
		edges = append(edges, namespace.EdgeCloudeventfilters)
	}
	if m.services != nil {
		edges = append(edges, namespace.EdgeServices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeInodes:
		ids := make([]ent.Value, 0, len(m.inodes))
		for id := range m.inodes {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeMirrors:
		ids := make([]ent.Value, 0, len(m.mirrors))
		for id := range m.mirrors {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeMirrorActivities:
		ids := make([]ent.Value, 0, len(m.mirror_activities))
		for id := range m.mirror_activities {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeVars:
		ids := make([]ent.Value, 0, len(m.vars))
		for id := range m.vars {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudevents:
		ids := make([]ent.Value, 0, len(m.cloudevents))
		for id := range m.cloudevents {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeNamespacelisteners:
		ids := make([]ent.Value, 0, len(m.namespacelisteners))
		for id := range m.namespacelisteners {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudeventfilters:
		ids := make([]ent.Value, 0, len(m.cloudeventfilters))
		for id := range m.cloudeventfilters {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 11)
	if m.removedinodes != nil {
		edges = append(edges, namespace.EdgeInodes)
	}
	if m.removedworkflows != nil {
		edges = append(edges, namespace.EdgeWorkflows)
	}
	if m.removedmirrors != nil {
		edges = append(edges, namespace.EdgeMirrors)
	}
	if m.removedmirror_activities != nil {
		edges = append(edges, namespace.EdgeMirrorActivities)
	}
	if m.removedinstances != nil {
		edges = append(edges, namespace.EdgeInstances)
	}
	if m.removedlogs != nil {
		edges = append(edges, namespace.EdgeLogs)
	}
	if m.removedvars != nil {
		edges = append(edges, namespace.EdgeVars)
	}
	if m.removedcloudevents != nil {
		edges = append(edges, namespace.EdgeCloudevents)
	}
	if m.removednamespacelisteners != nil {
		edges = append(edges, namespace.EdgeNamespacelisteners)
	}
	if m.removedcloudeventfilters != nil {
		edges = append(edges, namespace.EdgeCloudeventfilters)
	}
	if m.removedservices != nil {
		edges = append(edges, namespace.EdgeServices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeInodes:
		ids := make([]ent.Value, 0, len(m.removedinodes))
		for id := range m.removedinodes {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeMirrors:
		ids := make([]ent.Value, 0, len(m.removedmirrors))
		for id := range m.removedmirrors {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeMirrorActivities:
		ids := make([]ent.Value, 0, len(m.removedmirror_activities))
		for id := range m.removedmirror_activities {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeVars:
		ids := make([]ent.Value, 0, len(m.removedvars))
		for id := range m.removedvars {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudevents:
		ids := make([]ent.Value, 0, len(m.removedcloudevents))
		for id := range m.removedcloudevents {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeNamespacelisteners:
		ids := make([]ent.Value, 0, len(m.removednamespacelisteners))
		for id := range m.removednamespacelisteners {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudeventfilters:
		ids := make([]ent.Value, 0, len(m.removedcloudeventfilters))
		for id := range m.removedcloudeventfilters {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 11)
	if m.clearedinodes {
		edges = append(edges, namespace.EdgeInodes)
	}
	if m.clearedworkflows {
		edges = append(edges, namespace.EdgeWorkflows)
	}
	if m.clearedmirrors {
		edges = append(edges, namespace.EdgeMirrors)
	}
	if m.clearedmirror_activities {
		edges = append(edges, namespace.EdgeMirrorActivities)
	}
	if m.clearedinstances {
		edges = append(edges, namespace.EdgeInstances)
	}
	if m.clearedlogs {
		edges = append(edges, namespace.EdgeLogs)
	}
	if m.clearedvars {
		edges = append(edges, namespace.EdgeVars)
	}
	if m.clearedcloudevents {
		edges = append(edges, namespace.EdgeCloudevents)
	}
	if m.clearednamespacelisteners {
		edges = append(edges, namespace.EdgeNamespacelisteners)
	}
	if m.clearedcloudeventfilters {
		edges = append(edges, namespace.EdgeCloudeventfilters)
	}
	if m.clearedservices {
		edges = append(edges, namespace.EdgeServices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case namespace.EdgeInodes:
		return m.clearedinodes
	case namespace.EdgeWorkflows:
		return m.clearedworkflows
	case namespace.EdgeMirrors:
		return m.clearedmirrors
	case namespace.EdgeMirrorActivities:
		return m.clearedmirror_activities
	case namespace.EdgeInstances:
		return m.clearedinstances
	case namespace.EdgeLogs:
		return m.clearedlogs
	case namespace.EdgeVars:
		return m.clearedvars
	case namespace.EdgeCloudevents:
		return m.clearedcloudevents
	case namespace.EdgeNamespacelisteners:
		return m.clearednamespacelisteners
	case namespace.EdgeCloudeventfilters:
		return m.clearedcloudeventfilters
	case namespace.EdgeServices:
		return m.clearedservices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamespaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamespaceMutation) ResetEdge(name string) error {
	switch name {
	case namespace.EdgeInodes:
		m.ResetInodes()
		return nil
	case namespace.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	case namespace.EdgeMirrors:
		m.ResetMirrors()
		return nil
	case namespace.EdgeMirrorActivities:
		m.ResetMirrorActivities()
		return nil
	case namespace.EdgeInstances:
		m.ResetInstances()
		return nil
	case namespace.EdgeLogs:
		m.ResetLogs()
		return nil
	case namespace.EdgeVars:
		m.ResetVars()
		return nil
	case namespace.EdgeCloudevents:
		m.ResetCloudevents()
		return nil
	case namespace.EdgeNamespacelisteners:
		m.ResetNamespacelisteners()
		return nil
	case namespace.EdgeCloudeventfilters:
		m.ResetCloudeventfilters()
		return nil
	case namespace.EdgeServices:
		m.ResetServices()
		return nil
	}
	return fmt.Errorf("unknown Namespace edge %s", name)
}

// RefMutation represents an operation that mutates the Ref nodes in the graph.
type RefMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	immutable       *bool
	name            *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	workflow        *uuid.UUID
	clearedworkflow bool
	revision        *uuid.UUID
	clearedrevision bool
	routes          map[uuid.UUID]struct{}
	removedroutes   map[uuid.UUID]struct{}
	clearedroutes   bool
	done            bool
	oldValue        func(context.Context) (*Ref, error)
	predicates      []predicate.Ref
}

var _ ent.Mutation = (*RefMutation)(nil)

// refOption allows management of the mutation configuration using functional options.
type refOption func(*RefMutation)

// newRefMutation creates new mutation for the Ref entity.
func newRefMutation(c config, op Op, opts ...refOption) *RefMutation {
	m := &RefMutation{
		config:        c,
		op:            op,
		typ:           TypeRef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRefID sets the ID field of the mutation.
func withRefID(id uuid.UUID) refOption {
	return func(m *RefMutation) {
		var (
			err   error
			once  sync.Once
			value *Ref
		)
		m.oldValue = func(ctx context.Context) (*Ref, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ref.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRef sets the old Ref of the mutation.
func withRef(node *Ref) refOption {
	return func(m *RefMutation) {
		m.oldValue = func(context.Context) (*Ref, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ref entities.
func (m *RefMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RefMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RefMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ref.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImmutable sets the "immutable" field.
func (m *RefMutation) SetImmutable(b bool) {
	m.immutable = &b
}

// Immutable returns the value of the "immutable" field in the mutation.
func (m *RefMutation) Immutable() (r bool, exists bool) {
	v := m.immutable
	if v == nil {
		return
	}
	return *v, true
}

// OldImmutable returns the old "immutable" field's value of the Ref entity.
// If the Ref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefMutation) OldImmutable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImmutable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImmutable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImmutable: %w", err)
	}
	return oldValue.Immutable, nil
}

// ResetImmutable resets all changes to the "immutable" field.
func (m *RefMutation) ResetImmutable() {
	m.immutable = nil
}

// SetName sets the "name" field.
func (m *RefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ref entity.
// If the Ref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RefMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RefMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RefMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ref entity.
// If the Ref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RefMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *RefMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *RefMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *RefMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *RefMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *RefMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *RefMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetRevisionID sets the "revision" edge to the Revision entity by id.
func (m *RefMutation) SetRevisionID(id uuid.UUID) {
	m.revision = &id
}

// ClearRevision clears the "revision" edge to the Revision entity.
func (m *RefMutation) ClearRevision() {
	m.clearedrevision = true
}

// RevisionCleared reports if the "revision" edge to the Revision entity was cleared.
func (m *RefMutation) RevisionCleared() bool {
	return m.clearedrevision
}

// RevisionID returns the "revision" edge ID in the mutation.
func (m *RefMutation) RevisionID() (id uuid.UUID, exists bool) {
	if m.revision != nil {
		return *m.revision, true
	}
	return
}

// RevisionIDs returns the "revision" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevisionID instead. It exists only for internal usage by the builders.
func (m *RefMutation) RevisionIDs() (ids []uuid.UUID) {
	if id := m.revision; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevision resets all changes to the "revision" edge.
func (m *RefMutation) ResetRevision() {
	m.revision = nil
	m.clearedrevision = false
}

// AddRouteIDs adds the "routes" edge to the Route entity by ids.
func (m *RefMutation) AddRouteIDs(ids ...uuid.UUID) {
	if m.routes == nil {
		m.routes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.routes[ids[i]] = struct{}{}
	}
}

// ClearRoutes clears the "routes" edge to the Route entity.
func (m *RefMutation) ClearRoutes() {
	m.clearedroutes = true
}

// RoutesCleared reports if the "routes" edge to the Route entity was cleared.
func (m *RefMutation) RoutesCleared() bool {
	return m.clearedroutes
}

// RemoveRouteIDs removes the "routes" edge to the Route entity by IDs.
func (m *RefMutation) RemoveRouteIDs(ids ...uuid.UUID) {
	if m.removedroutes == nil {
		m.removedroutes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.routes, ids[i])
		m.removedroutes[ids[i]] = struct{}{}
	}
}

// RemovedRoutes returns the removed IDs of the "routes" edge to the Route entity.
func (m *RefMutation) RemovedRoutesIDs() (ids []uuid.UUID) {
	for id := range m.removedroutes {
		ids = append(ids, id)
	}
	return
}

// RoutesIDs returns the "routes" edge IDs in the mutation.
func (m *RefMutation) RoutesIDs() (ids []uuid.UUID) {
	for id := range m.routes {
		ids = append(ids, id)
	}
	return
}

// ResetRoutes resets all changes to the "routes" edge.
func (m *RefMutation) ResetRoutes() {
	m.routes = nil
	m.clearedroutes = false
	m.removedroutes = nil
}

// Where appends a list predicates to the RefMutation builder.
func (m *RefMutation) Where(ps ...predicate.Ref) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RefMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ref).
func (m *RefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RefMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.immutable != nil {
		fields = append(fields, ref.FieldImmutable)
	}
	if m.name != nil {
		fields = append(fields, ref.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, ref.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ref.FieldImmutable:
		return m.Immutable()
	case ref.FieldName:
		return m.Name()
	case ref.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ref.FieldImmutable:
		return m.OldImmutable(ctx)
	case ref.FieldName:
		return m.OldName(ctx)
	case ref.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ref field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ref.FieldImmutable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImmutable(v)
		return nil
	case ref.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ref.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ref field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RefMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RefMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ref numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RefMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RefMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ref nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RefMutation) ResetField(name string) error {
	switch name {
	case ref.FieldImmutable:
		m.ResetImmutable()
		return nil
	case ref.FieldName:
		m.ResetName()
		return nil
	case ref.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ref field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RefMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workflow != nil {
		edges = append(edges, ref.EdgeWorkflow)
	}
	if m.revision != nil {
		edges = append(edges, ref.EdgeRevision)
	}
	if m.routes != nil {
		edges = append(edges, ref.EdgeRoutes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ref.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case ref.EdgeRevision:
		if id := m.revision; id != nil {
			return []ent.Value{*id}
		}
	case ref.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.routes))
		for id := range m.routes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedroutes != nil {
		edges = append(edges, ref.EdgeRoutes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RefMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ref.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.removedroutes))
		for id := range m.removedroutes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkflow {
		edges = append(edges, ref.EdgeWorkflow)
	}
	if m.clearedrevision {
		edges = append(edges, ref.EdgeRevision)
	}
	if m.clearedroutes {
		edges = append(edges, ref.EdgeRoutes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RefMutation) EdgeCleared(name string) bool {
	switch name {
	case ref.EdgeWorkflow:
		return m.clearedworkflow
	case ref.EdgeRevision:
		return m.clearedrevision
	case ref.EdgeRoutes:
		return m.clearedroutes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RefMutation) ClearEdge(name string) error {
	switch name {
	case ref.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case ref.EdgeRevision:
		m.ClearRevision()
		return nil
	}
	return fmt.Errorf("unknown Ref unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RefMutation) ResetEdge(name string) error {
	switch name {
	case ref.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case ref.EdgeRevision:
		m.ResetRevision()
		return nil
	case ref.EdgeRoutes:
		m.ResetRoutes()
		return nil
	}
	return fmt.Errorf("unknown Ref edge %s", name)
}

// RevisionMutation represents an operation that mutates the Revision nodes in the graph.
type RevisionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	hash             *string
	source           *[]byte
	metadata         *map[string]interface{}
	clearedFields    map[string]struct{}
	workflow         *uuid.UUID
	clearedworkflow  bool
	refs             map[uuid.UUID]struct{}
	removedrefs      map[uuid.UUID]struct{}
	clearedrefs      bool
	instances        map[uuid.UUID]struct{}
	removedinstances map[uuid.UUID]struct{}
	clearedinstances bool
	done             bool
	oldValue         func(context.Context) (*Revision, error)
	predicates       []predicate.Revision
}

var _ ent.Mutation = (*RevisionMutation)(nil)

// revisionOption allows management of the mutation configuration using functional options.
type revisionOption func(*RevisionMutation)

// newRevisionMutation creates new mutation for the Revision entity.
func newRevisionMutation(c config, op Op, opts ...revisionOption) *RevisionMutation {
	m := &RevisionMutation{
		config:        c,
		op:            op,
		typ:           TypeRevision,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevisionID sets the ID field of the mutation.
func withRevisionID(id uuid.UUID) revisionOption {
	return func(m *RevisionMutation) {
		var (
			err   error
			once  sync.Once
			value *Revision
		)
		m.oldValue = func(ctx context.Context) (*Revision, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Revision.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevision sets the old Revision of the mutation.
func withRevision(node *Revision) revisionOption {
	return func(m *RevisionMutation) {
		m.oldValue = func(context.Context) (*Revision, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevisionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevisionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Revision entities.
func (m *RevisionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevisionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevisionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Revision.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RevisionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RevisionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RevisionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetHash sets the "hash" field.
func (m *RevisionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *RevisionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *RevisionMutation) ResetHash() {
	m.hash = nil
}

// SetSource sets the "source" field.
func (m *RevisionMutation) SetSource(b []byte) {
	m.source = &b
}

// Source returns the value of the "source" field in the mutation.
func (m *RevisionMutation) Source() (r []byte, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldSource(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *RevisionMutation) ResetSource() {
	m.source = nil
}

// SetMetadata sets the "metadata" field.
func (m *RevisionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *RevisionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *RevisionMutation) ResetMetadata() {
	m.metadata = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *RevisionMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *RevisionMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *RevisionMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *RevisionMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *RevisionMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *RevisionMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddRefIDs adds the "refs" edge to the Ref entity by ids.
func (m *RevisionMutation) AddRefIDs(ids ...uuid.UUID) {
	if m.refs == nil {
		m.refs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.refs[ids[i]] = struct{}{}
	}
}

// ClearRefs clears the "refs" edge to the Ref entity.
func (m *RevisionMutation) ClearRefs() {
	m.clearedrefs = true
}

// RefsCleared reports if the "refs" edge to the Ref entity was cleared.
func (m *RevisionMutation) RefsCleared() bool {
	return m.clearedrefs
}

// RemoveRefIDs removes the "refs" edge to the Ref entity by IDs.
func (m *RevisionMutation) RemoveRefIDs(ids ...uuid.UUID) {
	if m.removedrefs == nil {
		m.removedrefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.refs, ids[i])
		m.removedrefs[ids[i]] = struct{}{}
	}
}

// RemovedRefs returns the removed IDs of the "refs" edge to the Ref entity.
func (m *RevisionMutation) RemovedRefsIDs() (ids []uuid.UUID) {
	for id := range m.removedrefs {
		ids = append(ids, id)
	}
	return
}

// RefsIDs returns the "refs" edge IDs in the mutation.
func (m *RevisionMutation) RefsIDs() (ids []uuid.UUID) {
	for id := range m.refs {
		ids = append(ids, id)
	}
	return
}

// ResetRefs resets all changes to the "refs" edge.
func (m *RevisionMutation) ResetRefs() {
	m.refs = nil
	m.clearedrefs = false
	m.removedrefs = nil
}

// AddInstanceIDs adds the "instances" edge to the Instance entity by ids.
func (m *RevisionMutation) AddInstanceIDs(ids ...uuid.UUID) {
	if m.instances == nil {
		m.instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the Instance entity.
func (m *RevisionMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the Instance entity was cleared.
func (m *RevisionMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the Instance entity by IDs.
func (m *RevisionMutation) RemoveInstanceIDs(ids ...uuid.UUID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the Instance entity.
func (m *RevisionMutation) RemovedInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *RevisionMutation) InstancesIDs() (ids []uuid.UUID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *RevisionMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// Where appends a list predicates to the RevisionMutation builder.
func (m *RevisionMutation) Where(ps ...predicate.Revision) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RevisionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Revision).
func (m *RevisionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevisionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, revision.FieldCreatedAt)
	}
	if m.hash != nil {
		fields = append(fields, revision.FieldHash)
	}
	if m.source != nil {
		fields = append(fields, revision.FieldSource)
	}
	if m.metadata != nil {
		fields = append(fields, revision.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevisionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revision.FieldCreatedAt:
		return m.CreatedAt()
	case revision.FieldHash:
		return m.Hash()
	case revision.FieldSource:
		return m.Source()
	case revision.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevisionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revision.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case revision.FieldHash:
		return m.OldHash(ctx)
	case revision.FieldSource:
		return m.OldSource(ctx)
	case revision.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Revision field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevisionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revision.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case revision.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case revision.FieldSource:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case revision.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Revision field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevisionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevisionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevisionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Revision numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevisionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevisionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevisionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Revision nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevisionMutation) ResetField(name string) error {
	switch name {
	case revision.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case revision.FieldHash:
		m.ResetHash()
		return nil
	case revision.FieldSource:
		m.ResetSource()
		return nil
	case revision.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Revision field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevisionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workflow != nil {
		edges = append(edges, revision.EdgeWorkflow)
	}
	if m.refs != nil {
		edges = append(edges, revision.EdgeRefs)
	}
	if m.instances != nil {
		edges = append(edges, revision.EdgeInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevisionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case revision.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case revision.EdgeRefs:
		ids := make([]ent.Value, 0, len(m.refs))
		for id := range m.refs {
			ids = append(ids, id)
		}
		return ids
	case revision.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevisionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrefs != nil {
		edges = append(edges, revision.EdgeRefs)
	}
	if m.removedinstances != nil {
		edges = append(edges, revision.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevisionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case revision.EdgeRefs:
		ids := make([]ent.Value, 0, len(m.removedrefs))
		for id := range m.removedrefs {
			ids = append(ids, id)
		}
		return ids
	case revision.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevisionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkflow {
		edges = append(edges, revision.EdgeWorkflow)
	}
	if m.clearedrefs {
		edges = append(edges, revision.EdgeRefs)
	}
	if m.clearedinstances {
		edges = append(edges, revision.EdgeInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevisionMutation) EdgeCleared(name string) bool {
	switch name {
	case revision.EdgeWorkflow:
		return m.clearedworkflow
	case revision.EdgeRefs:
		return m.clearedrefs
	case revision.EdgeInstances:
		return m.clearedinstances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevisionMutation) ClearEdge(name string) error {
	switch name {
	case revision.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown Revision unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevisionMutation) ResetEdge(name string) error {
	switch name {
	case revision.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case revision.EdgeRefs:
		m.ResetRefs()
		return nil
	case revision.EdgeInstances:
		m.ResetInstances()
		return nil
	}
	return fmt.Errorf("unknown Revision edge %s", name)
}

// RouteMutation represents an operation that mutates the Route nodes in the graph.
type RouteMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	weight          *int
	addweight       *int
	clearedFields   map[string]struct{}
	workflow        *uuid.UUID
	clearedworkflow bool
	ref             *uuid.UUID
	clearedref      bool
	done            bool
	oldValue        func(context.Context) (*Route, error)
	predicates      []predicate.Route
}

var _ ent.Mutation = (*RouteMutation)(nil)

// routeOption allows management of the mutation configuration using functional options.
type routeOption func(*RouteMutation)

// newRouteMutation creates new mutation for the Route entity.
func newRouteMutation(c config, op Op, opts ...routeOption) *RouteMutation {
	m := &RouteMutation{
		config:        c,
		op:            op,
		typ:           TypeRoute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouteID sets the ID field of the mutation.
func withRouteID(id uuid.UUID) routeOption {
	return func(m *RouteMutation) {
		var (
			err   error
			once  sync.Once
			value *Route
		)
		m.oldValue = func(ctx context.Context) (*Route, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Route.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoute sets the old Route of the mutation.
func withRoute(node *Route) routeOption {
	return func(m *RouteMutation) {
		m.oldValue = func(context.Context) (*Route, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Route entities.
func (m *RouteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Route.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWeight sets the "weight" field.
func (m *RouteMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *RouteMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *RouteMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *RouteMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *RouteMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *RouteMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *RouteMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *RouteMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *RouteMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *RouteMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *RouteMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetRefID sets the "ref" edge to the Ref entity by id.
func (m *RouteMutation) SetRefID(id uuid.UUID) {
	m.ref = &id
}

// ClearRef clears the "ref" edge to the Ref entity.
func (m *RouteMutation) ClearRef() {
	m.clearedref = true
}

// RefCleared reports if the "ref" edge to the Ref entity was cleared.
func (m *RouteMutation) RefCleared() bool {
	return m.clearedref
}

// RefID returns the "ref" edge ID in the mutation.
func (m *RouteMutation) RefID() (id uuid.UUID, exists bool) {
	if m.ref != nil {
		return *m.ref, true
	}
	return
}

// RefIDs returns the "ref" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RefID instead. It exists only for internal usage by the builders.
func (m *RouteMutation) RefIDs() (ids []uuid.UUID) {
	if id := m.ref; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRef resets all changes to the "ref" edge.
func (m *RouteMutation) ResetRef() {
	m.ref = nil
	m.clearedref = false
}

// Where appends a list predicates to the RouteMutation builder.
func (m *RouteMutation) Where(ps ...predicate.Route) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RouteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Route).
func (m *RouteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouteMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.weight != nil {
		fields = append(fields, route.FieldWeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case route.FieldWeight:
		return m.Weight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case route.FieldWeight:
		return m.OldWeight(ctx)
	}
	return nil, fmt.Errorf("unknown Route field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case route.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouteMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, route.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case route.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case route.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Route numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Route nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouteMutation) ResetField(name string) error {
	switch name {
	case route.FieldWeight:
		m.ResetWeight()
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflow != nil {
		edges = append(edges, route.EdgeWorkflow)
	}
	if m.ref != nil {
		edges = append(edges, route.EdgeRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case route.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case route.EdgeRef:
		if id := m.ref; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflow {
		edges = append(edges, route.EdgeWorkflow)
	}
	if m.clearedref {
		edges = append(edges, route.EdgeRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouteMutation) EdgeCleared(name string) bool {
	switch name {
	case route.EdgeWorkflow:
		return m.clearedworkflow
	case route.EdgeRef:
		return m.clearedref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouteMutation) ClearEdge(name string) error {
	switch name {
	case route.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case route.EdgeRef:
		m.ClearRef()
		return nil
	}
	return fmt.Errorf("unknown Route unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouteMutation) ResetEdge(name string) error {
	switch name {
	case route.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case route.EdgeRef:
		m.ResetRef()
		return nil
	}
	return fmt.Errorf("unknown Route edge %s", name)
}

// ServicesMutation represents an operation that mutates the Services nodes in the graph.
type ServicesMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	url              *string
	name             *string
	data             *string
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	done             bool
	oldValue         func(context.Context) (*Services, error)
	predicates       []predicate.Services
}

var _ ent.Mutation = (*ServicesMutation)(nil)

// servicesOption allows management of the mutation configuration using functional options.
type servicesOption func(*ServicesMutation)

// newServicesMutation creates new mutation for the Services entity.
func newServicesMutation(c config, op Op, opts ...servicesOption) *ServicesMutation {
	m := &ServicesMutation{
		config:        c,
		op:            op,
		typ:           TypeServices,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServicesID sets the ID field of the mutation.
func withServicesID(id uuid.UUID) servicesOption {
	return func(m *ServicesMutation) {
		var (
			err   error
			once  sync.Once
			value *Services
		)
		m.oldValue = func(ctx context.Context) (*Services, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Services.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServices sets the old Services of the mutation.
func withServices(node *Services) servicesOption {
	return func(m *ServicesMutation) {
		m.oldValue = func(context.Context) (*Services, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServicesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServicesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Services entities.
func (m *ServicesMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServicesMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServicesMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Services.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServicesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServicesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServicesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServicesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServicesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServicesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetURL sets the "url" field.
func (m *ServicesMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ServicesMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ServicesMutation) ResetURL() {
	m.url = nil
}

// SetName sets the "name" field.
func (m *ServicesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServicesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServicesMutation) ResetName() {
	m.name = nil
}

// SetData sets the "data" field.
func (m *ServicesMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *ServicesMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *ServicesMutation) ResetData() {
	m.data = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *ServicesMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *ServicesMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *ServicesMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *ServicesMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *ServicesMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *ServicesMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the ServicesMutation builder.
func (m *ServicesMutation) Where(ps ...predicate.Services) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ServicesMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Services).
func (m *ServicesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServicesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, services.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, services.FieldUpdatedAt)
	}
	if m.url != nil {
		fields = append(fields, services.FieldURL)
	}
	if m.name != nil {
		fields = append(fields, services.FieldName)
	}
	if m.data != nil {
		fields = append(fields, services.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServicesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case services.FieldCreatedAt:
		return m.CreatedAt()
	case services.FieldUpdatedAt:
		return m.UpdatedAt()
	case services.FieldURL:
		return m.URL()
	case services.FieldName:
		return m.Name()
	case services.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServicesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case services.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case services.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case services.FieldURL:
		return m.OldURL(ctx)
	case services.FieldName:
		return m.OldName(ctx)
	case services.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Services field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServicesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case services.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case services.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case services.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case services.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case services.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Services field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServicesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServicesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServicesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Services numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServicesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServicesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServicesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Services nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServicesMutation) ResetField(name string) error {
	switch name {
	case services.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case services.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case services.FieldURL:
		m.ResetURL()
		return nil
	case services.FieldName:
		m.ResetName()
		return nil
	case services.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Services field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServicesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespace != nil {
		edges = append(edges, services.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServicesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case services.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServicesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServicesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServicesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespace {
		edges = append(edges, services.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServicesMutation) EdgeCleared(name string) bool {
	switch name {
	case services.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServicesMutation) ClearEdge(name string) error {
	switch name {
	case services.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Services unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServicesMutation) ResetEdge(name string) error {
	switch name {
	case services.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown Services edge %s", name)
}

// VarDataMutation represents an operation that mutates the VarData nodes in the graph.
type VarDataMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	size           *int
	addsize        *int
	hash           *string
	data           *[]byte
	mime_type      *string
	clearedFields  map[string]struct{}
	varrefs        map[uuid.UUID]struct{}
	removedvarrefs map[uuid.UUID]struct{}
	clearedvarrefs bool
	done           bool
	oldValue       func(context.Context) (*VarData, error)
	predicates     []predicate.VarData
}

var _ ent.Mutation = (*VarDataMutation)(nil)

// vardataOption allows management of the mutation configuration using functional options.
type vardataOption func(*VarDataMutation)

// newVarDataMutation creates new mutation for the VarData entity.
func newVarDataMutation(c config, op Op, opts ...vardataOption) *VarDataMutation {
	m := &VarDataMutation{
		config:        c,
		op:            op,
		typ:           TypeVarData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVarDataID sets the ID field of the mutation.
func withVarDataID(id uuid.UUID) vardataOption {
	return func(m *VarDataMutation) {
		var (
			err   error
			once  sync.Once
			value *VarData
		)
		m.oldValue = func(ctx context.Context) (*VarData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VarData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVarData sets the old VarData of the mutation.
func withVarData(node *VarData) vardataOption {
	return func(m *VarDataMutation) {
		m.oldValue = func(context.Context) (*VarData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VarDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VarDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VarData entities.
func (m *VarDataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VarDataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VarDataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VarData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VarDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VarDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VarDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VarDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VarDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VarDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSize sets the "size" field.
func (m *VarDataMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VarDataMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VarDataMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VarDataMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *VarDataMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetHash sets the "hash" field.
func (m *VarDataMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *VarDataMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *VarDataMutation) ResetHash() {
	m.hash = nil
}

// SetData sets the "data" field.
func (m *VarDataMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *VarDataMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *VarDataMutation) ResetData() {
	m.data = nil
}

// SetMimeType sets the "mime_type" field.
func (m *VarDataMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *VarDataMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *VarDataMutation) ResetMimeType() {
	m.mime_type = nil
}

// AddVarrefIDs adds the "varrefs" edge to the VarRef entity by ids.
func (m *VarDataMutation) AddVarrefIDs(ids ...uuid.UUID) {
	if m.varrefs == nil {
		m.varrefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.varrefs[ids[i]] = struct{}{}
	}
}

// ClearVarrefs clears the "varrefs" edge to the VarRef entity.
func (m *VarDataMutation) ClearVarrefs() {
	m.clearedvarrefs = true
}

// VarrefsCleared reports if the "varrefs" edge to the VarRef entity was cleared.
func (m *VarDataMutation) VarrefsCleared() bool {
	return m.clearedvarrefs
}

// RemoveVarrefIDs removes the "varrefs" edge to the VarRef entity by IDs.
func (m *VarDataMutation) RemoveVarrefIDs(ids ...uuid.UUID) {
	if m.removedvarrefs == nil {
		m.removedvarrefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.varrefs, ids[i])
		m.removedvarrefs[ids[i]] = struct{}{}
	}
}

// RemovedVarrefs returns the removed IDs of the "varrefs" edge to the VarRef entity.
func (m *VarDataMutation) RemovedVarrefsIDs() (ids []uuid.UUID) {
	for id := range m.removedvarrefs {
		ids = append(ids, id)
	}
	return
}

// VarrefsIDs returns the "varrefs" edge IDs in the mutation.
func (m *VarDataMutation) VarrefsIDs() (ids []uuid.UUID) {
	for id := range m.varrefs {
		ids = append(ids, id)
	}
	return
}

// ResetVarrefs resets all changes to the "varrefs" edge.
func (m *VarDataMutation) ResetVarrefs() {
	m.varrefs = nil
	m.clearedvarrefs = false
	m.removedvarrefs = nil
}

// Where appends a list predicates to the VarDataMutation builder.
func (m *VarDataMutation) Where(ps ...predicate.VarData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VarDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VarData).
func (m *VarDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VarDataMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, vardata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vardata.FieldUpdatedAt)
	}
	if m.size != nil {
		fields = append(fields, vardata.FieldSize)
	}
	if m.hash != nil {
		fields = append(fields, vardata.FieldHash)
	}
	if m.data != nil {
		fields = append(fields, vardata.FieldData)
	}
	if m.mime_type != nil {
		fields = append(fields, vardata.FieldMimeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VarDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vardata.FieldCreatedAt:
		return m.CreatedAt()
	case vardata.FieldUpdatedAt:
		return m.UpdatedAt()
	case vardata.FieldSize:
		return m.Size()
	case vardata.FieldHash:
		return m.Hash()
	case vardata.FieldData:
		return m.Data()
	case vardata.FieldMimeType:
		return m.MimeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VarDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vardata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vardata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vardata.FieldSize:
		return m.OldSize(ctx)
	case vardata.FieldHash:
		return m.OldHash(ctx)
	case vardata.FieldData:
		return m.OldData(ctx)
	case vardata.FieldMimeType:
		return m.OldMimeType(ctx)
	}
	return nil, fmt.Errorf("unknown VarData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vardata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vardata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vardata.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case vardata.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case vardata.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case vardata.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	}
	return fmt.Errorf("unknown VarData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VarDataMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, vardata.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VarDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vardata.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vardata.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown VarData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VarDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VarDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VarDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VarData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VarDataMutation) ResetField(name string) error {
	switch name {
	case vardata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vardata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vardata.FieldSize:
		m.ResetSize()
		return nil
	case vardata.FieldHash:
		m.ResetHash()
		return nil
	case vardata.FieldData:
		m.ResetData()
		return nil
	case vardata.FieldMimeType:
		m.ResetMimeType()
		return nil
	}
	return fmt.Errorf("unknown VarData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VarDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.varrefs != nil {
		edges = append(edges, vardata.EdgeVarrefs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VarDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vardata.EdgeVarrefs:
		ids := make([]ent.Value, 0, len(m.varrefs))
		for id := range m.varrefs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VarDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvarrefs != nil {
		edges = append(edges, vardata.EdgeVarrefs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VarDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vardata.EdgeVarrefs:
		ids := make([]ent.Value, 0, len(m.removedvarrefs))
		for id := range m.removedvarrefs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VarDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvarrefs {
		edges = append(edges, vardata.EdgeVarrefs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VarDataMutation) EdgeCleared(name string) bool {
	switch name {
	case vardata.EdgeVarrefs:
		return m.clearedvarrefs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VarDataMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VarData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VarDataMutation) ResetEdge(name string) error {
	switch name {
	case vardata.EdgeVarrefs:
		m.ResetVarrefs()
		return nil
	}
	return fmt.Errorf("unknown VarData edge %s", name)
}

// VarRefMutation represents an operation that mutates the VarRef nodes in the graph.
type VarRefMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	behaviour        *string
	clearedFields    map[string]struct{}
	vardata          *uuid.UUID
	clearedvardata   bool
	namespace        *uuid.UUID
	clearednamespace bool
	workflow         *uuid.UUID
	clearedworkflow  bool
	instance         *uuid.UUID
	clearedinstance  bool
	done             bool
	oldValue         func(context.Context) (*VarRef, error)
	predicates       []predicate.VarRef
}

var _ ent.Mutation = (*VarRefMutation)(nil)

// varrefOption allows management of the mutation configuration using functional options.
type varrefOption func(*VarRefMutation)

// newVarRefMutation creates new mutation for the VarRef entity.
func newVarRefMutation(c config, op Op, opts ...varrefOption) *VarRefMutation {
	m := &VarRefMutation{
		config:        c,
		op:            op,
		typ:           TypeVarRef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVarRefID sets the ID field of the mutation.
func withVarRefID(id uuid.UUID) varrefOption {
	return func(m *VarRefMutation) {
		var (
			err   error
			once  sync.Once
			value *VarRef
		)
		m.oldValue = func(ctx context.Context) (*VarRef, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VarRef.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVarRef sets the old VarRef of the mutation.
func withVarRef(node *VarRef) varrefOption {
	return func(m *VarRefMutation) {
		m.oldValue = func(context.Context) (*VarRef, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VarRefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VarRefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VarRef entities.
func (m *VarRefMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VarRefMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VarRefMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VarRef.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *VarRefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VarRefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VarRef entity.
// If the VarRef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarRefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VarRefMutation) ClearName() {
	m.name = nil
	m.clearedFields[varref.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VarRefMutation) NameCleared() bool {
	_, ok := m.clearedFields[varref.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VarRefMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, varref.FieldName)
}

// SetBehaviour sets the "behaviour" field.
func (m *VarRefMutation) SetBehaviour(s string) {
	m.behaviour = &s
}

// Behaviour returns the value of the "behaviour" field in the mutation.
func (m *VarRefMutation) Behaviour() (r string, exists bool) {
	v := m.behaviour
	if v == nil {
		return
	}
	return *v, true
}

// OldBehaviour returns the old "behaviour" field's value of the VarRef entity.
// If the VarRef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarRefMutation) OldBehaviour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBehaviour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBehaviour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBehaviour: %w", err)
	}
	return oldValue.Behaviour, nil
}

// ClearBehaviour clears the value of the "behaviour" field.
func (m *VarRefMutation) ClearBehaviour() {
	m.behaviour = nil
	m.clearedFields[varref.FieldBehaviour] = struct{}{}
}

// BehaviourCleared returns if the "behaviour" field was cleared in this mutation.
func (m *VarRefMutation) BehaviourCleared() bool {
	_, ok := m.clearedFields[varref.FieldBehaviour]
	return ok
}

// ResetBehaviour resets all changes to the "behaviour" field.
func (m *VarRefMutation) ResetBehaviour() {
	m.behaviour = nil
	delete(m.clearedFields, varref.FieldBehaviour)
}

// SetVardataID sets the "vardata" edge to the VarData entity by id.
func (m *VarRefMutation) SetVardataID(id uuid.UUID) {
	m.vardata = &id
}

// ClearVardata clears the "vardata" edge to the VarData entity.
func (m *VarRefMutation) ClearVardata() {
	m.clearedvardata = true
}

// VardataCleared reports if the "vardata" edge to the VarData entity was cleared.
func (m *VarRefMutation) VardataCleared() bool {
	return m.clearedvardata
}

// VardataID returns the "vardata" edge ID in the mutation.
func (m *VarRefMutation) VardataID() (id uuid.UUID, exists bool) {
	if m.vardata != nil {
		return *m.vardata, true
	}
	return
}

// VardataIDs returns the "vardata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VardataID instead. It exists only for internal usage by the builders.
func (m *VarRefMutation) VardataIDs() (ids []uuid.UUID) {
	if id := m.vardata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVardata resets all changes to the "vardata" edge.
func (m *VarRefMutation) ResetVardata() {
	m.vardata = nil
	m.clearedvardata = false
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *VarRefMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *VarRefMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *VarRefMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *VarRefMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *VarRefMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *VarRefMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *VarRefMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *VarRefMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *VarRefMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *VarRefMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *VarRefMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *VarRefMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *VarRefMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *VarRefMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *VarRefMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *VarRefMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *VarRefMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *VarRefMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// Where appends a list predicates to the VarRefMutation builder.
func (m *VarRefMutation) Where(ps ...predicate.VarRef) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VarRefMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VarRef).
func (m *VarRefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VarRefMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, varref.FieldName)
	}
	if m.behaviour != nil {
		fields = append(fields, varref.FieldBehaviour)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VarRefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case varref.FieldName:
		return m.Name()
	case varref.FieldBehaviour:
		return m.Behaviour()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VarRefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case varref.FieldName:
		return m.OldName(ctx)
	case varref.FieldBehaviour:
		return m.OldBehaviour(ctx)
	}
	return nil, fmt.Errorf("unknown VarRef field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarRefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case varref.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case varref.FieldBehaviour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBehaviour(v)
		return nil
	}
	return fmt.Errorf("unknown VarRef field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VarRefMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VarRefMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarRefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VarRef numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VarRefMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(varref.FieldName) {
		fields = append(fields, varref.FieldName)
	}
	if m.FieldCleared(varref.FieldBehaviour) {
		fields = append(fields, varref.FieldBehaviour)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VarRefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VarRefMutation) ClearField(name string) error {
	switch name {
	case varref.FieldName:
		m.ClearName()
		return nil
	case varref.FieldBehaviour:
		m.ClearBehaviour()
		return nil
	}
	return fmt.Errorf("unknown VarRef nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VarRefMutation) ResetField(name string) error {
	switch name {
	case varref.FieldName:
		m.ResetName()
		return nil
	case varref.FieldBehaviour:
		m.ResetBehaviour()
		return nil
	}
	return fmt.Errorf("unknown VarRef field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VarRefMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.vardata != nil {
		edges = append(edges, varref.EdgeVardata)
	}
	if m.namespace != nil {
		edges = append(edges, varref.EdgeNamespace)
	}
	if m.workflow != nil {
		edges = append(edges, varref.EdgeWorkflow)
	}
	if m.instance != nil {
		edges = append(edges, varref.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VarRefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case varref.EdgeVardata:
		if id := m.vardata; id != nil {
			return []ent.Value{*id}
		}
	case varref.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case varref.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case varref.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VarRefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VarRefMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VarRefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedvardata {
		edges = append(edges, varref.EdgeVardata)
	}
	if m.clearednamespace {
		edges = append(edges, varref.EdgeNamespace)
	}
	if m.clearedworkflow {
		edges = append(edges, varref.EdgeWorkflow)
	}
	if m.clearedinstance {
		edges = append(edges, varref.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VarRefMutation) EdgeCleared(name string) bool {
	switch name {
	case varref.EdgeVardata:
		return m.clearedvardata
	case varref.EdgeNamespace:
		return m.clearednamespace
	case varref.EdgeWorkflow:
		return m.clearedworkflow
	case varref.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VarRefMutation) ClearEdge(name string) error {
	switch name {
	case varref.EdgeVardata:
		m.ClearVardata()
		return nil
	case varref.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case varref.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case varref.EdgeInstance:
		m.ClearInstance()
		return nil
	}
	return fmt.Errorf("unknown VarRef unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VarRefMutation) ResetEdge(name string) error {
	switch name {
	case varref.EdgeVardata:
		m.ResetVardata()
		return nil
	case varref.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case varref.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case varref.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown VarRef edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	live             *bool
	logToEvents      *string
	readOnly         *bool
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	inode            *uuid.UUID
	clearedinode     bool
	namespace        *uuid.UUID
	clearednamespace bool
	revisions        map[uuid.UUID]struct{}
	removedrevisions map[uuid.UUID]struct{}
	clearedrevisions bool
	refs             map[uuid.UUID]struct{}
	removedrefs      map[uuid.UUID]struct{}
	clearedrefs      bool
	instances        map[uuid.UUID]struct{}
	removedinstances map[uuid.UUID]struct{}
	clearedinstances bool
	routes           map[uuid.UUID]struct{}
	removedroutes    map[uuid.UUID]struct{}
	clearedroutes    bool
	logs             map[uuid.UUID]struct{}
	removedlogs      map[uuid.UUID]struct{}
	clearedlogs      bool
	vars             map[uuid.UUID]struct{}
	removedvars      map[uuid.UUID]struct{}
	clearedvars      bool
	wfevents         map[uuid.UUID]struct{}
	removedwfevents  map[uuid.UUID]struct{}
	clearedwfevents  bool
	done             bool
	oldValue         func(context.Context) (*Workflow, error)
	predicates       []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id uuid.UUID) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workflow entities.
func (m *WorkflowMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLive sets the "live" field.
func (m *WorkflowMutation) SetLive(b bool) {
	m.live = &b
}

// Live returns the value of the "live" field in the mutation.
func (m *WorkflowMutation) Live() (r bool, exists bool) {
	v := m.live
	if v == nil {
		return
	}
	return *v, true
}

// OldLive returns the old "live" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldLive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLive: %w", err)
	}
	return oldValue.Live, nil
}

// ResetLive resets all changes to the "live" field.
func (m *WorkflowMutation) ResetLive() {
	m.live = nil
}

// SetLogToEvents sets the "logToEvents" field.
func (m *WorkflowMutation) SetLogToEvents(s string) {
	m.logToEvents = &s
}

// LogToEvents returns the value of the "logToEvents" field in the mutation.
func (m *WorkflowMutation) LogToEvents() (r string, exists bool) {
	v := m.logToEvents
	if v == nil {
		return
	}
	return *v, true
}

// OldLogToEvents returns the old "logToEvents" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldLogToEvents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogToEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogToEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogToEvents: %w", err)
	}
	return oldValue.LogToEvents, nil
}

// ClearLogToEvents clears the value of the "logToEvents" field.
func (m *WorkflowMutation) ClearLogToEvents() {
	m.logToEvents = nil
	m.clearedFields[workflow.FieldLogToEvents] = struct{}{}
}

// LogToEventsCleared returns if the "logToEvents" field was cleared in this mutation.
func (m *WorkflowMutation) LogToEventsCleared() bool {
	_, ok := m.clearedFields[workflow.FieldLogToEvents]
	return ok
}

// ResetLogToEvents resets all changes to the "logToEvents" field.
func (m *WorkflowMutation) ResetLogToEvents() {
	m.logToEvents = nil
	delete(m.clearedFields, workflow.FieldLogToEvents)
}

// SetReadOnly sets the "readOnly" field.
func (m *WorkflowMutation) SetReadOnly(b bool) {
	m.readOnly = &b
}

// ReadOnly returns the value of the "readOnly" field in the mutation.
func (m *WorkflowMutation) ReadOnly() (r bool, exists bool) {
	v := m.readOnly
	if v == nil {
		return
	}
	return *v, true
}

// OldReadOnly returns the old "readOnly" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldReadOnly(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReadOnly is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReadOnly requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReadOnly: %w", err)
	}
	return oldValue.ReadOnly, nil
}

// ClearReadOnly clears the value of the "readOnly" field.
func (m *WorkflowMutation) ClearReadOnly() {
	m.readOnly = nil
	m.clearedFields[workflow.FieldReadOnly] = struct{}{}
}

// ReadOnlyCleared returns if the "readOnly" field was cleared in this mutation.
func (m *WorkflowMutation) ReadOnlyCleared() bool {
	_, ok := m.clearedFields[workflow.FieldReadOnly]
	return ok
}

// ResetReadOnly resets all changes to the "readOnly" field.
func (m *WorkflowMutation) ResetReadOnly() {
	m.readOnly = nil
	delete(m.clearedFields, workflow.FieldReadOnly)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkflowMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkflowMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkflowMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workflow.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkflowMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workflow.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkflowMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workflow.FieldUpdatedAt)
}

// SetInodeID sets the "inode" edge to the Inode entity by id.
func (m *WorkflowMutation) SetInodeID(id uuid.UUID) {
	m.inode = &id
}

// ClearInode clears the "inode" edge to the Inode entity.
func (m *WorkflowMutation) ClearInode() {
	m.clearedinode = true
}

// InodeCleared reports if the "inode" edge to the Inode entity was cleared.
func (m *WorkflowMutation) InodeCleared() bool {
	return m.clearedinode
}

// InodeID returns the "inode" edge ID in the mutation.
func (m *WorkflowMutation) InodeID() (id uuid.UUID, exists bool) {
	if m.inode != nil {
		return *m.inode, true
	}
	return
}

// InodeIDs returns the "inode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InodeID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) InodeIDs() (ids []uuid.UUID) {
	if id := m.inode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInode resets all changes to the "inode" edge.
func (m *WorkflowMutation) ResetInode() {
	m.inode = nil
	m.clearedinode = false
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *WorkflowMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *WorkflowMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *WorkflowMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *WorkflowMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *WorkflowMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddRevisionIDs adds the "revisions" edge to the Revision entity by ids.
func (m *WorkflowMutation) AddRevisionIDs(ids ...uuid.UUID) {
	if m.revisions == nil {
		m.revisions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.revisions[ids[i]] = struct{}{}
	}
}

// ClearRevisions clears the "revisions" edge to the Revision entity.
func (m *WorkflowMutation) ClearRevisions() {
	m.clearedrevisions = true
}

// RevisionsCleared reports if the "revisions" edge to the Revision entity was cleared.
func (m *WorkflowMutation) RevisionsCleared() bool {
	return m.clearedrevisions
}

// RemoveRevisionIDs removes the "revisions" edge to the Revision entity by IDs.
func (m *WorkflowMutation) RemoveRevisionIDs(ids ...uuid.UUID) {
	if m.removedrevisions == nil {
		m.removedrevisions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.revisions, ids[i])
		m.removedrevisions[ids[i]] = struct{}{}
	}
}

// RemovedRevisions returns the removed IDs of the "revisions" edge to the Revision entity.
func (m *WorkflowMutation) RemovedRevisionsIDs() (ids []uuid.UUID) {
	for id := range m.removedrevisions {
		ids = append(ids, id)
	}
	return
}

// RevisionsIDs returns the "revisions" edge IDs in the mutation.
func (m *WorkflowMutation) RevisionsIDs() (ids []uuid.UUID) {
	for id := range m.revisions {
		ids = append(ids, id)
	}
	return
}

// ResetRevisions resets all changes to the "revisions" edge.
func (m *WorkflowMutation) ResetRevisions() {
	m.revisions = nil
	m.clearedrevisions = false
	m.removedrevisions = nil
}

// AddRefIDs adds the "refs" edge to the Ref entity by ids.
func (m *WorkflowMutation) AddRefIDs(ids ...uuid.UUID) {
	if m.refs == nil {
		m.refs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.refs[ids[i]] = struct{}{}
	}
}

// ClearRefs clears the "refs" edge to the Ref entity.
func (m *WorkflowMutation) ClearRefs() {
	m.clearedrefs = true
}

// RefsCleared reports if the "refs" edge to the Ref entity was cleared.
func (m *WorkflowMutation) RefsCleared() bool {
	return m.clearedrefs
}

// RemoveRefIDs removes the "refs" edge to the Ref entity by IDs.
func (m *WorkflowMutation) RemoveRefIDs(ids ...uuid.UUID) {
	if m.removedrefs == nil {
		m.removedrefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.refs, ids[i])
		m.removedrefs[ids[i]] = struct{}{}
	}
}

// RemovedRefs returns the removed IDs of the "refs" edge to the Ref entity.
func (m *WorkflowMutation) RemovedRefsIDs() (ids []uuid.UUID) {
	for id := range m.removedrefs {
		ids = append(ids, id)
	}
	return
}

// RefsIDs returns the "refs" edge IDs in the mutation.
func (m *WorkflowMutation) RefsIDs() (ids []uuid.UUID) {
	for id := range m.refs {
		ids = append(ids, id)
	}
	return
}

// ResetRefs resets all changes to the "refs" edge.
func (m *WorkflowMutation) ResetRefs() {
	m.refs = nil
	m.clearedrefs = false
	m.removedrefs = nil
}

// AddInstanceIDs adds the "instances" edge to the Instance entity by ids.
func (m *WorkflowMutation) AddInstanceIDs(ids ...uuid.UUID) {
	if m.instances == nil {
		m.instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the Instance entity.
func (m *WorkflowMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the Instance entity was cleared.
func (m *WorkflowMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the Instance entity by IDs.
func (m *WorkflowMutation) RemoveInstanceIDs(ids ...uuid.UUID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the Instance entity.
func (m *WorkflowMutation) RemovedInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *WorkflowMutation) InstancesIDs() (ids []uuid.UUID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *WorkflowMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// AddRouteIDs adds the "routes" edge to the Route entity by ids.
func (m *WorkflowMutation) AddRouteIDs(ids ...uuid.UUID) {
	if m.routes == nil {
		m.routes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.routes[ids[i]] = struct{}{}
	}
}

// ClearRoutes clears the "routes" edge to the Route entity.
func (m *WorkflowMutation) ClearRoutes() {
	m.clearedroutes = true
}

// RoutesCleared reports if the "routes" edge to the Route entity was cleared.
func (m *WorkflowMutation) RoutesCleared() bool {
	return m.clearedroutes
}

// RemoveRouteIDs removes the "routes" edge to the Route entity by IDs.
func (m *WorkflowMutation) RemoveRouteIDs(ids ...uuid.UUID) {
	if m.removedroutes == nil {
		m.removedroutes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.routes, ids[i])
		m.removedroutes[ids[i]] = struct{}{}
	}
}

// RemovedRoutes returns the removed IDs of the "routes" edge to the Route entity.
func (m *WorkflowMutation) RemovedRoutesIDs() (ids []uuid.UUID) {
	for id := range m.removedroutes {
		ids = append(ids, id)
	}
	return
}

// RoutesIDs returns the "routes" edge IDs in the mutation.
func (m *WorkflowMutation) RoutesIDs() (ids []uuid.UUID) {
	for id := range m.routes {
		ids = append(ids, id)
	}
	return
}

// ResetRoutes resets all changes to the "routes" edge.
func (m *WorkflowMutation) ResetRoutes() {
	m.routes = nil
	m.clearedroutes = false
	m.removedroutes = nil
}

// AddLogIDs adds the "logs" edge to the LogMsg entity by ids.
func (m *WorkflowMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the LogMsg entity.
func (m *WorkflowMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the LogMsg entity was cleared.
func (m *WorkflowMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the LogMsg entity by IDs.
func (m *WorkflowMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the LogMsg entity.
func (m *WorkflowMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *WorkflowMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *WorkflowMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddVarIDs adds the "vars" edge to the VarRef entity by ids.
func (m *WorkflowMutation) AddVarIDs(ids ...uuid.UUID) {
	if m.vars == nil {
		m.vars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vars[ids[i]] = struct{}{}
	}
}

// ClearVars clears the "vars" edge to the VarRef entity.
func (m *WorkflowMutation) ClearVars() {
	m.clearedvars = true
}

// VarsCleared reports if the "vars" edge to the VarRef entity was cleared.
func (m *WorkflowMutation) VarsCleared() bool {
	return m.clearedvars
}

// RemoveVarIDs removes the "vars" edge to the VarRef entity by IDs.
func (m *WorkflowMutation) RemoveVarIDs(ids ...uuid.UUID) {
	if m.removedvars == nil {
		m.removedvars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vars, ids[i])
		m.removedvars[ids[i]] = struct{}{}
	}
}

// RemovedVars returns the removed IDs of the "vars" edge to the VarRef entity.
func (m *WorkflowMutation) RemovedVarsIDs() (ids []uuid.UUID) {
	for id := range m.removedvars {
		ids = append(ids, id)
	}
	return
}

// VarsIDs returns the "vars" edge IDs in the mutation.
func (m *WorkflowMutation) VarsIDs() (ids []uuid.UUID) {
	for id := range m.vars {
		ids = append(ids, id)
	}
	return
}

// ResetVars resets all changes to the "vars" edge.
func (m *WorkflowMutation) ResetVars() {
	m.vars = nil
	m.clearedvars = false
	m.removedvars = nil
}

// AddWfeventIDs adds the "wfevents" edge to the Events entity by ids.
func (m *WorkflowMutation) AddWfeventIDs(ids ...uuid.UUID) {
	if m.wfevents == nil {
		m.wfevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.wfevents[ids[i]] = struct{}{}
	}
}

// ClearWfevents clears the "wfevents" edge to the Events entity.
func (m *WorkflowMutation) ClearWfevents() {
	m.clearedwfevents = true
}

// WfeventsCleared reports if the "wfevents" edge to the Events entity was cleared.
func (m *WorkflowMutation) WfeventsCleared() bool {
	return m.clearedwfevents
}

// RemoveWfeventIDs removes the "wfevents" edge to the Events entity by IDs.
func (m *WorkflowMutation) RemoveWfeventIDs(ids ...uuid.UUID) {
	if m.removedwfevents == nil {
		m.removedwfevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.wfevents, ids[i])
		m.removedwfevents[ids[i]] = struct{}{}
	}
}

// RemovedWfevents returns the removed IDs of the "wfevents" edge to the Events entity.
func (m *WorkflowMutation) RemovedWfeventsIDs() (ids []uuid.UUID) {
	for id := range m.removedwfevents {
		ids = append(ids, id)
	}
	return
}

// WfeventsIDs returns the "wfevents" edge IDs in the mutation.
func (m *WorkflowMutation) WfeventsIDs() (ids []uuid.UUID) {
	for id := range m.wfevents {
		ids = append(ids, id)
	}
	return
}

// ResetWfevents resets all changes to the "wfevents" edge.
func (m *WorkflowMutation) ResetWfevents() {
	m.wfevents = nil
	m.clearedwfevents = false
	m.removedwfevents = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.live != nil {
		fields = append(fields, workflow.FieldLive)
	}
	if m.logToEvents != nil {
		fields = append(fields, workflow.FieldLogToEvents)
	}
	if m.readOnly != nil {
		fields = append(fields, workflow.FieldReadOnly)
	}
	if m.updated_at != nil {
		fields = append(fields, workflow.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldLive:
		return m.Live()
	case workflow.FieldLogToEvents:
		return m.LogToEvents()
	case workflow.FieldReadOnly:
		return m.ReadOnly()
	case workflow.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldLive:
		return m.OldLive(ctx)
	case workflow.FieldLogToEvents:
		return m.OldLogToEvents(ctx)
	case workflow.FieldReadOnly:
		return m.OldReadOnly(ctx)
	case workflow.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldLive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLive(v)
		return nil
	case workflow.FieldLogToEvents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogToEvents(v)
		return nil
	case workflow.FieldReadOnly:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReadOnly(v)
		return nil
	case workflow.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldLogToEvents) {
		fields = append(fields, workflow.FieldLogToEvents)
	}
	if m.FieldCleared(workflow.FieldReadOnly) {
		fields = append(fields, workflow.FieldReadOnly)
	}
	if m.FieldCleared(workflow.FieldUpdatedAt) {
		fields = append(fields, workflow.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldLogToEvents:
		m.ClearLogToEvents()
		return nil
	case workflow.FieldReadOnly:
		m.ClearReadOnly()
		return nil
	case workflow.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldLive:
		m.ResetLive()
		return nil
	case workflow.FieldLogToEvents:
		m.ResetLogToEvents()
		return nil
	case workflow.FieldReadOnly:
		m.ResetReadOnly()
		return nil
	case workflow.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.inode != nil {
		edges = append(edges, workflow.EdgeInode)
	}
	if m.namespace != nil {
		edges = append(edges, workflow.EdgeNamespace)
	}
	if m.revisions != nil {
		edges = append(edges, workflow.EdgeRevisions)
	}
	if m.refs != nil {
		edges = append(edges, workflow.EdgeRefs)
	}
	if m.instances != nil {
		edges = append(edges, workflow.EdgeInstances)
	}
	if m.routes != nil {
		edges = append(edges, workflow.EdgeRoutes)
	}
	if m.logs != nil {
		edges = append(edges, workflow.EdgeLogs)
	}
	if m.vars != nil {
		edges = append(edges, workflow.EdgeVars)
	}
	if m.wfevents != nil {
		edges = append(edges, workflow.EdgeWfevents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeInode:
		if id := m.inode; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.revisions))
		for id := range m.revisions {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeRefs:
		ids := make([]ent.Value, 0, len(m.refs))
		for id := range m.refs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.routes))
		for id := range m.routes {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeVars:
		ids := make([]ent.Value, 0, len(m.vars))
		for id := range m.vars {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeWfevents:
		ids := make([]ent.Value, 0, len(m.wfevents))
		for id := range m.wfevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedrevisions != nil {
		edges = append(edges, workflow.EdgeRevisions)
	}
	if m.removedrefs != nil {
		edges = append(edges, workflow.EdgeRefs)
	}
	if m.removedinstances != nil {
		edges = append(edges, workflow.EdgeInstances)
	}
	if m.removedroutes != nil {
		edges = append(edges, workflow.EdgeRoutes)
	}
	if m.removedlogs != nil {
		edges = append(edges, workflow.EdgeLogs)
	}
	if m.removedvars != nil {
		edges = append(edges, workflow.EdgeVars)
	}
	if m.removedwfevents != nil {
		edges = append(edges, workflow.EdgeWfevents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.removedrevisions))
		for id := range m.removedrevisions {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeRefs:
		ids := make([]ent.Value, 0, len(m.removedrefs))
		for id := range m.removedrefs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.removedroutes))
		for id := range m.removedroutes {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeVars:
		ids := make([]ent.Value, 0, len(m.removedvars))
		for id := range m.removedvars {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeWfevents:
		ids := make([]ent.Value, 0, len(m.removedwfevents))
		for id := range m.removedwfevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedinode {
		edges = append(edges, workflow.EdgeInode)
	}
	if m.clearednamespace {
		edges = append(edges, workflow.EdgeNamespace)
	}
	if m.clearedrevisions {
		edges = append(edges, workflow.EdgeRevisions)
	}
	if m.clearedrefs {
		edges = append(edges, workflow.EdgeRefs)
	}
	if m.clearedinstances {
		edges = append(edges, workflow.EdgeInstances)
	}
	if m.clearedroutes {
		edges = append(edges, workflow.EdgeRoutes)
	}
	if m.clearedlogs {
		edges = append(edges, workflow.EdgeLogs)
	}
	if m.clearedvars {
		edges = append(edges, workflow.EdgeVars)
	}
	if m.clearedwfevents {
		edges = append(edges, workflow.EdgeWfevents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeInode:
		return m.clearedinode
	case workflow.EdgeNamespace:
		return m.clearednamespace
	case workflow.EdgeRevisions:
		return m.clearedrevisions
	case workflow.EdgeRefs:
		return m.clearedrefs
	case workflow.EdgeInstances:
		return m.clearedinstances
	case workflow.EdgeRoutes:
		return m.clearedroutes
	case workflow.EdgeLogs:
		return m.clearedlogs
	case workflow.EdgeVars:
		return m.clearedvars
	case workflow.EdgeWfevents:
		return m.clearedwfevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	case workflow.EdgeInode:
		m.ClearInode()
		return nil
	case workflow.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeInode:
		m.ResetInode()
		return nil
	case workflow.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case workflow.EdgeRevisions:
		m.ResetRevisions()
		return nil
	case workflow.EdgeRefs:
		m.ResetRefs()
		return nil
	case workflow.EdgeInstances:
		m.ResetInstances()
		return nil
	case workflow.EdgeRoutes:
		m.ResetRoutes()
		return nil
	case workflow.EdgeLogs:
		m.ResetLogs()
		return nil
	case workflow.EdgeVars:
		m.ResetVars()
		return nil
	case workflow.EdgeWfevents:
		m.ResetWfevents()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}
