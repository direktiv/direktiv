// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/direktiv/direktiv/pkg/flow/ent/cloudevents"
	"github.com/direktiv/direktiv/pkg/flow/ent/events"
	"github.com/direktiv/direktiv/pkg/flow/ent/eventswait"
	"github.com/direktiv/direktiv/pkg/flow/ent/inode"
	"github.com/direktiv/direktiv/pkg/flow/ent/instance"
	"github.com/direktiv/direktiv/pkg/flow/ent/instanceruntime"
	"github.com/direktiv/direktiv/pkg/flow/ent/logmsg"
	"github.com/direktiv/direktiv/pkg/flow/ent/namespace"
	"github.com/direktiv/direktiv/pkg/flow/ent/predicate"
	"github.com/direktiv/direktiv/pkg/flow/ent/ref"
	"github.com/direktiv/direktiv/pkg/flow/ent/revision"
	"github.com/direktiv/direktiv/pkg/flow/ent/route"
	"github.com/direktiv/direktiv/pkg/flow/ent/vardata"
	"github.com/direktiv/direktiv/pkg/flow/ent/varref"
	"github.com/direktiv/direktiv/pkg/flow/ent/workflow"
	"github.com/google/uuid"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeCloudEvents     = "CloudEvents"
	TypeEvents          = "Events"
	TypeEventsWait      = "EventsWait"
	TypeInode           = "Inode"
	TypeInstance        = "Instance"
	TypeInstanceRuntime = "InstanceRuntime"
	TypeLogMsg          = "LogMsg"
	TypeNamespace       = "Namespace"
	TypeRef             = "Ref"
	TypeRevision        = "Revision"
	TypeRoute           = "Route"
	TypeVarData         = "VarData"
	TypeVarRef          = "VarRef"
	TypeWorkflow        = "Workflow"
)

// CloudEventsMutation represents an operation that mutates the CloudEvents nodes in the graph.
type CloudEventsMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	eventId          *string
	event            *event.Event
	fire             *time.Time
	created          *time.Time
	processed        *bool
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	done             bool
	oldValue         func(context.Context) (*CloudEvents, error)
	predicates       []predicate.CloudEvents
}

var _ ent.Mutation = (*CloudEventsMutation)(nil)

// cloudeventsOption allows management of the mutation configuration using functional options.
type cloudeventsOption func(*CloudEventsMutation)

// newCloudEventsMutation creates new mutation for the CloudEvents entity.
func newCloudEventsMutation(c config, op Op, opts ...cloudeventsOption) *CloudEventsMutation {
	m := &CloudEventsMutation{
		config:        c,
		op:            op,
		typ:           TypeCloudEvents,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCloudEventsID sets the ID field of the mutation.
func withCloudEventsID(id uuid.UUID) cloudeventsOption {
	return func(m *CloudEventsMutation) {
		var (
			err   error
			once  sync.Once
			value *CloudEvents
		)
		m.oldValue = func(ctx context.Context) (*CloudEvents, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CloudEvents.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCloudEvents sets the old CloudEvents of the mutation.
func withCloudEvents(node *CloudEvents) cloudeventsOption {
	return func(m *CloudEventsMutation) {
		m.oldValue = func(context.Context) (*CloudEvents, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CloudEventsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CloudEventsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CloudEvents entities.
func (m *CloudEventsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CloudEventsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CloudEventsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CloudEvents.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventId sets the "eventId" field.
func (m *CloudEventsMutation) SetEventId(s string) {
	m.eventId = &s
}

// EventId returns the value of the "eventId" field in the mutation.
func (m *CloudEventsMutation) EventId() (r string, exists bool) {
	v := m.eventId
	if v == nil {
		return
	}
	return *v, true
}

// OldEventId returns the old "eventId" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldEventId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventId: %w", err)
	}
	return oldValue.EventId, nil
}

// ResetEventId resets all changes to the "eventId" field.
func (m *CloudEventsMutation) ResetEventId() {
	m.eventId = nil
}

// SetEvent sets the "event" field.
func (m *CloudEventsMutation) SetEvent(e event.Event) {
	m.event = &e
}

// Event returns the value of the "event" field in the mutation.
func (m *CloudEventsMutation) Event() (r event.Event, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEvent returns the old "event" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldEvent(ctx context.Context) (v event.Event, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvent: %w", err)
	}
	return oldValue.Event, nil
}

// ResetEvent resets all changes to the "event" field.
func (m *CloudEventsMutation) ResetEvent() {
	m.event = nil
}

// SetFire sets the "fire" field.
func (m *CloudEventsMutation) SetFire(t time.Time) {
	m.fire = &t
}

// Fire returns the value of the "fire" field in the mutation.
func (m *CloudEventsMutation) Fire() (r time.Time, exists bool) {
	v := m.fire
	if v == nil {
		return
	}
	return *v, true
}

// OldFire returns the old "fire" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldFire(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFire is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFire requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFire: %w", err)
	}
	return oldValue.Fire, nil
}

// ResetFire resets all changes to the "fire" field.
func (m *CloudEventsMutation) ResetFire() {
	m.fire = nil
}

// SetCreated sets the "created" field.
func (m *CloudEventsMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *CloudEventsMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *CloudEventsMutation) ResetCreated() {
	m.created = nil
}

// SetProcessed sets the "processed" field.
func (m *CloudEventsMutation) SetProcessed(b bool) {
	m.processed = &b
}

// Processed returns the value of the "processed" field in the mutation.
func (m *CloudEventsMutation) Processed() (r bool, exists bool) {
	v := m.processed
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessed returns the old "processed" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldProcessed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessed: %w", err)
	}
	return oldValue.Processed, nil
}

// ResetProcessed resets all changes to the "processed" field.
func (m *CloudEventsMutation) ResetProcessed() {
	m.processed = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *CloudEventsMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *CloudEventsMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *CloudEventsMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *CloudEventsMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *CloudEventsMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *CloudEventsMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the CloudEventsMutation builder.
func (m *CloudEventsMutation) Where(ps ...predicate.CloudEvents) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CloudEventsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CloudEvents).
func (m *CloudEventsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CloudEventsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.eventId != nil {
		fields = append(fields, cloudevents.FieldEventId)
	}
	if m.event != nil {
		fields = append(fields, cloudevents.FieldEvent)
	}
	if m.fire != nil {
		fields = append(fields, cloudevents.FieldFire)
	}
	if m.created != nil {
		fields = append(fields, cloudevents.FieldCreated)
	}
	if m.processed != nil {
		fields = append(fields, cloudevents.FieldProcessed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CloudEventsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cloudevents.FieldEventId:
		return m.EventId()
	case cloudevents.FieldEvent:
		return m.Event()
	case cloudevents.FieldFire:
		return m.Fire()
	case cloudevents.FieldCreated:
		return m.Created()
	case cloudevents.FieldProcessed:
		return m.Processed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CloudEventsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cloudevents.FieldEventId:
		return m.OldEventId(ctx)
	case cloudevents.FieldEvent:
		return m.OldEvent(ctx)
	case cloudevents.FieldFire:
		return m.OldFire(ctx)
	case cloudevents.FieldCreated:
		return m.OldCreated(ctx)
	case cloudevents.FieldProcessed:
		return m.OldProcessed(ctx)
	}
	return nil, fmt.Errorf("unknown CloudEvents field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cloudevents.FieldEventId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventId(v)
		return nil
	case cloudevents.FieldEvent:
		v, ok := value.(event.Event)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvent(v)
		return nil
	case cloudevents.FieldFire:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFire(v)
		return nil
	case cloudevents.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case cloudevents.FieldProcessed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessed(v)
		return nil
	}
	return fmt.Errorf("unknown CloudEvents field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CloudEventsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CloudEventsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CloudEvents numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CloudEventsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CloudEventsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CloudEventsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CloudEvents nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CloudEventsMutation) ResetField(name string) error {
	switch name {
	case cloudevents.FieldEventId:
		m.ResetEventId()
		return nil
	case cloudevents.FieldEvent:
		m.ResetEvent()
		return nil
	case cloudevents.FieldFire:
		m.ResetFire()
		return nil
	case cloudevents.FieldCreated:
		m.ResetCreated()
		return nil
	case cloudevents.FieldProcessed:
		m.ResetProcessed()
		return nil
	}
	return fmt.Errorf("unknown CloudEvents field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CloudEventsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespace != nil {
		edges = append(edges, cloudevents.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CloudEventsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cloudevents.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CloudEventsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CloudEventsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CloudEventsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespace {
		edges = append(edges, cloudevents.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CloudEventsMutation) EdgeCleared(name string) bool {
	switch name {
	case cloudevents.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CloudEventsMutation) ClearEdge(name string) error {
	switch name {
	case cloudevents.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEvents unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CloudEventsMutation) ResetEdge(name string) error {
	switch name {
	case cloudevents.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEvents edge %s", name)
}

// EventsMutation represents an operation that mutates the Events nodes in the graph.
type EventsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	events              *[]map[string]interface{}
	correlations        *[]string
	signature           *[]byte
	count               *int
	addcount            *int
	created_at          *time.Time
	updated_at          *time.Time
	clearedFields       map[string]struct{}
	workflow            *uuid.UUID
	clearedworkflow     bool
	wfeventswait        map[uuid.UUID]struct{}
	removedwfeventswait map[uuid.UUID]struct{}
	clearedwfeventswait bool
	instance            *uuid.UUID
	clearedinstance     bool
	namespace           *uuid.UUID
	clearednamespace    bool
	done                bool
	oldValue            func(context.Context) (*Events, error)
	predicates          []predicate.Events
}

var _ ent.Mutation = (*EventsMutation)(nil)

// eventsOption allows management of the mutation configuration using functional options.
type eventsOption func(*EventsMutation)

// newEventsMutation creates new mutation for the Events entity.
func newEventsMutation(c config, op Op, opts ...eventsOption) *EventsMutation {
	m := &EventsMutation{
		config:        c,
		op:            op,
		typ:           TypeEvents,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventsID sets the ID field of the mutation.
func withEventsID(id uuid.UUID) eventsOption {
	return func(m *EventsMutation) {
		var (
			err   error
			once  sync.Once
			value *Events
		)
		m.oldValue = func(ctx context.Context) (*Events, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Events.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvents sets the old Events of the mutation.
func withEvents(node *Events) eventsOption {
	return func(m *EventsMutation) {
		m.oldValue = func(context.Context) (*Events, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Events entities.
func (m *EventsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Events.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEvents sets the "events" field.
func (m *EventsMutation) SetEvents(value []map[string]interface{}) {
	m.events = &value
}

// Events returns the value of the "events" field in the mutation.
func (m *EventsMutation) Events() (r []map[string]interface{}, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldEvents(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// ResetEvents resets all changes to the "events" field.
func (m *EventsMutation) ResetEvents() {
	m.events = nil
}

// SetCorrelations sets the "correlations" field.
func (m *EventsMutation) SetCorrelations(s []string) {
	m.correlations = &s
}

// Correlations returns the value of the "correlations" field in the mutation.
func (m *EventsMutation) Correlations() (r []string, exists bool) {
	v := m.correlations
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelations returns the old "correlations" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldCorrelations(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelations: %w", err)
	}
	return oldValue.Correlations, nil
}

// ResetCorrelations resets all changes to the "correlations" field.
func (m *EventsMutation) ResetCorrelations() {
	m.correlations = nil
}

// SetSignature sets the "signature" field.
func (m *EventsMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *EventsMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *EventsMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[events.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *EventsMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[events.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *EventsMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, events.FieldSignature)
}

// SetCount sets the "count" field.
func (m *EventsMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *EventsMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *EventsMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *EventsMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *EventsMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *EventsMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *EventsMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *EventsMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *EventsMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *EventsMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *EventsMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddWfeventswaitIDs adds the "wfeventswait" edge to the EventsWait entity by ids.
func (m *EventsMutation) AddWfeventswaitIDs(ids ...uuid.UUID) {
	if m.wfeventswait == nil {
		m.wfeventswait = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.wfeventswait[ids[i]] = struct{}{}
	}
}

// ClearWfeventswait clears the "wfeventswait" edge to the EventsWait entity.
func (m *EventsMutation) ClearWfeventswait() {
	m.clearedwfeventswait = true
}

// WfeventswaitCleared reports if the "wfeventswait" edge to the EventsWait entity was cleared.
func (m *EventsMutation) WfeventswaitCleared() bool {
	return m.clearedwfeventswait
}

// RemoveWfeventswaitIDs removes the "wfeventswait" edge to the EventsWait entity by IDs.
func (m *EventsMutation) RemoveWfeventswaitIDs(ids ...uuid.UUID) {
	if m.removedwfeventswait == nil {
		m.removedwfeventswait = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.wfeventswait, ids[i])
		m.removedwfeventswait[ids[i]] = struct{}{}
	}
}

// RemovedWfeventswait returns the removed IDs of the "wfeventswait" edge to the EventsWait entity.
func (m *EventsMutation) RemovedWfeventswaitIDs() (ids []uuid.UUID) {
	for id := range m.removedwfeventswait {
		ids = append(ids, id)
	}
	return
}

// WfeventswaitIDs returns the "wfeventswait" edge IDs in the mutation.
func (m *EventsMutation) WfeventswaitIDs() (ids []uuid.UUID) {
	for id := range m.wfeventswait {
		ids = append(ids, id)
	}
	return
}

// ResetWfeventswait resets all changes to the "wfeventswait" edge.
func (m *EventsMutation) ResetWfeventswait() {
	m.wfeventswait = nil
	m.clearedwfeventswait = false
	m.removedwfeventswait = nil
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *EventsMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *EventsMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *EventsMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *EventsMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *EventsMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *EventsMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *EventsMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *EventsMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *EventsMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *EventsMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *EventsMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *EventsMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the EventsMutation builder.
func (m *EventsMutation) Where(ps ...predicate.Events) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Events).
func (m *EventsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventsMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.events != nil {
		fields = append(fields, events.FieldEvents)
	}
	if m.correlations != nil {
		fields = append(fields, events.FieldCorrelations)
	}
	if m.signature != nil {
		fields = append(fields, events.FieldSignature)
	}
	if m.count != nil {
		fields = append(fields, events.FieldCount)
	}
	if m.created_at != nil {
		fields = append(fields, events.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, events.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case events.FieldEvents:
		return m.Events()
	case events.FieldCorrelations:
		return m.Correlations()
	case events.FieldSignature:
		return m.Signature()
	case events.FieldCount:
		return m.Count()
	case events.FieldCreatedAt:
		return m.CreatedAt()
	case events.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case events.FieldEvents:
		return m.OldEvents(ctx)
	case events.FieldCorrelations:
		return m.OldCorrelations(ctx)
	case events.FieldSignature:
		return m.OldSignature(ctx)
	case events.FieldCount:
		return m.OldCount(ctx)
	case events.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case events.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Events field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case events.FieldEvents:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	case events.FieldCorrelations:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelations(v)
		return nil
	case events.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case events.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case events.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case events.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Events field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventsMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, events.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case events.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case events.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown Events numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(events.FieldSignature) {
		fields = append(fields, events.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventsMutation) ClearField(name string) error {
	switch name {
	case events.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown Events nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventsMutation) ResetField(name string) error {
	switch name {
	case events.FieldEvents:
		m.ResetEvents()
		return nil
	case events.FieldCorrelations:
		m.ResetCorrelations()
		return nil
	case events.FieldSignature:
		m.ResetSignature()
		return nil
	case events.FieldCount:
		m.ResetCount()
		return nil
	case events.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case events.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Events field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventsMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.workflow != nil {
		edges = append(edges, events.EdgeWorkflow)
	}
	if m.wfeventswait != nil {
		edges = append(edges, events.EdgeWfeventswait)
	}
	if m.instance != nil {
		edges = append(edges, events.EdgeInstance)
	}
	if m.namespace != nil {
		edges = append(edges, events.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case events.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case events.EdgeWfeventswait:
		ids := make([]ent.Value, 0, len(m.wfeventswait))
		for id := range m.wfeventswait {
			ids = append(ids, id)
		}
		return ids
	case events.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	case events.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedwfeventswait != nil {
		edges = append(edges, events.EdgeWfeventswait)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case events.EdgeWfeventswait:
		ids := make([]ent.Value, 0, len(m.removedwfeventswait))
		for id := range m.removedwfeventswait {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedworkflow {
		edges = append(edges, events.EdgeWorkflow)
	}
	if m.clearedwfeventswait {
		edges = append(edges, events.EdgeWfeventswait)
	}
	if m.clearedinstance {
		edges = append(edges, events.EdgeInstance)
	}
	if m.clearednamespace {
		edges = append(edges, events.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventsMutation) EdgeCleared(name string) bool {
	switch name {
	case events.EdgeWorkflow:
		return m.clearedworkflow
	case events.EdgeWfeventswait:
		return m.clearedwfeventswait
	case events.EdgeInstance:
		return m.clearedinstance
	case events.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventsMutation) ClearEdge(name string) error {
	switch name {
	case events.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case events.EdgeInstance:
		m.ClearInstance()
		return nil
	case events.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Events unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventsMutation) ResetEdge(name string) error {
	switch name {
	case events.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case events.EdgeWfeventswait:
		m.ResetWfeventswait()
		return nil
	case events.EdgeInstance:
		m.ResetInstance()
		return nil
	case events.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown Events edge %s", name)
}

// EventsWaitMutation represents an operation that mutates the EventsWait nodes in the graph.
type EventsWaitMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	events               *map[string]interface{}
	clearedFields        map[string]struct{}
	workflowevent        *uuid.UUID
	clearedworkflowevent bool
	done                 bool
	oldValue             func(context.Context) (*EventsWait, error)
	predicates           []predicate.EventsWait
}

var _ ent.Mutation = (*EventsWaitMutation)(nil)

// eventswaitOption allows management of the mutation configuration using functional options.
type eventswaitOption func(*EventsWaitMutation)

// newEventsWaitMutation creates new mutation for the EventsWait entity.
func newEventsWaitMutation(c config, op Op, opts ...eventswaitOption) *EventsWaitMutation {
	m := &EventsWaitMutation{
		config:        c,
		op:            op,
		typ:           TypeEventsWait,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventsWaitID sets the ID field of the mutation.
func withEventsWaitID(id uuid.UUID) eventswaitOption {
	return func(m *EventsWaitMutation) {
		var (
			err   error
			once  sync.Once
			value *EventsWait
		)
		m.oldValue = func(ctx context.Context) (*EventsWait, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventsWait.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventsWait sets the old EventsWait of the mutation.
func withEventsWait(node *EventsWait) eventswaitOption {
	return func(m *EventsWaitMutation) {
		m.oldValue = func(context.Context) (*EventsWait, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventsWaitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventsWaitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventsWait entities.
func (m *EventsWaitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventsWaitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventsWaitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventsWait.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEvents sets the "events" field.
func (m *EventsWaitMutation) SetEvents(value map[string]interface{}) {
	m.events = &value
}

// Events returns the value of the "events" field in the mutation.
func (m *EventsWaitMutation) Events() (r map[string]interface{}, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the EventsWait entity.
// If the EventsWait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsWaitMutation) OldEvents(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// ResetEvents resets all changes to the "events" field.
func (m *EventsWaitMutation) ResetEvents() {
	m.events = nil
}

// SetWorkfloweventID sets the "workflowevent" edge to the Events entity by id.
func (m *EventsWaitMutation) SetWorkfloweventID(id uuid.UUID) {
	m.workflowevent = &id
}

// ClearWorkflowevent clears the "workflowevent" edge to the Events entity.
func (m *EventsWaitMutation) ClearWorkflowevent() {
	m.clearedworkflowevent = true
}

// WorkfloweventCleared reports if the "workflowevent" edge to the Events entity was cleared.
func (m *EventsWaitMutation) WorkfloweventCleared() bool {
	return m.clearedworkflowevent
}

// WorkfloweventID returns the "workflowevent" edge ID in the mutation.
func (m *EventsWaitMutation) WorkfloweventID() (id uuid.UUID, exists bool) {
	if m.workflowevent != nil {
		return *m.workflowevent, true
	}
	return
}

// WorkfloweventIDs returns the "workflowevent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkfloweventID instead. It exists only for internal usage by the builders.
func (m *EventsWaitMutation) WorkfloweventIDs() (ids []uuid.UUID) {
	if id := m.workflowevent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowevent resets all changes to the "workflowevent" edge.
func (m *EventsWaitMutation) ResetWorkflowevent() {
	m.workflowevent = nil
	m.clearedworkflowevent = false
}

// Where appends a list predicates to the EventsWaitMutation builder.
func (m *EventsWaitMutation) Where(ps ...predicate.EventsWait) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventsWaitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EventsWait).
func (m *EventsWaitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventsWaitMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.events != nil {
		fields = append(fields, eventswait.FieldEvents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventsWaitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventswait.FieldEvents:
		return m.Events()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventsWaitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventswait.FieldEvents:
		return m.OldEvents(ctx)
	}
	return nil, fmt.Errorf("unknown EventsWait field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsWaitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventswait.FieldEvents:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	}
	return fmt.Errorf("unknown EventsWait field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventsWaitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventsWaitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsWaitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventsWait numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventsWaitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventsWaitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventsWaitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventsWait nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventsWaitMutation) ResetField(name string) error {
	switch name {
	case eventswait.FieldEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown EventsWait field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventsWaitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflowevent != nil {
		edges = append(edges, eventswait.EdgeWorkflowevent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventsWaitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventswait.EdgeWorkflowevent:
		if id := m.workflowevent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventsWaitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventsWaitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventsWaitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflowevent {
		edges = append(edges, eventswait.EdgeWorkflowevent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventsWaitMutation) EdgeCleared(name string) bool {
	switch name {
	case eventswait.EdgeWorkflowevent:
		return m.clearedworkflowevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventsWaitMutation) ClearEdge(name string) error {
	switch name {
	case eventswait.EdgeWorkflowevent:
		m.ClearWorkflowevent()
		return nil
	}
	return fmt.Errorf("unknown EventsWait unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventsWaitMutation) ResetEdge(name string) error {
	switch name {
	case eventswait.EdgeWorkflowevent:
		m.ResetWorkflowevent()
		return nil
	}
	return fmt.Errorf("unknown EventsWait edge %s", name)
}

// InodeMutation represents an operation that mutates the Inode nodes in the graph.
type InodeMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	name             *string
	_type            *string
	attributes       *[]string
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	children         map[uuid.UUID]struct{}
	removedchildren  map[uuid.UUID]struct{}
	clearedchildren  bool
	parent           *uuid.UUID
	clearedparent    bool
	workflow         *uuid.UUID
	clearedworkflow  bool
	done             bool
	oldValue         func(context.Context) (*Inode, error)
	predicates       []predicate.Inode
}

var _ ent.Mutation = (*InodeMutation)(nil)

// inodeOption allows management of the mutation configuration using functional options.
type inodeOption func(*InodeMutation)

// newInodeMutation creates new mutation for the Inode entity.
func newInodeMutation(c config, op Op, opts ...inodeOption) *InodeMutation {
	m := &InodeMutation{
		config:        c,
		op:            op,
		typ:           TypeInode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInodeID sets the ID field of the mutation.
func withInodeID(id uuid.UUID) inodeOption {
	return func(m *InodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Inode
		)
		m.oldValue = func(ctx context.Context) (*Inode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Inode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInode sets the old Inode of the mutation.
func withInode(node *Inode) inodeOption {
	return func(m *InodeMutation) {
		m.oldValue = func(context.Context) (*Inode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Inode entities.
func (m *InodeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InodeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InodeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Inode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InodeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InodeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InodeMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InodeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InodeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InodeMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetName sets the "name" field.
func (m *InodeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *InodeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *InodeMutation) ClearName() {
	m.name = nil
	m.clearedFields[inode.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *InodeMutation) NameCleared() bool {
	_, ok := m.clearedFields[inode.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *InodeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, inode.FieldName)
}

// SetType sets the "type" field.
func (m *InodeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *InodeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *InodeMutation) ResetType() {
	m._type = nil
}

// SetAttributes sets the "attributes" field.
func (m *InodeMutation) SetAttributes(s []string) {
	m.attributes = &s
}

// Attributes returns the value of the "attributes" field in the mutation.
func (m *InodeMutation) Attributes() (r []string, exists bool) {
	v := m.attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldAttributes returns the old "attributes" field's value of the Inode entity.
// If the Inode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InodeMutation) OldAttributes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttributes: %w", err)
	}
	return oldValue.Attributes, nil
}

// ClearAttributes clears the value of the "attributes" field.
func (m *InodeMutation) ClearAttributes() {
	m.attributes = nil
	m.clearedFields[inode.FieldAttributes] = struct{}{}
}

// AttributesCleared returns if the "attributes" field was cleared in this mutation.
func (m *InodeMutation) AttributesCleared() bool {
	_, ok := m.clearedFields[inode.FieldAttributes]
	return ok
}

// ResetAttributes resets all changes to the "attributes" field.
func (m *InodeMutation) ResetAttributes() {
	m.attributes = nil
	delete(m.clearedFields, inode.FieldAttributes)
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *InodeMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *InodeMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *InodeMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *InodeMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *InodeMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *InodeMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddChildIDs adds the "children" edge to the Inode entity by ids.
func (m *InodeMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Inode entity.
func (m *InodeMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Inode entity was cleared.
func (m *InodeMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Inode entity by IDs.
func (m *InodeMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Inode entity.
func (m *InodeMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *InodeMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *InodeMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentID sets the "parent" edge to the Inode entity by id.
func (m *InodeMutation) SetParentID(id uuid.UUID) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Inode entity.
func (m *InodeMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Inode entity was cleared.
func (m *InodeMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *InodeMutation) ParentID() (id uuid.UUID, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *InodeMutation) ParentIDs() (ids []uuid.UUID) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *InodeMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *InodeMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *InodeMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *InodeMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *InodeMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *InodeMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *InodeMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// Where appends a list predicates to the InodeMutation builder.
func (m *InodeMutation) Where(ps ...predicate.Inode) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InodeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Inode).
func (m *InodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InodeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, inode.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, inode.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, inode.FieldName)
	}
	if m._type != nil {
		fields = append(fields, inode.FieldType)
	}
	if m.attributes != nil {
		fields = append(fields, inode.FieldAttributes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inode.FieldCreatedAt:
		return m.CreatedAt()
	case inode.FieldUpdatedAt:
		return m.UpdatedAt()
	case inode.FieldName:
		return m.Name()
	case inode.FieldType:
		return m.GetType()
	case inode.FieldAttributes:
		return m.Attributes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inode.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case inode.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case inode.FieldName:
		return m.OldName(ctx)
	case inode.FieldType:
		return m.OldType(ctx)
	case inode.FieldAttributes:
		return m.OldAttributes(ctx)
	}
	return nil, fmt.Errorf("unknown Inode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inode.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case inode.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case inode.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case inode.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case inode.FieldAttributes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttributes(v)
		return nil
	}
	return fmt.Errorf("unknown Inode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Inode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inode.FieldName) {
		fields = append(fields, inode.FieldName)
	}
	if m.FieldCleared(inode.FieldAttributes) {
		fields = append(fields, inode.FieldAttributes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InodeMutation) ClearField(name string) error {
	switch name {
	case inode.FieldName:
		m.ClearName()
		return nil
	case inode.FieldAttributes:
		m.ClearAttributes()
		return nil
	}
	return fmt.Errorf("unknown Inode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InodeMutation) ResetField(name string) error {
	switch name {
	case inode.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case inode.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case inode.FieldName:
		m.ResetName()
		return nil
	case inode.FieldType:
		m.ResetType()
		return nil
	case inode.FieldAttributes:
		m.ResetAttributes()
		return nil
	}
	return fmt.Errorf("unknown Inode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.namespace != nil {
		edges = append(edges, inode.EdgeNamespace)
	}
	if m.children != nil {
		edges = append(edges, inode.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, inode.EdgeParent)
	}
	if m.workflow != nil {
		edges = append(edges, inode.EdgeWorkflow)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inode.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case inode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case inode.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case inode.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, inode.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InodeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inode.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearednamespace {
		edges = append(edges, inode.EdgeNamespace)
	}
	if m.clearedchildren {
		edges = append(edges, inode.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, inode.EdgeParent)
	}
	if m.clearedworkflow {
		edges = append(edges, inode.EdgeWorkflow)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InodeMutation) EdgeCleared(name string) bool {
	switch name {
	case inode.EdgeNamespace:
		return m.clearednamespace
	case inode.EdgeChildren:
		return m.clearedchildren
	case inode.EdgeParent:
		return m.clearedparent
	case inode.EdgeWorkflow:
		return m.clearedworkflow
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InodeMutation) ClearEdge(name string) error {
	switch name {
	case inode.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case inode.EdgeParent:
		m.ClearParent()
		return nil
	case inode.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown Inode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InodeMutation) ResetEdge(name string) error {
	switch name {
	case inode.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case inode.EdgeChildren:
		m.ResetChildren()
		return nil
	case inode.EdgeParent:
		m.ResetParent()
		return nil
	case inode.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	}
	return fmt.Errorf("unknown Inode edge %s", name)
}

// InstanceMutation represents an operation that mutates the Instance nodes in the graph.
type InstanceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	end_at                *time.Time
	status                *string
	as                    *string
	errorCode             *string
	errorMessage          *string
	invoker               *string
	clearedFields         map[string]struct{}
	namespace             *uuid.UUID
	clearednamespace      bool
	workflow              *uuid.UUID
	clearedworkflow       bool
	revision              *uuid.UUID
	clearedrevision       bool
	logs                  map[uuid.UUID]struct{}
	removedlogs           map[uuid.UUID]struct{}
	clearedlogs           bool
	vars                  map[uuid.UUID]struct{}
	removedvars           map[uuid.UUID]struct{}
	clearedvars           bool
	runtime               *uuid.UUID
	clearedruntime        bool
	children              map[uuid.UUID]struct{}
	removedchildren       map[uuid.UUID]struct{}
	clearedchildren       bool
	eventlisteners        map[uuid.UUID]struct{}
	removedeventlisteners map[uuid.UUID]struct{}
	clearedeventlisteners bool
	done                  bool
	oldValue              func(context.Context) (*Instance, error)
	predicates            []predicate.Instance
}

var _ ent.Mutation = (*InstanceMutation)(nil)

// instanceOption allows management of the mutation configuration using functional options.
type instanceOption func(*InstanceMutation)

// newInstanceMutation creates new mutation for the Instance entity.
func newInstanceMutation(c config, op Op, opts ...instanceOption) *InstanceMutation {
	m := &InstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceID sets the ID field of the mutation.
func withInstanceID(id uuid.UUID) instanceOption {
	return func(m *InstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Instance
		)
		m.oldValue = func(ctx context.Context) (*Instance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Instance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstance sets the old Instance of the mutation.
func withInstance(node *Instance) instanceOption {
	return func(m *InstanceMutation) {
		m.oldValue = func(context.Context) (*Instance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Instance entities.
func (m *InstanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Instance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *InstanceMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *InstanceMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *InstanceMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[instance.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *InstanceMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[instance.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *InstanceMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, instance.FieldEndAt)
}

// SetStatus sets the "status" field.
func (m *InstanceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *InstanceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InstanceMutation) ResetStatus() {
	m.status = nil
}

// SetAs sets the "as" field.
func (m *InstanceMutation) SetAs(s string) {
	m.as = &s
}

// As returns the value of the "as" field in the mutation.
func (m *InstanceMutation) As() (r string, exists bool) {
	v := m.as
	if v == nil {
		return
	}
	return *v, true
}

// OldAs returns the old "as" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldAs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAs: %w", err)
	}
	return oldValue.As, nil
}

// ResetAs resets all changes to the "as" field.
func (m *InstanceMutation) ResetAs() {
	m.as = nil
}

// SetErrorCode sets the "errorCode" field.
func (m *InstanceMutation) SetErrorCode(s string) {
	m.errorCode = &s
}

// ErrorCode returns the value of the "errorCode" field in the mutation.
func (m *InstanceMutation) ErrorCode() (r string, exists bool) {
	v := m.errorCode
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "errorCode" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// ClearErrorCode clears the value of the "errorCode" field.
func (m *InstanceMutation) ClearErrorCode() {
	m.errorCode = nil
	m.clearedFields[instance.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "errorCode" field was cleared in this mutation.
func (m *InstanceMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[instance.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "errorCode" field.
func (m *InstanceMutation) ResetErrorCode() {
	m.errorCode = nil
	delete(m.clearedFields, instance.FieldErrorCode)
}

// SetErrorMessage sets the "errorMessage" field.
func (m *InstanceMutation) SetErrorMessage(s string) {
	m.errorMessage = &s
}

// ErrorMessage returns the value of the "errorMessage" field in the mutation.
func (m *InstanceMutation) ErrorMessage() (r string, exists bool) {
	v := m.errorMessage
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "errorMessage" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "errorMessage" field.
func (m *InstanceMutation) ClearErrorMessage() {
	m.errorMessage = nil
	m.clearedFields[instance.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "errorMessage" field was cleared in this mutation.
func (m *InstanceMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[instance.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "errorMessage" field.
func (m *InstanceMutation) ResetErrorMessage() {
	m.errorMessage = nil
	delete(m.clearedFields, instance.FieldErrorMessage)
}

// SetInvoker sets the "invoker" field.
func (m *InstanceMutation) SetInvoker(s string) {
	m.invoker = &s
}

// Invoker returns the value of the "invoker" field in the mutation.
func (m *InstanceMutation) Invoker() (r string, exists bool) {
	v := m.invoker
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoker returns the old "invoker" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldInvoker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoker: %w", err)
	}
	return oldValue.Invoker, nil
}

// ClearInvoker clears the value of the "invoker" field.
func (m *InstanceMutation) ClearInvoker() {
	m.invoker = nil
	m.clearedFields[instance.FieldInvoker] = struct{}{}
}

// InvokerCleared returns if the "invoker" field was cleared in this mutation.
func (m *InstanceMutation) InvokerCleared() bool {
	_, ok := m.clearedFields[instance.FieldInvoker]
	return ok
}

// ResetInvoker resets all changes to the "invoker" field.
func (m *InstanceMutation) ResetInvoker() {
	m.invoker = nil
	delete(m.clearedFields, instance.FieldInvoker)
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *InstanceMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *InstanceMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *InstanceMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *InstanceMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *InstanceMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *InstanceMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *InstanceMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *InstanceMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *InstanceMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *InstanceMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetRevisionID sets the "revision" edge to the Revision entity by id.
func (m *InstanceMutation) SetRevisionID(id uuid.UUID) {
	m.revision = &id
}

// ClearRevision clears the "revision" edge to the Revision entity.
func (m *InstanceMutation) ClearRevision() {
	m.clearedrevision = true
}

// RevisionCleared reports if the "revision" edge to the Revision entity was cleared.
func (m *InstanceMutation) RevisionCleared() bool {
	return m.clearedrevision
}

// RevisionID returns the "revision" edge ID in the mutation.
func (m *InstanceMutation) RevisionID() (id uuid.UUID, exists bool) {
	if m.revision != nil {
		return *m.revision, true
	}
	return
}

// RevisionIDs returns the "revision" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevisionID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) RevisionIDs() (ids []uuid.UUID) {
	if id := m.revision; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevision resets all changes to the "revision" edge.
func (m *InstanceMutation) ResetRevision() {
	m.revision = nil
	m.clearedrevision = false
}

// AddLogIDs adds the "logs" edge to the LogMsg entity by ids.
func (m *InstanceMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the LogMsg entity.
func (m *InstanceMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the LogMsg entity was cleared.
func (m *InstanceMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the LogMsg entity by IDs.
func (m *InstanceMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the LogMsg entity.
func (m *InstanceMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *InstanceMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *InstanceMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddVarIDs adds the "vars" edge to the VarRef entity by ids.
func (m *InstanceMutation) AddVarIDs(ids ...uuid.UUID) {
	if m.vars == nil {
		m.vars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vars[ids[i]] = struct{}{}
	}
}

// ClearVars clears the "vars" edge to the VarRef entity.
func (m *InstanceMutation) ClearVars() {
	m.clearedvars = true
}

// VarsCleared reports if the "vars" edge to the VarRef entity was cleared.
func (m *InstanceMutation) VarsCleared() bool {
	return m.clearedvars
}

// RemoveVarIDs removes the "vars" edge to the VarRef entity by IDs.
func (m *InstanceMutation) RemoveVarIDs(ids ...uuid.UUID) {
	if m.removedvars == nil {
		m.removedvars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vars, ids[i])
		m.removedvars[ids[i]] = struct{}{}
	}
}

// RemovedVars returns the removed IDs of the "vars" edge to the VarRef entity.
func (m *InstanceMutation) RemovedVarsIDs() (ids []uuid.UUID) {
	for id := range m.removedvars {
		ids = append(ids, id)
	}
	return
}

// VarsIDs returns the "vars" edge IDs in the mutation.
func (m *InstanceMutation) VarsIDs() (ids []uuid.UUID) {
	for id := range m.vars {
		ids = append(ids, id)
	}
	return
}

// ResetVars resets all changes to the "vars" edge.
func (m *InstanceMutation) ResetVars() {
	m.vars = nil
	m.clearedvars = false
	m.removedvars = nil
}

// SetRuntimeID sets the "runtime" edge to the InstanceRuntime entity by id.
func (m *InstanceMutation) SetRuntimeID(id uuid.UUID) {
	m.runtime = &id
}

// ClearRuntime clears the "runtime" edge to the InstanceRuntime entity.
func (m *InstanceMutation) ClearRuntime() {
	m.clearedruntime = true
}

// RuntimeCleared reports if the "runtime" edge to the InstanceRuntime entity was cleared.
func (m *InstanceMutation) RuntimeCleared() bool {
	return m.clearedruntime
}

// RuntimeID returns the "runtime" edge ID in the mutation.
func (m *InstanceMutation) RuntimeID() (id uuid.UUID, exists bool) {
	if m.runtime != nil {
		return *m.runtime, true
	}
	return
}

// RuntimeIDs returns the "runtime" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuntimeID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) RuntimeIDs() (ids []uuid.UUID) {
	if id := m.runtime; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRuntime resets all changes to the "runtime" edge.
func (m *InstanceMutation) ResetRuntime() {
	m.runtime = nil
	m.clearedruntime = false
}

// AddChildIDs adds the "children" edge to the InstanceRuntime entity by ids.
func (m *InstanceMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the InstanceRuntime entity.
func (m *InstanceMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the InstanceRuntime entity was cleared.
func (m *InstanceMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the InstanceRuntime entity by IDs.
func (m *InstanceMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the InstanceRuntime entity.
func (m *InstanceMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *InstanceMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *InstanceMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddEventlistenerIDs adds the "eventlisteners" edge to the Events entity by ids.
func (m *InstanceMutation) AddEventlistenerIDs(ids ...uuid.UUID) {
	if m.eventlisteners == nil {
		m.eventlisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.eventlisteners[ids[i]] = struct{}{}
	}
}

// ClearEventlisteners clears the "eventlisteners" edge to the Events entity.
func (m *InstanceMutation) ClearEventlisteners() {
	m.clearedeventlisteners = true
}

// EventlistenersCleared reports if the "eventlisteners" edge to the Events entity was cleared.
func (m *InstanceMutation) EventlistenersCleared() bool {
	return m.clearedeventlisteners
}

// RemoveEventlistenerIDs removes the "eventlisteners" edge to the Events entity by IDs.
func (m *InstanceMutation) RemoveEventlistenerIDs(ids ...uuid.UUID) {
	if m.removedeventlisteners == nil {
		m.removedeventlisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.eventlisteners, ids[i])
		m.removedeventlisteners[ids[i]] = struct{}{}
	}
}

// RemovedEventlisteners returns the removed IDs of the "eventlisteners" edge to the Events entity.
func (m *InstanceMutation) RemovedEventlistenersIDs() (ids []uuid.UUID) {
	for id := range m.removedeventlisteners {
		ids = append(ids, id)
	}
	return
}

// EventlistenersIDs returns the "eventlisteners" edge IDs in the mutation.
func (m *InstanceMutation) EventlistenersIDs() (ids []uuid.UUID) {
	for id := range m.eventlisteners {
		ids = append(ids, id)
	}
	return
}

// ResetEventlisteners resets all changes to the "eventlisteners" edge.
func (m *InstanceMutation) ResetEventlisteners() {
	m.eventlisteners = nil
	m.clearedeventlisteners = false
	m.removedeventlisteners = nil
}

// Where appends a list predicates to the InstanceMutation builder.
func (m *InstanceMutation) Where(ps ...predicate.Instance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Instance).
func (m *InstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, instance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, instance.FieldUpdatedAt)
	}
	if m.end_at != nil {
		fields = append(fields, instance.FieldEndAt)
	}
	if m.status != nil {
		fields = append(fields, instance.FieldStatus)
	}
	if m.as != nil {
		fields = append(fields, instance.FieldAs)
	}
	if m.errorCode != nil {
		fields = append(fields, instance.FieldErrorCode)
	}
	if m.errorMessage != nil {
		fields = append(fields, instance.FieldErrorMessage)
	}
	if m.invoker != nil {
		fields = append(fields, instance.FieldInvoker)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instance.FieldCreatedAt:
		return m.CreatedAt()
	case instance.FieldUpdatedAt:
		return m.UpdatedAt()
	case instance.FieldEndAt:
		return m.EndAt()
	case instance.FieldStatus:
		return m.Status()
	case instance.FieldAs:
		return m.As()
	case instance.FieldErrorCode:
		return m.ErrorCode()
	case instance.FieldErrorMessage:
		return m.ErrorMessage()
	case instance.FieldInvoker:
		return m.Invoker()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case instance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case instance.FieldEndAt:
		return m.OldEndAt(ctx)
	case instance.FieldStatus:
		return m.OldStatus(ctx)
	case instance.FieldAs:
		return m.OldAs(ctx)
	case instance.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case instance.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case instance.FieldInvoker:
		return m.OldInvoker(ctx)
	}
	return nil, fmt.Errorf("unknown Instance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case instance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case instance.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case instance.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case instance.FieldAs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAs(v)
		return nil
	case instance.FieldErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case instance.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case instance.FieldInvoker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoker(v)
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Instance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(instance.FieldEndAt) {
		fields = append(fields, instance.FieldEndAt)
	}
	if m.FieldCleared(instance.FieldErrorCode) {
		fields = append(fields, instance.FieldErrorCode)
	}
	if m.FieldCleared(instance.FieldErrorMessage) {
		fields = append(fields, instance.FieldErrorMessage)
	}
	if m.FieldCleared(instance.FieldInvoker) {
		fields = append(fields, instance.FieldInvoker)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceMutation) ClearField(name string) error {
	switch name {
	case instance.FieldEndAt:
		m.ClearEndAt()
		return nil
	case instance.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case instance.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case instance.FieldInvoker:
		m.ClearInvoker()
		return nil
	}
	return fmt.Errorf("unknown Instance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceMutation) ResetField(name string) error {
	switch name {
	case instance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case instance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case instance.FieldEndAt:
		m.ResetEndAt()
		return nil
	case instance.FieldStatus:
		m.ResetStatus()
		return nil
	case instance.FieldAs:
		m.ResetAs()
		return nil
	case instance.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case instance.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case instance.FieldInvoker:
		m.ResetInvoker()
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.namespace != nil {
		edges = append(edges, instance.EdgeNamespace)
	}
	if m.workflow != nil {
		edges = append(edges, instance.EdgeWorkflow)
	}
	if m.revision != nil {
		edges = append(edges, instance.EdgeRevision)
	}
	if m.logs != nil {
		edges = append(edges, instance.EdgeLogs)
	}
	if m.vars != nil {
		edges = append(edges, instance.EdgeVars)
	}
	if m.runtime != nil {
		edges = append(edges, instance.EdgeRuntime)
	}
	if m.children != nil {
		edges = append(edges, instance.EdgeChildren)
	}
	if m.eventlisteners != nil {
		edges = append(edges, instance.EdgeEventlisteners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeRevision:
		if id := m.revision; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeVars:
		ids := make([]ent.Value, 0, len(m.vars))
		for id := range m.vars {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeRuntime:
		if id := m.runtime; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeEventlisteners:
		ids := make([]ent.Value, 0, len(m.eventlisteners))
		for id := range m.eventlisteners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedlogs != nil {
		edges = append(edges, instance.EdgeLogs)
	}
	if m.removedvars != nil {
		edges = append(edges, instance.EdgeVars)
	}
	if m.removedchildren != nil {
		edges = append(edges, instance.EdgeChildren)
	}
	if m.removedeventlisteners != nil {
		edges = append(edges, instance.EdgeEventlisteners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeVars:
		ids := make([]ent.Value, 0, len(m.removedvars))
		for id := range m.removedvars {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeEventlisteners:
		ids := make([]ent.Value, 0, len(m.removedeventlisteners))
		for id := range m.removedeventlisteners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearednamespace {
		edges = append(edges, instance.EdgeNamespace)
	}
	if m.clearedworkflow {
		edges = append(edges, instance.EdgeWorkflow)
	}
	if m.clearedrevision {
		edges = append(edges, instance.EdgeRevision)
	}
	if m.clearedlogs {
		edges = append(edges, instance.EdgeLogs)
	}
	if m.clearedvars {
		edges = append(edges, instance.EdgeVars)
	}
	if m.clearedruntime {
		edges = append(edges, instance.EdgeRuntime)
	}
	if m.clearedchildren {
		edges = append(edges, instance.EdgeChildren)
	}
	if m.clearedeventlisteners {
		edges = append(edges, instance.EdgeEventlisteners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case instance.EdgeNamespace:
		return m.clearednamespace
	case instance.EdgeWorkflow:
		return m.clearedworkflow
	case instance.EdgeRevision:
		return m.clearedrevision
	case instance.EdgeLogs:
		return m.clearedlogs
	case instance.EdgeVars:
		return m.clearedvars
	case instance.EdgeRuntime:
		return m.clearedruntime
	case instance.EdgeChildren:
		return m.clearedchildren
	case instance.EdgeEventlisteners:
		return m.clearedeventlisteners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceMutation) ClearEdge(name string) error {
	switch name {
	case instance.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case instance.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case instance.EdgeRevision:
		m.ClearRevision()
		return nil
	case instance.EdgeRuntime:
		m.ClearRuntime()
		return nil
	}
	return fmt.Errorf("unknown Instance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceMutation) ResetEdge(name string) error {
	switch name {
	case instance.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case instance.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case instance.EdgeRevision:
		m.ResetRevision()
		return nil
	case instance.EdgeLogs:
		m.ResetLogs()
		return nil
	case instance.EdgeVars:
		m.ResetVars()
		return nil
	case instance.EdgeRuntime:
		m.ResetRuntime()
		return nil
	case instance.EdgeChildren:
		m.ResetChildren()
		return nil
	case instance.EdgeEventlisteners:
		m.ResetEventlisteners()
		return nil
	}
	return fmt.Errorf("unknown Instance edge %s", name)
}

// InstanceRuntimeMutation represents an operation that mutates the InstanceRuntime nodes in the graph.
type InstanceRuntimeMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	input           *[]byte
	data            *string
	controller      *string
	memory          *string
	flow            *[]string
	output          *string
	stateBeginTime  *time.Time
	deadline        *time.Time
	attempts        *int
	addattempts     *int
	caller_data     *string
	instanceContext *string
	stateContext    *string
	metadata        *string
	clearedFields   map[string]struct{}
	instance        *uuid.UUID
	clearedinstance bool
	caller          *uuid.UUID
	clearedcaller   bool
	done            bool
	oldValue        func(context.Context) (*InstanceRuntime, error)
	predicates      []predicate.InstanceRuntime
}

var _ ent.Mutation = (*InstanceRuntimeMutation)(nil)

// instanceruntimeOption allows management of the mutation configuration using functional options.
type instanceruntimeOption func(*InstanceRuntimeMutation)

// newInstanceRuntimeMutation creates new mutation for the InstanceRuntime entity.
func newInstanceRuntimeMutation(c config, op Op, opts ...instanceruntimeOption) *InstanceRuntimeMutation {
	m := &InstanceRuntimeMutation{
		config:        c,
		op:            op,
		typ:           TypeInstanceRuntime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceRuntimeID sets the ID field of the mutation.
func withInstanceRuntimeID(id uuid.UUID) instanceruntimeOption {
	return func(m *InstanceRuntimeMutation) {
		var (
			err   error
			once  sync.Once
			value *InstanceRuntime
		)
		m.oldValue = func(ctx context.Context) (*InstanceRuntime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstanceRuntime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstanceRuntime sets the old InstanceRuntime of the mutation.
func withInstanceRuntime(node *InstanceRuntime) instanceruntimeOption {
	return func(m *InstanceRuntimeMutation) {
		m.oldValue = func(context.Context) (*InstanceRuntime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceRuntimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceRuntimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstanceRuntime entities.
func (m *InstanceRuntimeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceRuntimeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceRuntimeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstanceRuntime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInput sets the "input" field.
func (m *InstanceRuntimeMutation) SetInput(b []byte) {
	m.input = &b
}

// Input returns the value of the "input" field in the mutation.
func (m *InstanceRuntimeMutation) Input() (r []byte, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldInput(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *InstanceRuntimeMutation) ResetInput() {
	m.input = nil
}

// SetData sets the "data" field.
func (m *InstanceRuntimeMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *InstanceRuntimeMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *InstanceRuntimeMutation) ResetData() {
	m.data = nil
}

// SetController sets the "controller" field.
func (m *InstanceRuntimeMutation) SetController(s string) {
	m.controller = &s
}

// Controller returns the value of the "controller" field in the mutation.
func (m *InstanceRuntimeMutation) Controller() (r string, exists bool) {
	v := m.controller
	if v == nil {
		return
	}
	return *v, true
}

// OldController returns the old "controller" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldController(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldController: %w", err)
	}
	return oldValue.Controller, nil
}

// ClearController clears the value of the "controller" field.
func (m *InstanceRuntimeMutation) ClearController() {
	m.controller = nil
	m.clearedFields[instanceruntime.FieldController] = struct{}{}
}

// ControllerCleared returns if the "controller" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) ControllerCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldController]
	return ok
}

// ResetController resets all changes to the "controller" field.
func (m *InstanceRuntimeMutation) ResetController() {
	m.controller = nil
	delete(m.clearedFields, instanceruntime.FieldController)
}

// SetMemory sets the "memory" field.
func (m *InstanceRuntimeMutation) SetMemory(s string) {
	m.memory = &s
}

// Memory returns the value of the "memory" field in the mutation.
func (m *InstanceRuntimeMutation) Memory() (r string, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldMemory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// ClearMemory clears the value of the "memory" field.
func (m *InstanceRuntimeMutation) ClearMemory() {
	m.memory = nil
	m.clearedFields[instanceruntime.FieldMemory] = struct{}{}
}

// MemoryCleared returns if the "memory" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) MemoryCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldMemory]
	return ok
}

// ResetMemory resets all changes to the "memory" field.
func (m *InstanceRuntimeMutation) ResetMemory() {
	m.memory = nil
	delete(m.clearedFields, instanceruntime.FieldMemory)
}

// SetFlow sets the "flow" field.
func (m *InstanceRuntimeMutation) SetFlow(s []string) {
	m.flow = &s
}

// Flow returns the value of the "flow" field in the mutation.
func (m *InstanceRuntimeMutation) Flow() (r []string, exists bool) {
	v := m.flow
	if v == nil {
		return
	}
	return *v, true
}

// OldFlow returns the old "flow" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldFlow(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlow: %w", err)
	}
	return oldValue.Flow, nil
}

// ClearFlow clears the value of the "flow" field.
func (m *InstanceRuntimeMutation) ClearFlow() {
	m.flow = nil
	m.clearedFields[instanceruntime.FieldFlow] = struct{}{}
}

// FlowCleared returns if the "flow" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) FlowCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldFlow]
	return ok
}

// ResetFlow resets all changes to the "flow" field.
func (m *InstanceRuntimeMutation) ResetFlow() {
	m.flow = nil
	delete(m.clearedFields, instanceruntime.FieldFlow)
}

// SetOutput sets the "output" field.
func (m *InstanceRuntimeMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *InstanceRuntimeMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *InstanceRuntimeMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[instanceruntime.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) OutputCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *InstanceRuntimeMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, instanceruntime.FieldOutput)
}

// SetStateBeginTime sets the "stateBeginTime" field.
func (m *InstanceRuntimeMutation) SetStateBeginTime(t time.Time) {
	m.stateBeginTime = &t
}

// StateBeginTime returns the value of the "stateBeginTime" field in the mutation.
func (m *InstanceRuntimeMutation) StateBeginTime() (r time.Time, exists bool) {
	v := m.stateBeginTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStateBeginTime returns the old "stateBeginTime" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldStateBeginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateBeginTime: %w", err)
	}
	return oldValue.StateBeginTime, nil
}

// ClearStateBeginTime clears the value of the "stateBeginTime" field.
func (m *InstanceRuntimeMutation) ClearStateBeginTime() {
	m.stateBeginTime = nil
	m.clearedFields[instanceruntime.FieldStateBeginTime] = struct{}{}
}

// StateBeginTimeCleared returns if the "stateBeginTime" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) StateBeginTimeCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldStateBeginTime]
	return ok
}

// ResetStateBeginTime resets all changes to the "stateBeginTime" field.
func (m *InstanceRuntimeMutation) ResetStateBeginTime() {
	m.stateBeginTime = nil
	delete(m.clearedFields, instanceruntime.FieldStateBeginTime)
}

// SetDeadline sets the "deadline" field.
func (m *InstanceRuntimeMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *InstanceRuntimeMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ClearDeadline clears the value of the "deadline" field.
func (m *InstanceRuntimeMutation) ClearDeadline() {
	m.deadline = nil
	m.clearedFields[instanceruntime.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *InstanceRuntimeMutation) ResetDeadline() {
	m.deadline = nil
	delete(m.clearedFields, instanceruntime.FieldDeadline)
}

// SetAttempts sets the "attempts" field.
func (m *InstanceRuntimeMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *InstanceRuntimeMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *InstanceRuntimeMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *InstanceRuntimeMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ClearAttempts clears the value of the "attempts" field.
func (m *InstanceRuntimeMutation) ClearAttempts() {
	m.attempts = nil
	m.addattempts = nil
	m.clearedFields[instanceruntime.FieldAttempts] = struct{}{}
}

// AttemptsCleared returns if the "attempts" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) AttemptsCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldAttempts]
	return ok
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *InstanceRuntimeMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
	delete(m.clearedFields, instanceruntime.FieldAttempts)
}

// SetCallerData sets the "caller_data" field.
func (m *InstanceRuntimeMutation) SetCallerData(s string) {
	m.caller_data = &s
}

// CallerData returns the value of the "caller_data" field in the mutation.
func (m *InstanceRuntimeMutation) CallerData() (r string, exists bool) {
	v := m.caller_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCallerData returns the old "caller_data" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldCallerData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallerData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallerData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallerData: %w", err)
	}
	return oldValue.CallerData, nil
}

// ClearCallerData clears the value of the "caller_data" field.
func (m *InstanceRuntimeMutation) ClearCallerData() {
	m.caller_data = nil
	m.clearedFields[instanceruntime.FieldCallerData] = struct{}{}
}

// CallerDataCleared returns if the "caller_data" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) CallerDataCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldCallerData]
	return ok
}

// ResetCallerData resets all changes to the "caller_data" field.
func (m *InstanceRuntimeMutation) ResetCallerData() {
	m.caller_data = nil
	delete(m.clearedFields, instanceruntime.FieldCallerData)
}

// SetInstanceContext sets the "instanceContext" field.
func (m *InstanceRuntimeMutation) SetInstanceContext(s string) {
	m.instanceContext = &s
}

// InstanceContext returns the value of the "instanceContext" field in the mutation.
func (m *InstanceRuntimeMutation) InstanceContext() (r string, exists bool) {
	v := m.instanceContext
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceContext returns the old "instanceContext" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldInstanceContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceContext: %w", err)
	}
	return oldValue.InstanceContext, nil
}

// ClearInstanceContext clears the value of the "instanceContext" field.
func (m *InstanceRuntimeMutation) ClearInstanceContext() {
	m.instanceContext = nil
	m.clearedFields[instanceruntime.FieldInstanceContext] = struct{}{}
}

// InstanceContextCleared returns if the "instanceContext" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) InstanceContextCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldInstanceContext]
	return ok
}

// ResetInstanceContext resets all changes to the "instanceContext" field.
func (m *InstanceRuntimeMutation) ResetInstanceContext() {
	m.instanceContext = nil
	delete(m.clearedFields, instanceruntime.FieldInstanceContext)
}

// SetStateContext sets the "stateContext" field.
func (m *InstanceRuntimeMutation) SetStateContext(s string) {
	m.stateContext = &s
}

// StateContext returns the value of the "stateContext" field in the mutation.
func (m *InstanceRuntimeMutation) StateContext() (r string, exists bool) {
	v := m.stateContext
	if v == nil {
		return
	}
	return *v, true
}

// OldStateContext returns the old "stateContext" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldStateContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateContext: %w", err)
	}
	return oldValue.StateContext, nil
}

// ClearStateContext clears the value of the "stateContext" field.
func (m *InstanceRuntimeMutation) ClearStateContext() {
	m.stateContext = nil
	m.clearedFields[instanceruntime.FieldStateContext] = struct{}{}
}

// StateContextCleared returns if the "stateContext" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) StateContextCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldStateContext]
	return ok
}

// ResetStateContext resets all changes to the "stateContext" field.
func (m *InstanceRuntimeMutation) ResetStateContext() {
	m.stateContext = nil
	delete(m.clearedFields, instanceruntime.FieldStateContext)
}

// SetMetadata sets the "metadata" field.
func (m *InstanceRuntimeMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *InstanceRuntimeMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *InstanceRuntimeMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[instanceruntime.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *InstanceRuntimeMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, instanceruntime.FieldMetadata)
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *InstanceRuntimeMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *InstanceRuntimeMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *InstanceRuntimeMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *InstanceRuntimeMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *InstanceRuntimeMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *InstanceRuntimeMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// SetCallerID sets the "caller" edge to the Instance entity by id.
func (m *InstanceRuntimeMutation) SetCallerID(id uuid.UUID) {
	m.caller = &id
}

// ClearCaller clears the "caller" edge to the Instance entity.
func (m *InstanceRuntimeMutation) ClearCaller() {
	m.clearedcaller = true
}

// CallerCleared reports if the "caller" edge to the Instance entity was cleared.
func (m *InstanceRuntimeMutation) CallerCleared() bool {
	return m.clearedcaller
}

// CallerID returns the "caller" edge ID in the mutation.
func (m *InstanceRuntimeMutation) CallerID() (id uuid.UUID, exists bool) {
	if m.caller != nil {
		return *m.caller, true
	}
	return
}

// CallerIDs returns the "caller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallerID instead. It exists only for internal usage by the builders.
func (m *InstanceRuntimeMutation) CallerIDs() (ids []uuid.UUID) {
	if id := m.caller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCaller resets all changes to the "caller" edge.
func (m *InstanceRuntimeMutation) ResetCaller() {
	m.caller = nil
	m.clearedcaller = false
}

// Where appends a list predicates to the InstanceRuntimeMutation builder.
func (m *InstanceRuntimeMutation) Where(ps ...predicate.InstanceRuntime) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *InstanceRuntimeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (InstanceRuntime).
func (m *InstanceRuntimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceRuntimeMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.input != nil {
		fields = append(fields, instanceruntime.FieldInput)
	}
	if m.data != nil {
		fields = append(fields, instanceruntime.FieldData)
	}
	if m.controller != nil {
		fields = append(fields, instanceruntime.FieldController)
	}
	if m.memory != nil {
		fields = append(fields, instanceruntime.FieldMemory)
	}
	if m.flow != nil {
		fields = append(fields, instanceruntime.FieldFlow)
	}
	if m.output != nil {
		fields = append(fields, instanceruntime.FieldOutput)
	}
	if m.stateBeginTime != nil {
		fields = append(fields, instanceruntime.FieldStateBeginTime)
	}
	if m.deadline != nil {
		fields = append(fields, instanceruntime.FieldDeadline)
	}
	if m.attempts != nil {
		fields = append(fields, instanceruntime.FieldAttempts)
	}
	if m.caller_data != nil {
		fields = append(fields, instanceruntime.FieldCallerData)
	}
	if m.instanceContext != nil {
		fields = append(fields, instanceruntime.FieldInstanceContext)
	}
	if m.stateContext != nil {
		fields = append(fields, instanceruntime.FieldStateContext)
	}
	if m.metadata != nil {
		fields = append(fields, instanceruntime.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceRuntimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instanceruntime.FieldInput:
		return m.Input()
	case instanceruntime.FieldData:
		return m.Data()
	case instanceruntime.FieldController:
		return m.Controller()
	case instanceruntime.FieldMemory:
		return m.Memory()
	case instanceruntime.FieldFlow:
		return m.Flow()
	case instanceruntime.FieldOutput:
		return m.Output()
	case instanceruntime.FieldStateBeginTime:
		return m.StateBeginTime()
	case instanceruntime.FieldDeadline:
		return m.Deadline()
	case instanceruntime.FieldAttempts:
		return m.Attempts()
	case instanceruntime.FieldCallerData:
		return m.CallerData()
	case instanceruntime.FieldInstanceContext:
		return m.InstanceContext()
	case instanceruntime.FieldStateContext:
		return m.StateContext()
	case instanceruntime.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceRuntimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instanceruntime.FieldInput:
		return m.OldInput(ctx)
	case instanceruntime.FieldData:
		return m.OldData(ctx)
	case instanceruntime.FieldController:
		return m.OldController(ctx)
	case instanceruntime.FieldMemory:
		return m.OldMemory(ctx)
	case instanceruntime.FieldFlow:
		return m.OldFlow(ctx)
	case instanceruntime.FieldOutput:
		return m.OldOutput(ctx)
	case instanceruntime.FieldStateBeginTime:
		return m.OldStateBeginTime(ctx)
	case instanceruntime.FieldDeadline:
		return m.OldDeadline(ctx)
	case instanceruntime.FieldAttempts:
		return m.OldAttempts(ctx)
	case instanceruntime.FieldCallerData:
		return m.OldCallerData(ctx)
	case instanceruntime.FieldInstanceContext:
		return m.OldInstanceContext(ctx)
	case instanceruntime.FieldStateContext:
		return m.OldStateContext(ctx)
	case instanceruntime.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown InstanceRuntime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceRuntimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instanceruntime.FieldInput:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case instanceruntime.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case instanceruntime.FieldController:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetController(v)
		return nil
	case instanceruntime.FieldMemory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case instanceruntime.FieldFlow:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlow(v)
		return nil
	case instanceruntime.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case instanceruntime.FieldStateBeginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateBeginTime(v)
		return nil
	case instanceruntime.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case instanceruntime.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case instanceruntime.FieldCallerData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallerData(v)
		return nil
	case instanceruntime.FieldInstanceContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceContext(v)
		return nil
	case instanceruntime.FieldStateContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateContext(v)
		return nil
	case instanceruntime.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceRuntimeMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, instanceruntime.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceRuntimeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case instanceruntime.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceRuntimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case instanceruntime.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceRuntimeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(instanceruntime.FieldController) {
		fields = append(fields, instanceruntime.FieldController)
	}
	if m.FieldCleared(instanceruntime.FieldMemory) {
		fields = append(fields, instanceruntime.FieldMemory)
	}
	if m.FieldCleared(instanceruntime.FieldFlow) {
		fields = append(fields, instanceruntime.FieldFlow)
	}
	if m.FieldCleared(instanceruntime.FieldOutput) {
		fields = append(fields, instanceruntime.FieldOutput)
	}
	if m.FieldCleared(instanceruntime.FieldStateBeginTime) {
		fields = append(fields, instanceruntime.FieldStateBeginTime)
	}
	if m.FieldCleared(instanceruntime.FieldDeadline) {
		fields = append(fields, instanceruntime.FieldDeadline)
	}
	if m.FieldCleared(instanceruntime.FieldAttempts) {
		fields = append(fields, instanceruntime.FieldAttempts)
	}
	if m.FieldCleared(instanceruntime.FieldCallerData) {
		fields = append(fields, instanceruntime.FieldCallerData)
	}
	if m.FieldCleared(instanceruntime.FieldInstanceContext) {
		fields = append(fields, instanceruntime.FieldInstanceContext)
	}
	if m.FieldCleared(instanceruntime.FieldStateContext) {
		fields = append(fields, instanceruntime.FieldStateContext)
	}
	if m.FieldCleared(instanceruntime.FieldMetadata) {
		fields = append(fields, instanceruntime.FieldMetadata)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceRuntimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceRuntimeMutation) ClearField(name string) error {
	switch name {
	case instanceruntime.FieldController:
		m.ClearController()
		return nil
	case instanceruntime.FieldMemory:
		m.ClearMemory()
		return nil
	case instanceruntime.FieldFlow:
		m.ClearFlow()
		return nil
	case instanceruntime.FieldOutput:
		m.ClearOutput()
		return nil
	case instanceruntime.FieldStateBeginTime:
		m.ClearStateBeginTime()
		return nil
	case instanceruntime.FieldDeadline:
		m.ClearDeadline()
		return nil
	case instanceruntime.FieldAttempts:
		m.ClearAttempts()
		return nil
	case instanceruntime.FieldCallerData:
		m.ClearCallerData()
		return nil
	case instanceruntime.FieldInstanceContext:
		m.ClearInstanceContext()
		return nil
	case instanceruntime.FieldStateContext:
		m.ClearStateContext()
		return nil
	case instanceruntime.FieldMetadata:
		m.ClearMetadata()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceRuntimeMutation) ResetField(name string) error {
	switch name {
	case instanceruntime.FieldInput:
		m.ResetInput()
		return nil
	case instanceruntime.FieldData:
		m.ResetData()
		return nil
	case instanceruntime.FieldController:
		m.ResetController()
		return nil
	case instanceruntime.FieldMemory:
		m.ResetMemory()
		return nil
	case instanceruntime.FieldFlow:
		m.ResetFlow()
		return nil
	case instanceruntime.FieldOutput:
		m.ResetOutput()
		return nil
	case instanceruntime.FieldStateBeginTime:
		m.ResetStateBeginTime()
		return nil
	case instanceruntime.FieldDeadline:
		m.ResetDeadline()
		return nil
	case instanceruntime.FieldAttempts:
		m.ResetAttempts()
		return nil
	case instanceruntime.FieldCallerData:
		m.ResetCallerData()
		return nil
	case instanceruntime.FieldInstanceContext:
		m.ResetInstanceContext()
		return nil
	case instanceruntime.FieldStateContext:
		m.ResetStateContext()
		return nil
	case instanceruntime.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceRuntimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.instance != nil {
		edges = append(edges, instanceruntime.EdgeInstance)
	}
	if m.caller != nil {
		edges = append(edges, instanceruntime.EdgeCaller)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceRuntimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instanceruntime.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	case instanceruntime.EdgeCaller:
		if id := m.caller; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceRuntimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceRuntimeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceRuntimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinstance {
		edges = append(edges, instanceruntime.EdgeInstance)
	}
	if m.clearedcaller {
		edges = append(edges, instanceruntime.EdgeCaller)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceRuntimeMutation) EdgeCleared(name string) bool {
	switch name {
	case instanceruntime.EdgeInstance:
		return m.clearedinstance
	case instanceruntime.EdgeCaller:
		return m.clearedcaller
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceRuntimeMutation) ClearEdge(name string) error {
	switch name {
	case instanceruntime.EdgeInstance:
		m.ClearInstance()
		return nil
	case instanceruntime.EdgeCaller:
		m.ClearCaller()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceRuntimeMutation) ResetEdge(name string) error {
	switch name {
	case instanceruntime.EdgeInstance:
		m.ResetInstance()
		return nil
	case instanceruntime.EdgeCaller:
		m.ResetCaller()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime edge %s", name)
}

// LogMsgMutation represents an operation that mutates the LogMsg nodes in the graph.
type LogMsgMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	t                *time.Time
	msg              *string
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	workflow         *uuid.UUID
	clearedworkflow  bool
	instance         *uuid.UUID
	clearedinstance  bool
	done             bool
	oldValue         func(context.Context) (*LogMsg, error)
	predicates       []predicate.LogMsg
}

var _ ent.Mutation = (*LogMsgMutation)(nil)

// logmsgOption allows management of the mutation configuration using functional options.
type logmsgOption func(*LogMsgMutation)

// newLogMsgMutation creates new mutation for the LogMsg entity.
func newLogMsgMutation(c config, op Op, opts ...logmsgOption) *LogMsgMutation {
	m := &LogMsgMutation{
		config:        c,
		op:            op,
		typ:           TypeLogMsg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogMsgID sets the ID field of the mutation.
func withLogMsgID(id uuid.UUID) logmsgOption {
	return func(m *LogMsgMutation) {
		var (
			err   error
			once  sync.Once
			value *LogMsg
		)
		m.oldValue = func(ctx context.Context) (*LogMsg, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LogMsg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogMsg sets the old LogMsg of the mutation.
func withLogMsg(node *LogMsg) logmsgOption {
	return func(m *LogMsgMutation) {
		m.oldValue = func(context.Context) (*LogMsg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogMsgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogMsgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LogMsg entities.
func (m *LogMsgMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogMsgMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogMsgMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LogMsg.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetT sets the "t" field.
func (m *LogMsgMutation) SetT(t time.Time) {
	m.t = &t
}

// T returns the value of the "t" field in the mutation.
func (m *LogMsgMutation) T() (r time.Time, exists bool) {
	v := m.t
	if v == nil {
		return
	}
	return *v, true
}

// OldT returns the old "t" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldT(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldT: %w", err)
	}
	return oldValue.T, nil
}

// ResetT resets all changes to the "t" field.
func (m *LogMsgMutation) ResetT() {
	m.t = nil
}

// SetMsg sets the "msg" field.
func (m *LogMsgMutation) SetMsg(s string) {
	m.msg = &s
}

// Msg returns the value of the "msg" field in the mutation.
func (m *LogMsgMutation) Msg() (r string, exists bool) {
	v := m.msg
	if v == nil {
		return
	}
	return *v, true
}

// OldMsg returns the old "msg" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsg: %w", err)
	}
	return oldValue.Msg, nil
}

// ResetMsg resets all changes to the "msg" field.
func (m *LogMsgMutation) ResetMsg() {
	m.msg = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *LogMsgMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *LogMsgMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *LogMsgMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *LogMsgMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *LogMsgMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *LogMsgMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *LogMsgMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *LogMsgMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *LogMsgMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *LogMsgMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *LogMsgMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *LogMsgMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *LogMsgMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *LogMsgMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *LogMsgMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *LogMsgMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *LogMsgMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *LogMsgMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// Where appends a list predicates to the LogMsgMutation builder.
func (m *LogMsgMutation) Where(ps ...predicate.LogMsg) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *LogMsgMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (LogMsg).
func (m *LogMsgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogMsgMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.t != nil {
		fields = append(fields, logmsg.FieldT)
	}
	if m.msg != nil {
		fields = append(fields, logmsg.FieldMsg)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogMsgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logmsg.FieldT:
		return m.T()
	case logmsg.FieldMsg:
		return m.Msg()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogMsgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logmsg.FieldT:
		return m.OldT(ctx)
	case logmsg.FieldMsg:
		return m.OldMsg(ctx)
	}
	return nil, fmt.Errorf("unknown LogMsg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogMsgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logmsg.FieldT:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetT(v)
		return nil
	case logmsg.FieldMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsg(v)
		return nil
	}
	return fmt.Errorf("unknown LogMsg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogMsgMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogMsgMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogMsgMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LogMsg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogMsgMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogMsgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogMsgMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LogMsg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogMsgMutation) ResetField(name string) error {
	switch name {
	case logmsg.FieldT:
		m.ResetT()
		return nil
	case logmsg.FieldMsg:
		m.ResetMsg()
		return nil
	}
	return fmt.Errorf("unknown LogMsg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogMsgMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.namespace != nil {
		edges = append(edges, logmsg.EdgeNamespace)
	}
	if m.workflow != nil {
		edges = append(edges, logmsg.EdgeWorkflow)
	}
	if m.instance != nil {
		edges = append(edges, logmsg.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogMsgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case logmsg.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case logmsg.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case logmsg.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogMsgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogMsgMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogMsgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearednamespace {
		edges = append(edges, logmsg.EdgeNamespace)
	}
	if m.clearedworkflow {
		edges = append(edges, logmsg.EdgeWorkflow)
	}
	if m.clearedinstance {
		edges = append(edges, logmsg.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogMsgMutation) EdgeCleared(name string) bool {
	switch name {
	case logmsg.EdgeNamespace:
		return m.clearednamespace
	case logmsg.EdgeWorkflow:
		return m.clearedworkflow
	case logmsg.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogMsgMutation) ClearEdge(name string) error {
	switch name {
	case logmsg.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case logmsg.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case logmsg.EdgeInstance:
		m.ClearInstance()
		return nil
	}
	return fmt.Errorf("unknown LogMsg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogMsgMutation) ResetEdge(name string) error {
	switch name {
	case logmsg.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case logmsg.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case logmsg.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown LogMsg edge %s", name)
}

// NamespaceMutation represents an operation that mutates the Namespace nodes in the graph.
type NamespaceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	_config                   *string
	name                      *string
	clearedFields             map[string]struct{}
	inodes                    map[uuid.UUID]struct{}
	removedinodes             map[uuid.UUID]struct{}
	clearedinodes             bool
	workflows                 map[uuid.UUID]struct{}
	removedworkflows          map[uuid.UUID]struct{}
	clearedworkflows          bool
	instances                 map[uuid.UUID]struct{}
	removedinstances          map[uuid.UUID]struct{}
	clearedinstances          bool
	logs                      map[uuid.UUID]struct{}
	removedlogs               map[uuid.UUID]struct{}
	clearedlogs               bool
	vars                      map[uuid.UUID]struct{}
	removedvars               map[uuid.UUID]struct{}
	clearedvars               bool
	cloudevents               map[uuid.UUID]struct{}
	removedcloudevents        map[uuid.UUID]struct{}
	clearedcloudevents        bool
	namespacelisteners        map[uuid.UUID]struct{}
	removednamespacelisteners map[uuid.UUID]struct{}
	clearednamespacelisteners bool
	done                      bool
	oldValue                  func(context.Context) (*Namespace, error)
	predicates                []predicate.Namespace
}

var _ ent.Mutation = (*NamespaceMutation)(nil)

// namespaceOption allows management of the mutation configuration using functional options.
type namespaceOption func(*NamespaceMutation)

// newNamespaceMutation creates new mutation for the Namespace entity.
func newNamespaceMutation(c config, op Op, opts ...namespaceOption) *NamespaceMutation {
	m := &NamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceID sets the ID field of the mutation.
func withNamespaceID(id uuid.UUID) namespaceOption {
	return func(m *NamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Namespace
		)
		m.oldValue = func(ctx context.Context) (*Namespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Namespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespace sets the old Namespace of the mutation.
func withNamespace(node *Namespace) namespaceOption {
	return func(m *NamespaceMutation) {
		m.oldValue = func(context.Context) (*Namespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Namespace entities.
func (m *NamespaceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamespaceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NamespaceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Namespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NamespaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NamespaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NamespaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NamespaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NamespaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NamespaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetConfig sets the "config" field.
func (m *NamespaceMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *NamespaceMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NamespaceMutation) ResetConfig() {
	m._config = nil
}

// SetName sets the "name" field.
func (m *NamespaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NamespaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NamespaceMutation) ResetName() {
	m.name = nil
}

// AddInodeIDs adds the "inodes" edge to the Inode entity by ids.
func (m *NamespaceMutation) AddInodeIDs(ids ...uuid.UUID) {
	if m.inodes == nil {
		m.inodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.inodes[ids[i]] = struct{}{}
	}
}

// ClearInodes clears the "inodes" edge to the Inode entity.
func (m *NamespaceMutation) ClearInodes() {
	m.clearedinodes = true
}

// InodesCleared reports if the "inodes" edge to the Inode entity was cleared.
func (m *NamespaceMutation) InodesCleared() bool {
	return m.clearedinodes
}

// RemoveInodeIDs removes the "inodes" edge to the Inode entity by IDs.
func (m *NamespaceMutation) RemoveInodeIDs(ids ...uuid.UUID) {
	if m.removedinodes == nil {
		m.removedinodes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.inodes, ids[i])
		m.removedinodes[ids[i]] = struct{}{}
	}
}

// RemovedInodes returns the removed IDs of the "inodes" edge to the Inode entity.
func (m *NamespaceMutation) RemovedInodesIDs() (ids []uuid.UUID) {
	for id := range m.removedinodes {
		ids = append(ids, id)
	}
	return
}

// InodesIDs returns the "inodes" edge IDs in the mutation.
func (m *NamespaceMutation) InodesIDs() (ids []uuid.UUID) {
	for id := range m.inodes {
		ids = append(ids, id)
	}
	return
}

// ResetInodes resets all changes to the "inodes" edge.
func (m *NamespaceMutation) ResetInodes() {
	m.inodes = nil
	m.clearedinodes = false
	m.removedinodes = nil
}

// AddWorkflowIDs adds the "workflows" edge to the Workflow entity by ids.
func (m *NamespaceMutation) AddWorkflowIDs(ids ...uuid.UUID) {
	if m.workflows == nil {
		m.workflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflow entity.
func (m *NamespaceMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflow entity was cleared.
func (m *NamespaceMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflow entity by IDs.
func (m *NamespaceMutation) RemoveWorkflowIDs(ids ...uuid.UUID) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflow entity.
func (m *NamespaceMutation) RemovedWorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *NamespaceMutation) WorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *NamespaceMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// AddInstanceIDs adds the "instances" edge to the Instance entity by ids.
func (m *NamespaceMutation) AddInstanceIDs(ids ...uuid.UUID) {
	if m.instances == nil {
		m.instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the Instance entity.
func (m *NamespaceMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the Instance entity was cleared.
func (m *NamespaceMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the Instance entity by IDs.
func (m *NamespaceMutation) RemoveInstanceIDs(ids ...uuid.UUID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the Instance entity.
func (m *NamespaceMutation) RemovedInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *NamespaceMutation) InstancesIDs() (ids []uuid.UUID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *NamespaceMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// AddLogIDs adds the "logs" edge to the LogMsg entity by ids.
func (m *NamespaceMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the LogMsg entity.
func (m *NamespaceMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the LogMsg entity was cleared.
func (m *NamespaceMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the LogMsg entity by IDs.
func (m *NamespaceMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the LogMsg entity.
func (m *NamespaceMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *NamespaceMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *NamespaceMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddVarIDs adds the "vars" edge to the VarRef entity by ids.
func (m *NamespaceMutation) AddVarIDs(ids ...uuid.UUID) {
	if m.vars == nil {
		m.vars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vars[ids[i]] = struct{}{}
	}
}

// ClearVars clears the "vars" edge to the VarRef entity.
func (m *NamespaceMutation) ClearVars() {
	m.clearedvars = true
}

// VarsCleared reports if the "vars" edge to the VarRef entity was cleared.
func (m *NamespaceMutation) VarsCleared() bool {
	return m.clearedvars
}

// RemoveVarIDs removes the "vars" edge to the VarRef entity by IDs.
func (m *NamespaceMutation) RemoveVarIDs(ids ...uuid.UUID) {
	if m.removedvars == nil {
		m.removedvars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vars, ids[i])
		m.removedvars[ids[i]] = struct{}{}
	}
}

// RemovedVars returns the removed IDs of the "vars" edge to the VarRef entity.
func (m *NamespaceMutation) RemovedVarsIDs() (ids []uuid.UUID) {
	for id := range m.removedvars {
		ids = append(ids, id)
	}
	return
}

// VarsIDs returns the "vars" edge IDs in the mutation.
func (m *NamespaceMutation) VarsIDs() (ids []uuid.UUID) {
	for id := range m.vars {
		ids = append(ids, id)
	}
	return
}

// ResetVars resets all changes to the "vars" edge.
func (m *NamespaceMutation) ResetVars() {
	m.vars = nil
	m.clearedvars = false
	m.removedvars = nil
}

// AddCloudeventIDs adds the "cloudevents" edge to the CloudEvents entity by ids.
func (m *NamespaceMutation) AddCloudeventIDs(ids ...uuid.UUID) {
	if m.cloudevents == nil {
		m.cloudevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cloudevents[ids[i]] = struct{}{}
	}
}

// ClearCloudevents clears the "cloudevents" edge to the CloudEvents entity.
func (m *NamespaceMutation) ClearCloudevents() {
	m.clearedcloudevents = true
}

// CloudeventsCleared reports if the "cloudevents" edge to the CloudEvents entity was cleared.
func (m *NamespaceMutation) CloudeventsCleared() bool {
	return m.clearedcloudevents
}

// RemoveCloudeventIDs removes the "cloudevents" edge to the CloudEvents entity by IDs.
func (m *NamespaceMutation) RemoveCloudeventIDs(ids ...uuid.UUID) {
	if m.removedcloudevents == nil {
		m.removedcloudevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cloudevents, ids[i])
		m.removedcloudevents[ids[i]] = struct{}{}
	}
}

// RemovedCloudevents returns the removed IDs of the "cloudevents" edge to the CloudEvents entity.
func (m *NamespaceMutation) RemovedCloudeventsIDs() (ids []uuid.UUID) {
	for id := range m.removedcloudevents {
		ids = append(ids, id)
	}
	return
}

// CloudeventsIDs returns the "cloudevents" edge IDs in the mutation.
func (m *NamespaceMutation) CloudeventsIDs() (ids []uuid.UUID) {
	for id := range m.cloudevents {
		ids = append(ids, id)
	}
	return
}

// ResetCloudevents resets all changes to the "cloudevents" edge.
func (m *NamespaceMutation) ResetCloudevents() {
	m.cloudevents = nil
	m.clearedcloudevents = false
	m.removedcloudevents = nil
}

// AddNamespacelistenerIDs adds the "namespacelisteners" edge to the Events entity by ids.
func (m *NamespaceMutation) AddNamespacelistenerIDs(ids ...uuid.UUID) {
	if m.namespacelisteners == nil {
		m.namespacelisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.namespacelisteners[ids[i]] = struct{}{}
	}
}

// ClearNamespacelisteners clears the "namespacelisteners" edge to the Events entity.
func (m *NamespaceMutation) ClearNamespacelisteners() {
	m.clearednamespacelisteners = true
}

// NamespacelistenersCleared reports if the "namespacelisteners" edge to the Events entity was cleared.
func (m *NamespaceMutation) NamespacelistenersCleared() bool {
	return m.clearednamespacelisteners
}

// RemoveNamespacelistenerIDs removes the "namespacelisteners" edge to the Events entity by IDs.
func (m *NamespaceMutation) RemoveNamespacelistenerIDs(ids ...uuid.UUID) {
	if m.removednamespacelisteners == nil {
		m.removednamespacelisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.namespacelisteners, ids[i])
		m.removednamespacelisteners[ids[i]] = struct{}{}
	}
}

// RemovedNamespacelisteners returns the removed IDs of the "namespacelisteners" edge to the Events entity.
func (m *NamespaceMutation) RemovedNamespacelistenersIDs() (ids []uuid.UUID) {
	for id := range m.removednamespacelisteners {
		ids = append(ids, id)
	}
	return
}

// NamespacelistenersIDs returns the "namespacelisteners" edge IDs in the mutation.
func (m *NamespaceMutation) NamespacelistenersIDs() (ids []uuid.UUID) {
	for id := range m.namespacelisteners {
		ids = append(ids, id)
	}
	return
}

// ResetNamespacelisteners resets all changes to the "namespacelisteners" edge.
func (m *NamespaceMutation) ResetNamespacelisteners() {
	m.namespacelisteners = nil
	m.clearednamespacelisteners = false
	m.removednamespacelisteners = nil
}

// Where appends a list predicates to the NamespaceMutation builder.
func (m *NamespaceMutation) Where(ps ...predicate.Namespace) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NamespaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Namespace).
func (m *NamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamespaceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, namespace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, namespace.FieldUpdatedAt)
	}
	if m._config != nil {
		fields = append(fields, namespace.FieldConfig)
	}
	if m.name != nil {
		fields = append(fields, namespace.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.CreatedAt()
	case namespace.FieldUpdatedAt:
		return m.UpdatedAt()
	case namespace.FieldConfig:
		return m.Config()
	case namespace.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case namespace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case namespace.FieldConfig:
		return m.OldConfig(ctx)
	case namespace.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Namespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case namespace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case namespace.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case namespace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamespaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamespaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Namespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamespaceMutation) ResetField(name string) error {
	switch name {
	case namespace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case namespace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case namespace.FieldConfig:
		m.ResetConfig()
		return nil
	case namespace.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.inodes != nil {
		edges = append(edges, namespace.EdgeInodes)
	}
	if m.workflows != nil {
		edges = append(edges, namespace.EdgeWorkflows)
	}
	if m.instances != nil {
		edges = append(edges, namespace.EdgeInstances)
	}
	if m.logs != nil {
		edges = append(edges, namespace.EdgeLogs)
	}
	if m.vars != nil {
		edges = append(edges, namespace.EdgeVars)
	}
	if m.cloudevents != nil {
		edges = append(edges, namespace.EdgeCloudevents)
	}
	if m.namespacelisteners != nil {
		edges = append(edges, namespace.EdgeNamespacelisteners)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeInodes:
		ids := make([]ent.Value, 0, len(m.inodes))
		for id := range m.inodes {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeVars:
		ids := make([]ent.Value, 0, len(m.vars))
		for id := range m.vars {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudevents:
		ids := make([]ent.Value, 0, len(m.cloudevents))
		for id := range m.cloudevents {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeNamespacelisteners:
		ids := make([]ent.Value, 0, len(m.namespacelisteners))
		for id := range m.namespacelisteners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedinodes != nil {
		edges = append(edges, namespace.EdgeInodes)
	}
	if m.removedworkflows != nil {
		edges = append(edges, namespace.EdgeWorkflows)
	}
	if m.removedinstances != nil {
		edges = append(edges, namespace.EdgeInstances)
	}
	if m.removedlogs != nil {
		edges = append(edges, namespace.EdgeLogs)
	}
	if m.removedvars != nil {
		edges = append(edges, namespace.EdgeVars)
	}
	if m.removedcloudevents != nil {
		edges = append(edges, namespace.EdgeCloudevents)
	}
	if m.removednamespacelisteners != nil {
		edges = append(edges, namespace.EdgeNamespacelisteners)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeInodes:
		ids := make([]ent.Value, 0, len(m.removedinodes))
		for id := range m.removedinodes {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeVars:
		ids := make([]ent.Value, 0, len(m.removedvars))
		for id := range m.removedvars {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudevents:
		ids := make([]ent.Value, 0, len(m.removedcloudevents))
		for id := range m.removedcloudevents {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeNamespacelisteners:
		ids := make([]ent.Value, 0, len(m.removednamespacelisteners))
		for id := range m.removednamespacelisteners {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedinodes {
		edges = append(edges, namespace.EdgeInodes)
	}
	if m.clearedworkflows {
		edges = append(edges, namespace.EdgeWorkflows)
	}
	if m.clearedinstances {
		edges = append(edges, namespace.EdgeInstances)
	}
	if m.clearedlogs {
		edges = append(edges, namespace.EdgeLogs)
	}
	if m.clearedvars {
		edges = append(edges, namespace.EdgeVars)
	}
	if m.clearedcloudevents {
		edges = append(edges, namespace.EdgeCloudevents)
	}
	if m.clearednamespacelisteners {
		edges = append(edges, namespace.EdgeNamespacelisteners)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case namespace.EdgeInodes:
		return m.clearedinodes
	case namespace.EdgeWorkflows:
		return m.clearedworkflows
	case namespace.EdgeInstances:
		return m.clearedinstances
	case namespace.EdgeLogs:
		return m.clearedlogs
	case namespace.EdgeVars:
		return m.clearedvars
	case namespace.EdgeCloudevents:
		return m.clearedcloudevents
	case namespace.EdgeNamespacelisteners:
		return m.clearednamespacelisteners
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamespaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamespaceMutation) ResetEdge(name string) error {
	switch name {
	case namespace.EdgeInodes:
		m.ResetInodes()
		return nil
	case namespace.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	case namespace.EdgeInstances:
		m.ResetInstances()
		return nil
	case namespace.EdgeLogs:
		m.ResetLogs()
		return nil
	case namespace.EdgeVars:
		m.ResetVars()
		return nil
	case namespace.EdgeCloudevents:
		m.ResetCloudevents()
		return nil
	case namespace.EdgeNamespacelisteners:
		m.ResetNamespacelisteners()
		return nil
	}
	return fmt.Errorf("unknown Namespace edge %s", name)
}

// RefMutation represents an operation that mutates the Ref nodes in the graph.
type RefMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	immutable       *bool
	name            *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	workflow        *uuid.UUID
	clearedworkflow bool
	revision        *uuid.UUID
	clearedrevision bool
	routes          map[uuid.UUID]struct{}
	removedroutes   map[uuid.UUID]struct{}
	clearedroutes   bool
	done            bool
	oldValue        func(context.Context) (*Ref, error)
	predicates      []predicate.Ref
}

var _ ent.Mutation = (*RefMutation)(nil)

// refOption allows management of the mutation configuration using functional options.
type refOption func(*RefMutation)

// newRefMutation creates new mutation for the Ref entity.
func newRefMutation(c config, op Op, opts ...refOption) *RefMutation {
	m := &RefMutation{
		config:        c,
		op:            op,
		typ:           TypeRef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRefID sets the ID field of the mutation.
func withRefID(id uuid.UUID) refOption {
	return func(m *RefMutation) {
		var (
			err   error
			once  sync.Once
			value *Ref
		)
		m.oldValue = func(ctx context.Context) (*Ref, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Ref.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRef sets the old Ref of the mutation.
func withRef(node *Ref) refOption {
	return func(m *RefMutation) {
		m.oldValue = func(context.Context) (*Ref, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Ref entities.
func (m *RefMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RefMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RefMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Ref.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetImmutable sets the "immutable" field.
func (m *RefMutation) SetImmutable(b bool) {
	m.immutable = &b
}

// Immutable returns the value of the "immutable" field in the mutation.
func (m *RefMutation) Immutable() (r bool, exists bool) {
	v := m.immutable
	if v == nil {
		return
	}
	return *v, true
}

// OldImmutable returns the old "immutable" field's value of the Ref entity.
// If the Ref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefMutation) OldImmutable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImmutable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImmutable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImmutable: %w", err)
	}
	return oldValue.Immutable, nil
}

// ResetImmutable resets all changes to the "immutable" field.
func (m *RefMutation) ResetImmutable() {
	m.immutable = nil
}

// SetName sets the "name" field.
func (m *RefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *RefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Ref entity.
// If the Ref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *RefMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RefMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RefMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Ref entity.
// If the Ref object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RefMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RefMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *RefMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *RefMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *RefMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *RefMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *RefMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *RefMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetRevisionID sets the "revision" edge to the Revision entity by id.
func (m *RefMutation) SetRevisionID(id uuid.UUID) {
	m.revision = &id
}

// ClearRevision clears the "revision" edge to the Revision entity.
func (m *RefMutation) ClearRevision() {
	m.clearedrevision = true
}

// RevisionCleared reports if the "revision" edge to the Revision entity was cleared.
func (m *RefMutation) RevisionCleared() bool {
	return m.clearedrevision
}

// RevisionID returns the "revision" edge ID in the mutation.
func (m *RefMutation) RevisionID() (id uuid.UUID, exists bool) {
	if m.revision != nil {
		return *m.revision, true
	}
	return
}

// RevisionIDs returns the "revision" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RevisionID instead. It exists only for internal usage by the builders.
func (m *RefMutation) RevisionIDs() (ids []uuid.UUID) {
	if id := m.revision; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRevision resets all changes to the "revision" edge.
func (m *RefMutation) ResetRevision() {
	m.revision = nil
	m.clearedrevision = false
}

// AddRouteIDs adds the "routes" edge to the Route entity by ids.
func (m *RefMutation) AddRouteIDs(ids ...uuid.UUID) {
	if m.routes == nil {
		m.routes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.routes[ids[i]] = struct{}{}
	}
}

// ClearRoutes clears the "routes" edge to the Route entity.
func (m *RefMutation) ClearRoutes() {
	m.clearedroutes = true
}

// RoutesCleared reports if the "routes" edge to the Route entity was cleared.
func (m *RefMutation) RoutesCleared() bool {
	return m.clearedroutes
}

// RemoveRouteIDs removes the "routes" edge to the Route entity by IDs.
func (m *RefMutation) RemoveRouteIDs(ids ...uuid.UUID) {
	if m.removedroutes == nil {
		m.removedroutes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.routes, ids[i])
		m.removedroutes[ids[i]] = struct{}{}
	}
}

// RemovedRoutes returns the removed IDs of the "routes" edge to the Route entity.
func (m *RefMutation) RemovedRoutesIDs() (ids []uuid.UUID) {
	for id := range m.removedroutes {
		ids = append(ids, id)
	}
	return
}

// RoutesIDs returns the "routes" edge IDs in the mutation.
func (m *RefMutation) RoutesIDs() (ids []uuid.UUID) {
	for id := range m.routes {
		ids = append(ids, id)
	}
	return
}

// ResetRoutes resets all changes to the "routes" edge.
func (m *RefMutation) ResetRoutes() {
	m.routes = nil
	m.clearedroutes = false
	m.removedroutes = nil
}

// Where appends a list predicates to the RefMutation builder.
func (m *RefMutation) Where(ps ...predicate.Ref) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RefMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Ref).
func (m *RefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RefMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.immutable != nil {
		fields = append(fields, ref.FieldImmutable)
	}
	if m.name != nil {
		fields = append(fields, ref.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, ref.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ref.FieldImmutable:
		return m.Immutable()
	case ref.FieldName:
		return m.Name()
	case ref.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ref.FieldImmutable:
		return m.OldImmutable(ctx)
	case ref.FieldName:
		return m.OldName(ctx)
	case ref.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Ref field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ref.FieldImmutable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImmutable(v)
		return nil
	case ref.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case ref.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Ref field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RefMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RefMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Ref numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RefMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RefMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Ref nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RefMutation) ResetField(name string) error {
	switch name {
	case ref.FieldImmutable:
		m.ResetImmutable()
		return nil
	case ref.FieldName:
		m.ResetName()
		return nil
	case ref.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Ref field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RefMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workflow != nil {
		edges = append(edges, ref.EdgeWorkflow)
	}
	if m.revision != nil {
		edges = append(edges, ref.EdgeRevision)
	}
	if m.routes != nil {
		edges = append(edges, ref.EdgeRoutes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ref.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case ref.EdgeRevision:
		if id := m.revision; id != nil {
			return []ent.Value{*id}
		}
	case ref.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.routes))
		for id := range m.routes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedroutes != nil {
		edges = append(edges, ref.EdgeRoutes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RefMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case ref.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.removedroutes))
		for id := range m.removedroutes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkflow {
		edges = append(edges, ref.EdgeWorkflow)
	}
	if m.clearedrevision {
		edges = append(edges, ref.EdgeRevision)
	}
	if m.clearedroutes {
		edges = append(edges, ref.EdgeRoutes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RefMutation) EdgeCleared(name string) bool {
	switch name {
	case ref.EdgeWorkflow:
		return m.clearedworkflow
	case ref.EdgeRevision:
		return m.clearedrevision
	case ref.EdgeRoutes:
		return m.clearedroutes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RefMutation) ClearEdge(name string) error {
	switch name {
	case ref.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case ref.EdgeRevision:
		m.ClearRevision()
		return nil
	}
	return fmt.Errorf("unknown Ref unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RefMutation) ResetEdge(name string) error {
	switch name {
	case ref.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case ref.EdgeRevision:
		m.ResetRevision()
		return nil
	case ref.EdgeRoutes:
		m.ResetRoutes()
		return nil
	}
	return fmt.Errorf("unknown Ref edge %s", name)
}

// RevisionMutation represents an operation that mutates the Revision nodes in the graph.
type RevisionMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	hash             *string
	source           *[]byte
	metadata         *map[string]interface{}
	clearedFields    map[string]struct{}
	workflow         *uuid.UUID
	clearedworkflow  bool
	refs             map[uuid.UUID]struct{}
	removedrefs      map[uuid.UUID]struct{}
	clearedrefs      bool
	instances        map[uuid.UUID]struct{}
	removedinstances map[uuid.UUID]struct{}
	clearedinstances bool
	done             bool
	oldValue         func(context.Context) (*Revision, error)
	predicates       []predicate.Revision
}

var _ ent.Mutation = (*RevisionMutation)(nil)

// revisionOption allows management of the mutation configuration using functional options.
type revisionOption func(*RevisionMutation)

// newRevisionMutation creates new mutation for the Revision entity.
func newRevisionMutation(c config, op Op, opts ...revisionOption) *RevisionMutation {
	m := &RevisionMutation{
		config:        c,
		op:            op,
		typ:           TypeRevision,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRevisionID sets the ID field of the mutation.
func withRevisionID(id uuid.UUID) revisionOption {
	return func(m *RevisionMutation) {
		var (
			err   error
			once  sync.Once
			value *Revision
		)
		m.oldValue = func(ctx context.Context) (*Revision, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Revision.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRevision sets the old Revision of the mutation.
func withRevision(node *Revision) revisionOption {
	return func(m *RevisionMutation) {
		m.oldValue = func(context.Context) (*Revision, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RevisionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RevisionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Revision entities.
func (m *RevisionMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RevisionMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RevisionMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Revision.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *RevisionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RevisionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RevisionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetHash sets the "hash" field.
func (m *RevisionMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *RevisionMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *RevisionMutation) ResetHash() {
	m.hash = nil
}

// SetSource sets the "source" field.
func (m *RevisionMutation) SetSource(b []byte) {
	m.source = &b
}

// Source returns the value of the "source" field in the mutation.
func (m *RevisionMutation) Source() (r []byte, exists bool) {
	v := m.source
	if v == nil {
		return
	}
	return *v, true
}

// OldSource returns the old "source" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldSource(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSource is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSource requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSource: %w", err)
	}
	return oldValue.Source, nil
}

// ResetSource resets all changes to the "source" field.
func (m *RevisionMutation) ResetSource() {
	m.source = nil
}

// SetMetadata sets the "metadata" field.
func (m *RevisionMutation) SetMetadata(value map[string]interface{}) {
	m.metadata = &value
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *RevisionMutation) Metadata() (r map[string]interface{}, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the Revision entity.
// If the Revision object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RevisionMutation) OldMetadata(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *RevisionMutation) ResetMetadata() {
	m.metadata = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *RevisionMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *RevisionMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *RevisionMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *RevisionMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *RevisionMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *RevisionMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddRefIDs adds the "refs" edge to the Ref entity by ids.
func (m *RevisionMutation) AddRefIDs(ids ...uuid.UUID) {
	if m.refs == nil {
		m.refs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.refs[ids[i]] = struct{}{}
	}
}

// ClearRefs clears the "refs" edge to the Ref entity.
func (m *RevisionMutation) ClearRefs() {
	m.clearedrefs = true
}

// RefsCleared reports if the "refs" edge to the Ref entity was cleared.
func (m *RevisionMutation) RefsCleared() bool {
	return m.clearedrefs
}

// RemoveRefIDs removes the "refs" edge to the Ref entity by IDs.
func (m *RevisionMutation) RemoveRefIDs(ids ...uuid.UUID) {
	if m.removedrefs == nil {
		m.removedrefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.refs, ids[i])
		m.removedrefs[ids[i]] = struct{}{}
	}
}

// RemovedRefs returns the removed IDs of the "refs" edge to the Ref entity.
func (m *RevisionMutation) RemovedRefsIDs() (ids []uuid.UUID) {
	for id := range m.removedrefs {
		ids = append(ids, id)
	}
	return
}

// RefsIDs returns the "refs" edge IDs in the mutation.
func (m *RevisionMutation) RefsIDs() (ids []uuid.UUID) {
	for id := range m.refs {
		ids = append(ids, id)
	}
	return
}

// ResetRefs resets all changes to the "refs" edge.
func (m *RevisionMutation) ResetRefs() {
	m.refs = nil
	m.clearedrefs = false
	m.removedrefs = nil
}

// AddInstanceIDs adds the "instances" edge to the Instance entity by ids.
func (m *RevisionMutation) AddInstanceIDs(ids ...uuid.UUID) {
	if m.instances == nil {
		m.instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the Instance entity.
func (m *RevisionMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the Instance entity was cleared.
func (m *RevisionMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the Instance entity by IDs.
func (m *RevisionMutation) RemoveInstanceIDs(ids ...uuid.UUID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the Instance entity.
func (m *RevisionMutation) RemovedInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *RevisionMutation) InstancesIDs() (ids []uuid.UUID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *RevisionMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// Where appends a list predicates to the RevisionMutation builder.
func (m *RevisionMutation) Where(ps ...predicate.Revision) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RevisionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Revision).
func (m *RevisionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RevisionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, revision.FieldCreatedAt)
	}
	if m.hash != nil {
		fields = append(fields, revision.FieldHash)
	}
	if m.source != nil {
		fields = append(fields, revision.FieldSource)
	}
	if m.metadata != nil {
		fields = append(fields, revision.FieldMetadata)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RevisionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case revision.FieldCreatedAt:
		return m.CreatedAt()
	case revision.FieldHash:
		return m.Hash()
	case revision.FieldSource:
		return m.Source()
	case revision.FieldMetadata:
		return m.Metadata()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RevisionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case revision.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case revision.FieldHash:
		return m.OldHash(ctx)
	case revision.FieldSource:
		return m.OldSource(ctx)
	case revision.FieldMetadata:
		return m.OldMetadata(ctx)
	}
	return nil, fmt.Errorf("unknown Revision field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevisionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case revision.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case revision.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case revision.FieldSource:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSource(v)
		return nil
	case revision.FieldMetadata:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	}
	return fmt.Errorf("unknown Revision field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RevisionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RevisionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RevisionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Revision numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RevisionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RevisionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RevisionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Revision nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RevisionMutation) ResetField(name string) error {
	switch name {
	case revision.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case revision.FieldHash:
		m.ResetHash()
		return nil
	case revision.FieldSource:
		m.ResetSource()
		return nil
	case revision.FieldMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown Revision field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RevisionMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workflow != nil {
		edges = append(edges, revision.EdgeWorkflow)
	}
	if m.refs != nil {
		edges = append(edges, revision.EdgeRefs)
	}
	if m.instances != nil {
		edges = append(edges, revision.EdgeInstances)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RevisionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case revision.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case revision.EdgeRefs:
		ids := make([]ent.Value, 0, len(m.refs))
		for id := range m.refs {
			ids = append(ids, id)
		}
		return ids
	case revision.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RevisionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedrefs != nil {
		edges = append(edges, revision.EdgeRefs)
	}
	if m.removedinstances != nil {
		edges = append(edges, revision.EdgeInstances)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RevisionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case revision.EdgeRefs:
		ids := make([]ent.Value, 0, len(m.removedrefs))
		for id := range m.removedrefs {
			ids = append(ids, id)
		}
		return ids
	case revision.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RevisionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkflow {
		edges = append(edges, revision.EdgeWorkflow)
	}
	if m.clearedrefs {
		edges = append(edges, revision.EdgeRefs)
	}
	if m.clearedinstances {
		edges = append(edges, revision.EdgeInstances)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RevisionMutation) EdgeCleared(name string) bool {
	switch name {
	case revision.EdgeWorkflow:
		return m.clearedworkflow
	case revision.EdgeRefs:
		return m.clearedrefs
	case revision.EdgeInstances:
		return m.clearedinstances
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RevisionMutation) ClearEdge(name string) error {
	switch name {
	case revision.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown Revision unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RevisionMutation) ResetEdge(name string) error {
	switch name {
	case revision.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case revision.EdgeRefs:
		m.ResetRefs()
		return nil
	case revision.EdgeInstances:
		m.ResetInstances()
		return nil
	}
	return fmt.Errorf("unknown Revision edge %s", name)
}

// RouteMutation represents an operation that mutates the Route nodes in the graph.
type RouteMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	weight          *int
	addweight       *int
	clearedFields   map[string]struct{}
	workflow        *uuid.UUID
	clearedworkflow bool
	ref             *uuid.UUID
	clearedref      bool
	done            bool
	oldValue        func(context.Context) (*Route, error)
	predicates      []predicate.Route
}

var _ ent.Mutation = (*RouteMutation)(nil)

// routeOption allows management of the mutation configuration using functional options.
type routeOption func(*RouteMutation)

// newRouteMutation creates new mutation for the Route entity.
func newRouteMutation(c config, op Op, opts ...routeOption) *RouteMutation {
	m := &RouteMutation{
		config:        c,
		op:            op,
		typ:           TypeRoute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRouteID sets the ID field of the mutation.
func withRouteID(id uuid.UUID) routeOption {
	return func(m *RouteMutation) {
		var (
			err   error
			once  sync.Once
			value *Route
		)
		m.oldValue = func(ctx context.Context) (*Route, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Route.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoute sets the old Route of the mutation.
func withRoute(node *Route) routeOption {
	return func(m *RouteMutation) {
		m.oldValue = func(context.Context) (*Route, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RouteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RouteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Route entities.
func (m *RouteMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RouteMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RouteMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Route.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetWeight sets the "weight" field.
func (m *RouteMutation) SetWeight(i int) {
	m.weight = &i
	m.addweight = nil
}

// Weight returns the value of the "weight" field in the mutation.
func (m *RouteMutation) Weight() (r int, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old "weight" field's value of the Route entity.
// If the Route object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RouteMutation) OldWeight(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds i to the "weight" field.
func (m *RouteMutation) AddWeight(i int) {
	if m.addweight != nil {
		*m.addweight += i
	} else {
		m.addweight = &i
	}
}

// AddedWeight returns the value that was added to the "weight" field in this mutation.
func (m *RouteMutation) AddedWeight() (r int, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight resets all changes to the "weight" field.
func (m *RouteMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *RouteMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *RouteMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *RouteMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *RouteMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *RouteMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *RouteMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetRefID sets the "ref" edge to the Ref entity by id.
func (m *RouteMutation) SetRefID(id uuid.UUID) {
	m.ref = &id
}

// ClearRef clears the "ref" edge to the Ref entity.
func (m *RouteMutation) ClearRef() {
	m.clearedref = true
}

// RefCleared reports if the "ref" edge to the Ref entity was cleared.
func (m *RouteMutation) RefCleared() bool {
	return m.clearedref
}

// RefID returns the "ref" edge ID in the mutation.
func (m *RouteMutation) RefID() (id uuid.UUID, exists bool) {
	if m.ref != nil {
		return *m.ref, true
	}
	return
}

// RefIDs returns the "ref" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RefID instead. It exists only for internal usage by the builders.
func (m *RouteMutation) RefIDs() (ids []uuid.UUID) {
	if id := m.ref; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRef resets all changes to the "ref" edge.
func (m *RouteMutation) ResetRef() {
	m.ref = nil
	m.clearedref = false
}

// Where appends a list predicates to the RouteMutation builder.
func (m *RouteMutation) Where(ps ...predicate.Route) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *RouteMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Route).
func (m *RouteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RouteMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.weight != nil {
		fields = append(fields, route.FieldWeight)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RouteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case route.FieldWeight:
		return m.Weight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RouteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case route.FieldWeight:
		return m.OldWeight(ctx)
	}
	return nil, fmt.Errorf("unknown Route field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case route.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RouteMutation) AddedFields() []string {
	var fields []string
	if m.addweight != nil {
		fields = append(fields, route.FieldWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RouteMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case route.FieldWeight:
		return m.AddedWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RouteMutation) AddField(name string, value ent.Value) error {
	switch name {
	case route.FieldWeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	}
	return fmt.Errorf("unknown Route numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RouteMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RouteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RouteMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Route nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RouteMutation) ResetField(name string) error {
	switch name {
	case route.FieldWeight:
		m.ResetWeight()
		return nil
	}
	return fmt.Errorf("unknown Route field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RouteMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflow != nil {
		edges = append(edges, route.EdgeWorkflow)
	}
	if m.ref != nil {
		edges = append(edges, route.EdgeRef)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RouteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case route.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case route.EdgeRef:
		if id := m.ref; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RouteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RouteMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RouteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflow {
		edges = append(edges, route.EdgeWorkflow)
	}
	if m.clearedref {
		edges = append(edges, route.EdgeRef)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RouteMutation) EdgeCleared(name string) bool {
	switch name {
	case route.EdgeWorkflow:
		return m.clearedworkflow
	case route.EdgeRef:
		return m.clearedref
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RouteMutation) ClearEdge(name string) error {
	switch name {
	case route.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case route.EdgeRef:
		m.ClearRef()
		return nil
	}
	return fmt.Errorf("unknown Route unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RouteMutation) ResetEdge(name string) error {
	switch name {
	case route.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case route.EdgeRef:
		m.ResetRef()
		return nil
	}
	return fmt.Errorf("unknown Route edge %s", name)
}

// VarDataMutation represents an operation that mutates the VarData nodes in the graph.
type VarDataMutation struct {
	config
	op             Op
	typ            string
	id             *uuid.UUID
	created_at     *time.Time
	updated_at     *time.Time
	size           *int
	addsize        *int
	hash           *string
	data           *[]byte
	mime_type      *string
	clearedFields  map[string]struct{}
	varrefs        map[uuid.UUID]struct{}
	removedvarrefs map[uuid.UUID]struct{}
	clearedvarrefs bool
	done           bool
	oldValue       func(context.Context) (*VarData, error)
	predicates     []predicate.VarData
}

var _ ent.Mutation = (*VarDataMutation)(nil)

// vardataOption allows management of the mutation configuration using functional options.
type vardataOption func(*VarDataMutation)

// newVarDataMutation creates new mutation for the VarData entity.
func newVarDataMutation(c config, op Op, opts ...vardataOption) *VarDataMutation {
	m := &VarDataMutation{
		config:        c,
		op:            op,
		typ:           TypeVarData,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVarDataID sets the ID field of the mutation.
func withVarDataID(id uuid.UUID) vardataOption {
	return func(m *VarDataMutation) {
		var (
			err   error
			once  sync.Once
			value *VarData
		)
		m.oldValue = func(ctx context.Context) (*VarData, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VarData.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVarData sets the old VarData of the mutation.
func withVarData(node *VarData) vardataOption {
	return func(m *VarDataMutation) {
		m.oldValue = func(context.Context) (*VarData, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VarDataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VarDataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VarData entities.
func (m *VarDataMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VarDataMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VarDataMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VarData.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *VarDataMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *VarDataMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *VarDataMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *VarDataMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *VarDataMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *VarDataMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSize sets the "size" field.
func (m *VarDataMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *VarDataMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *VarDataMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *VarDataMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *VarDataMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetHash sets the "hash" field.
func (m *VarDataMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *VarDataMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *VarDataMutation) ResetHash() {
	m.hash = nil
}

// SetData sets the "data" field.
func (m *VarDataMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *VarDataMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *VarDataMutation) ResetData() {
	m.data = nil
}

// SetMimeType sets the "mime_type" field.
func (m *VarDataMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *VarDataMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the VarData entity.
// If the VarData object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarDataMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *VarDataMutation) ResetMimeType() {
	m.mime_type = nil
}

// AddVarrefIDs adds the "varrefs" edge to the VarRef entity by ids.
func (m *VarDataMutation) AddVarrefIDs(ids ...uuid.UUID) {
	if m.varrefs == nil {
		m.varrefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.varrefs[ids[i]] = struct{}{}
	}
}

// ClearVarrefs clears the "varrefs" edge to the VarRef entity.
func (m *VarDataMutation) ClearVarrefs() {
	m.clearedvarrefs = true
}

// VarrefsCleared reports if the "varrefs" edge to the VarRef entity was cleared.
func (m *VarDataMutation) VarrefsCleared() bool {
	return m.clearedvarrefs
}

// RemoveVarrefIDs removes the "varrefs" edge to the VarRef entity by IDs.
func (m *VarDataMutation) RemoveVarrefIDs(ids ...uuid.UUID) {
	if m.removedvarrefs == nil {
		m.removedvarrefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.varrefs, ids[i])
		m.removedvarrefs[ids[i]] = struct{}{}
	}
}

// RemovedVarrefs returns the removed IDs of the "varrefs" edge to the VarRef entity.
func (m *VarDataMutation) RemovedVarrefsIDs() (ids []uuid.UUID) {
	for id := range m.removedvarrefs {
		ids = append(ids, id)
	}
	return
}

// VarrefsIDs returns the "varrefs" edge IDs in the mutation.
func (m *VarDataMutation) VarrefsIDs() (ids []uuid.UUID) {
	for id := range m.varrefs {
		ids = append(ids, id)
	}
	return
}

// ResetVarrefs resets all changes to the "varrefs" edge.
func (m *VarDataMutation) ResetVarrefs() {
	m.varrefs = nil
	m.clearedvarrefs = false
	m.removedvarrefs = nil
}

// Where appends a list predicates to the VarDataMutation builder.
func (m *VarDataMutation) Where(ps ...predicate.VarData) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VarDataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VarData).
func (m *VarDataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VarDataMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, vardata.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, vardata.FieldUpdatedAt)
	}
	if m.size != nil {
		fields = append(fields, vardata.FieldSize)
	}
	if m.hash != nil {
		fields = append(fields, vardata.FieldHash)
	}
	if m.data != nil {
		fields = append(fields, vardata.FieldData)
	}
	if m.mime_type != nil {
		fields = append(fields, vardata.FieldMimeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VarDataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vardata.FieldCreatedAt:
		return m.CreatedAt()
	case vardata.FieldUpdatedAt:
		return m.UpdatedAt()
	case vardata.FieldSize:
		return m.Size()
	case vardata.FieldHash:
		return m.Hash()
	case vardata.FieldData:
		return m.Data()
	case vardata.FieldMimeType:
		return m.MimeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VarDataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vardata.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case vardata.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case vardata.FieldSize:
		return m.OldSize(ctx)
	case vardata.FieldHash:
		return m.OldHash(ctx)
	case vardata.FieldData:
		return m.OldData(ctx)
	case vardata.FieldMimeType:
		return m.OldMimeType(ctx)
	}
	return nil, fmt.Errorf("unknown VarData field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarDataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vardata.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case vardata.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case vardata.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case vardata.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case vardata.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case vardata.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	}
	return fmt.Errorf("unknown VarData field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VarDataMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, vardata.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VarDataMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case vardata.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarDataMutation) AddField(name string, value ent.Value) error {
	switch name {
	case vardata.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown VarData numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VarDataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VarDataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VarDataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown VarData nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VarDataMutation) ResetField(name string) error {
	switch name {
	case vardata.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case vardata.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case vardata.FieldSize:
		m.ResetSize()
		return nil
	case vardata.FieldHash:
		m.ResetHash()
		return nil
	case vardata.FieldData:
		m.ResetData()
		return nil
	case vardata.FieldMimeType:
		m.ResetMimeType()
		return nil
	}
	return fmt.Errorf("unknown VarData field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VarDataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.varrefs != nil {
		edges = append(edges, vardata.EdgeVarrefs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VarDataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case vardata.EdgeVarrefs:
		ids := make([]ent.Value, 0, len(m.varrefs))
		for id := range m.varrefs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VarDataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedvarrefs != nil {
		edges = append(edges, vardata.EdgeVarrefs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VarDataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case vardata.EdgeVarrefs:
		ids := make([]ent.Value, 0, len(m.removedvarrefs))
		for id := range m.removedvarrefs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VarDataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedvarrefs {
		edges = append(edges, vardata.EdgeVarrefs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VarDataMutation) EdgeCleared(name string) bool {
	switch name {
	case vardata.EdgeVarrefs:
		return m.clearedvarrefs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VarDataMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown VarData unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VarDataMutation) ResetEdge(name string) error {
	switch name {
	case vardata.EdgeVarrefs:
		m.ResetVarrefs()
		return nil
	}
	return fmt.Errorf("unknown VarData edge %s", name)
}

// VarRefMutation represents an operation that mutates the VarRef nodes in the graph.
type VarRefMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	behaviour        *string
	clearedFields    map[string]struct{}
	vardata          *uuid.UUID
	clearedvardata   bool
	namespace        *uuid.UUID
	clearednamespace bool
	workflow         *uuid.UUID
	clearedworkflow  bool
	instance         *uuid.UUID
	clearedinstance  bool
	done             bool
	oldValue         func(context.Context) (*VarRef, error)
	predicates       []predicate.VarRef
}

var _ ent.Mutation = (*VarRefMutation)(nil)

// varrefOption allows management of the mutation configuration using functional options.
type varrefOption func(*VarRefMutation)

// newVarRefMutation creates new mutation for the VarRef entity.
func newVarRefMutation(c config, op Op, opts ...varrefOption) *VarRefMutation {
	m := &VarRefMutation{
		config:        c,
		op:            op,
		typ:           TypeVarRef,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVarRefID sets the ID field of the mutation.
func withVarRefID(id uuid.UUID) varrefOption {
	return func(m *VarRefMutation) {
		var (
			err   error
			once  sync.Once
			value *VarRef
		)
		m.oldValue = func(ctx context.Context) (*VarRef, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().VarRef.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVarRef sets the old VarRef of the mutation.
func withVarRef(node *VarRef) varrefOption {
	return func(m *VarRefMutation) {
		m.oldValue = func(context.Context) (*VarRef, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VarRefMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VarRefMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of VarRef entities.
func (m *VarRefMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VarRefMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VarRefMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().VarRef.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *VarRefMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *VarRefMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the VarRef entity.
// If the VarRef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarRefMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *VarRefMutation) ClearName() {
	m.name = nil
	m.clearedFields[varref.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *VarRefMutation) NameCleared() bool {
	_, ok := m.clearedFields[varref.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *VarRefMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, varref.FieldName)
}

// SetBehaviour sets the "behaviour" field.
func (m *VarRefMutation) SetBehaviour(s string) {
	m.behaviour = &s
}

// Behaviour returns the value of the "behaviour" field in the mutation.
func (m *VarRefMutation) Behaviour() (r string, exists bool) {
	v := m.behaviour
	if v == nil {
		return
	}
	return *v, true
}

// OldBehaviour returns the old "behaviour" field's value of the VarRef entity.
// If the VarRef object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VarRefMutation) OldBehaviour(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBehaviour is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBehaviour requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBehaviour: %w", err)
	}
	return oldValue.Behaviour, nil
}

// ClearBehaviour clears the value of the "behaviour" field.
func (m *VarRefMutation) ClearBehaviour() {
	m.behaviour = nil
	m.clearedFields[varref.FieldBehaviour] = struct{}{}
}

// BehaviourCleared returns if the "behaviour" field was cleared in this mutation.
func (m *VarRefMutation) BehaviourCleared() bool {
	_, ok := m.clearedFields[varref.FieldBehaviour]
	return ok
}

// ResetBehaviour resets all changes to the "behaviour" field.
func (m *VarRefMutation) ResetBehaviour() {
	m.behaviour = nil
	delete(m.clearedFields, varref.FieldBehaviour)
}

// SetVardataID sets the "vardata" edge to the VarData entity by id.
func (m *VarRefMutation) SetVardataID(id uuid.UUID) {
	m.vardata = &id
}

// ClearVardata clears the "vardata" edge to the VarData entity.
func (m *VarRefMutation) ClearVardata() {
	m.clearedvardata = true
}

// VardataCleared reports if the "vardata" edge to the VarData entity was cleared.
func (m *VarRefMutation) VardataCleared() bool {
	return m.clearedvardata
}

// VardataID returns the "vardata" edge ID in the mutation.
func (m *VarRefMutation) VardataID() (id uuid.UUID, exists bool) {
	if m.vardata != nil {
		return *m.vardata, true
	}
	return
}

// VardataIDs returns the "vardata" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// VardataID instead. It exists only for internal usage by the builders.
func (m *VarRefMutation) VardataIDs() (ids []uuid.UUID) {
	if id := m.vardata; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetVardata resets all changes to the "vardata" edge.
func (m *VarRefMutation) ResetVardata() {
	m.vardata = nil
	m.clearedvardata = false
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *VarRefMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *VarRefMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *VarRefMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *VarRefMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *VarRefMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *VarRefMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *VarRefMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *VarRefMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *VarRefMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *VarRefMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *VarRefMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *VarRefMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *VarRefMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *VarRefMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *VarRefMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *VarRefMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *VarRefMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *VarRefMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// Where appends a list predicates to the VarRefMutation builder.
func (m *VarRefMutation) Where(ps ...predicate.VarRef) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VarRefMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (VarRef).
func (m *VarRefMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VarRefMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, varref.FieldName)
	}
	if m.behaviour != nil {
		fields = append(fields, varref.FieldBehaviour)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VarRefMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case varref.FieldName:
		return m.Name()
	case varref.FieldBehaviour:
		return m.Behaviour()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VarRefMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case varref.FieldName:
		return m.OldName(ctx)
	case varref.FieldBehaviour:
		return m.OldBehaviour(ctx)
	}
	return nil, fmt.Errorf("unknown VarRef field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarRefMutation) SetField(name string, value ent.Value) error {
	switch name {
	case varref.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case varref.FieldBehaviour:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBehaviour(v)
		return nil
	}
	return fmt.Errorf("unknown VarRef field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VarRefMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VarRefMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VarRefMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown VarRef numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VarRefMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(varref.FieldName) {
		fields = append(fields, varref.FieldName)
	}
	if m.FieldCleared(varref.FieldBehaviour) {
		fields = append(fields, varref.FieldBehaviour)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VarRefMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VarRefMutation) ClearField(name string) error {
	switch name {
	case varref.FieldName:
		m.ClearName()
		return nil
	case varref.FieldBehaviour:
		m.ClearBehaviour()
		return nil
	}
	return fmt.Errorf("unknown VarRef nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VarRefMutation) ResetField(name string) error {
	switch name {
	case varref.FieldName:
		m.ResetName()
		return nil
	case varref.FieldBehaviour:
		m.ResetBehaviour()
		return nil
	}
	return fmt.Errorf("unknown VarRef field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VarRefMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.vardata != nil {
		edges = append(edges, varref.EdgeVardata)
	}
	if m.namespace != nil {
		edges = append(edges, varref.EdgeNamespace)
	}
	if m.workflow != nil {
		edges = append(edges, varref.EdgeWorkflow)
	}
	if m.instance != nil {
		edges = append(edges, varref.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VarRefMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case varref.EdgeVardata:
		if id := m.vardata; id != nil {
			return []ent.Value{*id}
		}
	case varref.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case varref.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case varref.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VarRefMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VarRefMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VarRefMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedvardata {
		edges = append(edges, varref.EdgeVardata)
	}
	if m.clearednamespace {
		edges = append(edges, varref.EdgeNamespace)
	}
	if m.clearedworkflow {
		edges = append(edges, varref.EdgeWorkflow)
	}
	if m.clearedinstance {
		edges = append(edges, varref.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VarRefMutation) EdgeCleared(name string) bool {
	switch name {
	case varref.EdgeVardata:
		return m.clearedvardata
	case varref.EdgeNamespace:
		return m.clearednamespace
	case varref.EdgeWorkflow:
		return m.clearedworkflow
	case varref.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VarRefMutation) ClearEdge(name string) error {
	switch name {
	case varref.EdgeVardata:
		m.ClearVardata()
		return nil
	case varref.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case varref.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case varref.EdgeInstance:
		m.ClearInstance()
		return nil
	}
	return fmt.Errorf("unknown VarRef unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VarRefMutation) ResetEdge(name string) error {
	switch name {
	case varref.EdgeVardata:
		m.ResetVardata()
		return nil
	case varref.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case varref.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case varref.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown VarRef edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	live             *bool
	logToEvents      *string
	clearedFields    map[string]struct{}
	inode            *uuid.UUID
	clearedinode     bool
	namespace        *uuid.UUID
	clearednamespace bool
	revisions        map[uuid.UUID]struct{}
	removedrevisions map[uuid.UUID]struct{}
	clearedrevisions bool
	refs             map[uuid.UUID]struct{}
	removedrefs      map[uuid.UUID]struct{}
	clearedrefs      bool
	instances        map[uuid.UUID]struct{}
	removedinstances map[uuid.UUID]struct{}
	clearedinstances bool
	routes           map[uuid.UUID]struct{}
	removedroutes    map[uuid.UUID]struct{}
	clearedroutes    bool
	logs             map[uuid.UUID]struct{}
	removedlogs      map[uuid.UUID]struct{}
	clearedlogs      bool
	vars             map[uuid.UUID]struct{}
	removedvars      map[uuid.UUID]struct{}
	clearedvars      bool
	wfevents         map[uuid.UUID]struct{}
	removedwfevents  map[uuid.UUID]struct{}
	clearedwfevents  bool
	done             bool
	oldValue         func(context.Context) (*Workflow, error)
	predicates       []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id uuid.UUID) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workflow entities.
func (m *WorkflowMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkflowMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workflow.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLive sets the "live" field.
func (m *WorkflowMutation) SetLive(b bool) {
	m.live = &b
}

// Live returns the value of the "live" field in the mutation.
func (m *WorkflowMutation) Live() (r bool, exists bool) {
	v := m.live
	if v == nil {
		return
	}
	return *v, true
}

// OldLive returns the old "live" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldLive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLive: %w", err)
	}
	return oldValue.Live, nil
}

// ResetLive resets all changes to the "live" field.
func (m *WorkflowMutation) ResetLive() {
	m.live = nil
}

// SetLogToEvents sets the "logToEvents" field.
func (m *WorkflowMutation) SetLogToEvents(s string) {
	m.logToEvents = &s
}

// LogToEvents returns the value of the "logToEvents" field in the mutation.
func (m *WorkflowMutation) LogToEvents() (r string, exists bool) {
	v := m.logToEvents
	if v == nil {
		return
	}
	return *v, true
}

// OldLogToEvents returns the old "logToEvents" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldLogToEvents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogToEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogToEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogToEvents: %w", err)
	}
	return oldValue.LogToEvents, nil
}

// ClearLogToEvents clears the value of the "logToEvents" field.
func (m *WorkflowMutation) ClearLogToEvents() {
	m.logToEvents = nil
	m.clearedFields[workflow.FieldLogToEvents] = struct{}{}
}

// LogToEventsCleared returns if the "logToEvents" field was cleared in this mutation.
func (m *WorkflowMutation) LogToEventsCleared() bool {
	_, ok := m.clearedFields[workflow.FieldLogToEvents]
	return ok
}

// ResetLogToEvents resets all changes to the "logToEvents" field.
func (m *WorkflowMutation) ResetLogToEvents() {
	m.logToEvents = nil
	delete(m.clearedFields, workflow.FieldLogToEvents)
}

// SetInodeID sets the "inode" edge to the Inode entity by id.
func (m *WorkflowMutation) SetInodeID(id uuid.UUID) {
	m.inode = &id
}

// ClearInode clears the "inode" edge to the Inode entity.
func (m *WorkflowMutation) ClearInode() {
	m.clearedinode = true
}

// InodeCleared reports if the "inode" edge to the Inode entity was cleared.
func (m *WorkflowMutation) InodeCleared() bool {
	return m.clearedinode
}

// InodeID returns the "inode" edge ID in the mutation.
func (m *WorkflowMutation) InodeID() (id uuid.UUID, exists bool) {
	if m.inode != nil {
		return *m.inode, true
	}
	return
}

// InodeIDs returns the "inode" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InodeID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) InodeIDs() (ids []uuid.UUID) {
	if id := m.inode; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInode resets all changes to the "inode" edge.
func (m *WorkflowMutation) ResetInode() {
	m.inode = nil
	m.clearedinode = false
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *WorkflowMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *WorkflowMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *WorkflowMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *WorkflowMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *WorkflowMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddRevisionIDs adds the "revisions" edge to the Revision entity by ids.
func (m *WorkflowMutation) AddRevisionIDs(ids ...uuid.UUID) {
	if m.revisions == nil {
		m.revisions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.revisions[ids[i]] = struct{}{}
	}
}

// ClearRevisions clears the "revisions" edge to the Revision entity.
func (m *WorkflowMutation) ClearRevisions() {
	m.clearedrevisions = true
}

// RevisionsCleared reports if the "revisions" edge to the Revision entity was cleared.
func (m *WorkflowMutation) RevisionsCleared() bool {
	return m.clearedrevisions
}

// RemoveRevisionIDs removes the "revisions" edge to the Revision entity by IDs.
func (m *WorkflowMutation) RemoveRevisionIDs(ids ...uuid.UUID) {
	if m.removedrevisions == nil {
		m.removedrevisions = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.revisions, ids[i])
		m.removedrevisions[ids[i]] = struct{}{}
	}
}

// RemovedRevisions returns the removed IDs of the "revisions" edge to the Revision entity.
func (m *WorkflowMutation) RemovedRevisionsIDs() (ids []uuid.UUID) {
	for id := range m.removedrevisions {
		ids = append(ids, id)
	}
	return
}

// RevisionsIDs returns the "revisions" edge IDs in the mutation.
func (m *WorkflowMutation) RevisionsIDs() (ids []uuid.UUID) {
	for id := range m.revisions {
		ids = append(ids, id)
	}
	return
}

// ResetRevisions resets all changes to the "revisions" edge.
func (m *WorkflowMutation) ResetRevisions() {
	m.revisions = nil
	m.clearedrevisions = false
	m.removedrevisions = nil
}

// AddRefIDs adds the "refs" edge to the Ref entity by ids.
func (m *WorkflowMutation) AddRefIDs(ids ...uuid.UUID) {
	if m.refs == nil {
		m.refs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.refs[ids[i]] = struct{}{}
	}
}

// ClearRefs clears the "refs" edge to the Ref entity.
func (m *WorkflowMutation) ClearRefs() {
	m.clearedrefs = true
}

// RefsCleared reports if the "refs" edge to the Ref entity was cleared.
func (m *WorkflowMutation) RefsCleared() bool {
	return m.clearedrefs
}

// RemoveRefIDs removes the "refs" edge to the Ref entity by IDs.
func (m *WorkflowMutation) RemoveRefIDs(ids ...uuid.UUID) {
	if m.removedrefs == nil {
		m.removedrefs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.refs, ids[i])
		m.removedrefs[ids[i]] = struct{}{}
	}
}

// RemovedRefs returns the removed IDs of the "refs" edge to the Ref entity.
func (m *WorkflowMutation) RemovedRefsIDs() (ids []uuid.UUID) {
	for id := range m.removedrefs {
		ids = append(ids, id)
	}
	return
}

// RefsIDs returns the "refs" edge IDs in the mutation.
func (m *WorkflowMutation) RefsIDs() (ids []uuid.UUID) {
	for id := range m.refs {
		ids = append(ids, id)
	}
	return
}

// ResetRefs resets all changes to the "refs" edge.
func (m *WorkflowMutation) ResetRefs() {
	m.refs = nil
	m.clearedrefs = false
	m.removedrefs = nil
}

// AddInstanceIDs adds the "instances" edge to the Instance entity by ids.
func (m *WorkflowMutation) AddInstanceIDs(ids ...uuid.UUID) {
	if m.instances == nil {
		m.instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the Instance entity.
func (m *WorkflowMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the Instance entity was cleared.
func (m *WorkflowMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the Instance entity by IDs.
func (m *WorkflowMutation) RemoveInstanceIDs(ids ...uuid.UUID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the Instance entity.
func (m *WorkflowMutation) RemovedInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *WorkflowMutation) InstancesIDs() (ids []uuid.UUID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *WorkflowMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// AddRouteIDs adds the "routes" edge to the Route entity by ids.
func (m *WorkflowMutation) AddRouteIDs(ids ...uuid.UUID) {
	if m.routes == nil {
		m.routes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.routes[ids[i]] = struct{}{}
	}
}

// ClearRoutes clears the "routes" edge to the Route entity.
func (m *WorkflowMutation) ClearRoutes() {
	m.clearedroutes = true
}

// RoutesCleared reports if the "routes" edge to the Route entity was cleared.
func (m *WorkflowMutation) RoutesCleared() bool {
	return m.clearedroutes
}

// RemoveRouteIDs removes the "routes" edge to the Route entity by IDs.
func (m *WorkflowMutation) RemoveRouteIDs(ids ...uuid.UUID) {
	if m.removedroutes == nil {
		m.removedroutes = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.routes, ids[i])
		m.removedroutes[ids[i]] = struct{}{}
	}
}

// RemovedRoutes returns the removed IDs of the "routes" edge to the Route entity.
func (m *WorkflowMutation) RemovedRoutesIDs() (ids []uuid.UUID) {
	for id := range m.removedroutes {
		ids = append(ids, id)
	}
	return
}

// RoutesIDs returns the "routes" edge IDs in the mutation.
func (m *WorkflowMutation) RoutesIDs() (ids []uuid.UUID) {
	for id := range m.routes {
		ids = append(ids, id)
	}
	return
}

// ResetRoutes resets all changes to the "routes" edge.
func (m *WorkflowMutation) ResetRoutes() {
	m.routes = nil
	m.clearedroutes = false
	m.removedroutes = nil
}

// AddLogIDs adds the "logs" edge to the LogMsg entity by ids.
func (m *WorkflowMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the LogMsg entity.
func (m *WorkflowMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the LogMsg entity was cleared.
func (m *WorkflowMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the LogMsg entity by IDs.
func (m *WorkflowMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the LogMsg entity.
func (m *WorkflowMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *WorkflowMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *WorkflowMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddVarIDs adds the "vars" edge to the VarRef entity by ids.
func (m *WorkflowMutation) AddVarIDs(ids ...uuid.UUID) {
	if m.vars == nil {
		m.vars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.vars[ids[i]] = struct{}{}
	}
}

// ClearVars clears the "vars" edge to the VarRef entity.
func (m *WorkflowMutation) ClearVars() {
	m.clearedvars = true
}

// VarsCleared reports if the "vars" edge to the VarRef entity was cleared.
func (m *WorkflowMutation) VarsCleared() bool {
	return m.clearedvars
}

// RemoveVarIDs removes the "vars" edge to the VarRef entity by IDs.
func (m *WorkflowMutation) RemoveVarIDs(ids ...uuid.UUID) {
	if m.removedvars == nil {
		m.removedvars = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.vars, ids[i])
		m.removedvars[ids[i]] = struct{}{}
	}
}

// RemovedVars returns the removed IDs of the "vars" edge to the VarRef entity.
func (m *WorkflowMutation) RemovedVarsIDs() (ids []uuid.UUID) {
	for id := range m.removedvars {
		ids = append(ids, id)
	}
	return
}

// VarsIDs returns the "vars" edge IDs in the mutation.
func (m *WorkflowMutation) VarsIDs() (ids []uuid.UUID) {
	for id := range m.vars {
		ids = append(ids, id)
	}
	return
}

// ResetVars resets all changes to the "vars" edge.
func (m *WorkflowMutation) ResetVars() {
	m.vars = nil
	m.clearedvars = false
	m.removedvars = nil
}

// AddWfeventIDs adds the "wfevents" edge to the Events entity by ids.
func (m *WorkflowMutation) AddWfeventIDs(ids ...uuid.UUID) {
	if m.wfevents == nil {
		m.wfevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.wfevents[ids[i]] = struct{}{}
	}
}

// ClearWfevents clears the "wfevents" edge to the Events entity.
func (m *WorkflowMutation) ClearWfevents() {
	m.clearedwfevents = true
}

// WfeventsCleared reports if the "wfevents" edge to the Events entity was cleared.
func (m *WorkflowMutation) WfeventsCleared() bool {
	return m.clearedwfevents
}

// RemoveWfeventIDs removes the "wfevents" edge to the Events entity by IDs.
func (m *WorkflowMutation) RemoveWfeventIDs(ids ...uuid.UUID) {
	if m.removedwfevents == nil {
		m.removedwfevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.wfevents, ids[i])
		m.removedwfevents[ids[i]] = struct{}{}
	}
}

// RemovedWfevents returns the removed IDs of the "wfevents" edge to the Events entity.
func (m *WorkflowMutation) RemovedWfeventsIDs() (ids []uuid.UUID) {
	for id := range m.removedwfevents {
		ids = append(ids, id)
	}
	return
}

// WfeventsIDs returns the "wfevents" edge IDs in the mutation.
func (m *WorkflowMutation) WfeventsIDs() (ids []uuid.UUID) {
	for id := range m.wfevents {
		ids = append(ids, id)
	}
	return
}

// ResetWfevents resets all changes to the "wfevents" edge.
func (m *WorkflowMutation) ResetWfevents() {
	m.wfevents = nil
	m.clearedwfevents = false
	m.removedwfevents = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.live != nil {
		fields = append(fields, workflow.FieldLive)
	}
	if m.logToEvents != nil {
		fields = append(fields, workflow.FieldLogToEvents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldLive:
		return m.Live()
	case workflow.FieldLogToEvents:
		return m.LogToEvents()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldLive:
		return m.OldLive(ctx)
	case workflow.FieldLogToEvents:
		return m.OldLogToEvents(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldLive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLive(v)
		return nil
	case workflow.FieldLogToEvents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogToEvents(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldLogToEvents) {
		fields = append(fields, workflow.FieldLogToEvents)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldLogToEvents:
		m.ClearLogToEvents()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldLive:
		m.ResetLive()
		return nil
	case workflow.FieldLogToEvents:
		m.ResetLogToEvents()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.inode != nil {
		edges = append(edges, workflow.EdgeInode)
	}
	if m.namespace != nil {
		edges = append(edges, workflow.EdgeNamespace)
	}
	if m.revisions != nil {
		edges = append(edges, workflow.EdgeRevisions)
	}
	if m.refs != nil {
		edges = append(edges, workflow.EdgeRefs)
	}
	if m.instances != nil {
		edges = append(edges, workflow.EdgeInstances)
	}
	if m.routes != nil {
		edges = append(edges, workflow.EdgeRoutes)
	}
	if m.logs != nil {
		edges = append(edges, workflow.EdgeLogs)
	}
	if m.vars != nil {
		edges = append(edges, workflow.EdgeVars)
	}
	if m.wfevents != nil {
		edges = append(edges, workflow.EdgeWfevents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeInode:
		if id := m.inode; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.revisions))
		for id := range m.revisions {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeRefs:
		ids := make([]ent.Value, 0, len(m.refs))
		for id := range m.refs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.routes))
		for id := range m.routes {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeVars:
		ids := make([]ent.Value, 0, len(m.vars))
		for id := range m.vars {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeWfevents:
		ids := make([]ent.Value, 0, len(m.wfevents))
		for id := range m.wfevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedrevisions != nil {
		edges = append(edges, workflow.EdgeRevisions)
	}
	if m.removedrefs != nil {
		edges = append(edges, workflow.EdgeRefs)
	}
	if m.removedinstances != nil {
		edges = append(edges, workflow.EdgeInstances)
	}
	if m.removedroutes != nil {
		edges = append(edges, workflow.EdgeRoutes)
	}
	if m.removedlogs != nil {
		edges = append(edges, workflow.EdgeLogs)
	}
	if m.removedvars != nil {
		edges = append(edges, workflow.EdgeVars)
	}
	if m.removedwfevents != nil {
		edges = append(edges, workflow.EdgeWfevents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeRevisions:
		ids := make([]ent.Value, 0, len(m.removedrevisions))
		for id := range m.removedrevisions {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeRefs:
		ids := make([]ent.Value, 0, len(m.removedrefs))
		for id := range m.removedrefs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeRoutes:
		ids := make([]ent.Value, 0, len(m.removedroutes))
		for id := range m.removedroutes {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeVars:
		ids := make([]ent.Value, 0, len(m.removedvars))
		for id := range m.removedvars {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeWfevents:
		ids := make([]ent.Value, 0, len(m.removedwfevents))
		for id := range m.removedwfevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedinode {
		edges = append(edges, workflow.EdgeInode)
	}
	if m.clearednamespace {
		edges = append(edges, workflow.EdgeNamespace)
	}
	if m.clearedrevisions {
		edges = append(edges, workflow.EdgeRevisions)
	}
	if m.clearedrefs {
		edges = append(edges, workflow.EdgeRefs)
	}
	if m.clearedinstances {
		edges = append(edges, workflow.EdgeInstances)
	}
	if m.clearedroutes {
		edges = append(edges, workflow.EdgeRoutes)
	}
	if m.clearedlogs {
		edges = append(edges, workflow.EdgeLogs)
	}
	if m.clearedvars {
		edges = append(edges, workflow.EdgeVars)
	}
	if m.clearedwfevents {
		edges = append(edges, workflow.EdgeWfevents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeInode:
		return m.clearedinode
	case workflow.EdgeNamespace:
		return m.clearednamespace
	case workflow.EdgeRevisions:
		return m.clearedrevisions
	case workflow.EdgeRefs:
		return m.clearedrefs
	case workflow.EdgeInstances:
		return m.clearedinstances
	case workflow.EdgeRoutes:
		return m.clearedroutes
	case workflow.EdgeLogs:
		return m.clearedlogs
	case workflow.EdgeVars:
		return m.clearedvars
	case workflow.EdgeWfevents:
		return m.clearedwfevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	case workflow.EdgeInode:
		m.ClearInode()
		return nil
	case workflow.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeInode:
		m.ResetInode()
		return nil
	case workflow.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case workflow.EdgeRevisions:
		m.ResetRevisions()
		return nil
	case workflow.EdgeRefs:
		m.ResetRefs()
		return nil
	case workflow.EdgeInstances:
		m.ResetInstances()
		return nil
	case workflow.EdgeRoutes:
		m.ResetRoutes()
		return nil
	case workflow.EdgeLogs:
		m.ResetLogs()
		return nil
	case workflow.EdgeVars:
		m.ResetVars()
		return nil
	case workflow.EdgeWfevents:
		m.ResetWfevents()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}
