// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/cloudevents/sdk-go/v2/event"
	"github.com/direktiv/direktiv/pkg/flow/ent/annotation"
	"github.com/direktiv/direktiv/pkg/flow/ent/cloudeventfilters"
	"github.com/direktiv/direktiv/pkg/flow/ent/cloudevents"
	"github.com/direktiv/direktiv/pkg/flow/ent/events"
	"github.com/direktiv/direktiv/pkg/flow/ent/eventswait"
	"github.com/direktiv/direktiv/pkg/flow/ent/instance"
	"github.com/direktiv/direktiv/pkg/flow/ent/instanceruntime"
	"github.com/direktiv/direktiv/pkg/flow/ent/logmsg"
	"github.com/direktiv/direktiv/pkg/flow/ent/namespace"
	"github.com/direktiv/direktiv/pkg/flow/ent/predicate"
	"github.com/direktiv/direktiv/pkg/flow/ent/services"
	"github.com/google/uuid"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnnotation        = "Annotation"
	TypeCloudEventFilters = "CloudEventFilters"
	TypeCloudEvents       = "CloudEvents"
	TypeEvents            = "Events"
	TypeEventsWait        = "EventsWait"
	TypeInstance          = "Instance"
	TypeInstanceRuntime   = "InstanceRuntime"
	TypeLogMsg            = "LogMsg"
	TypeNamespace         = "Namespace"
	TypeServices          = "Services"
)

// AnnotationMutation represents an operation that mutates the Annotation nodes in the graph.
type AnnotationMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	created_at       *time.Time
	updated_at       *time.Time
	size             *int
	addsize          *int
	hash             *string
	data             *[]byte
	mime_type        *string
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	instance         *uuid.UUID
	clearedinstance  bool
	done             bool
	oldValue         func(context.Context) (*Annotation, error)
	predicates       []predicate.Annotation
}

var _ ent.Mutation = (*AnnotationMutation)(nil)

// annotationOption allows management of the mutation configuration using functional options.
type annotationOption func(*AnnotationMutation)

// newAnnotationMutation creates new mutation for the Annotation entity.
func newAnnotationMutation(c config, op Op, opts ...annotationOption) *AnnotationMutation {
	m := &AnnotationMutation{
		config:        c,
		op:            op,
		typ:           TypeAnnotation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnnotationID sets the ID field of the mutation.
func withAnnotationID(id uuid.UUID) annotationOption {
	return func(m *AnnotationMutation) {
		var (
			err   error
			once  sync.Once
			value *Annotation
		)
		m.oldValue = func(ctx context.Context) (*Annotation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Annotation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnnotation sets the old Annotation of the mutation.
func withAnnotation(node *Annotation) annotationOption {
	return func(m *AnnotationMutation) {
		m.oldValue = func(context.Context) (*Annotation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnnotationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnnotationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Annotation entities.
func (m *AnnotationMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AnnotationMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AnnotationMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Annotation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *AnnotationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AnnotationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AnnotationMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *AnnotationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AnnotationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AnnotationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AnnotationMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AnnotationMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AnnotationMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetSize sets the "size" field.
func (m *AnnotationMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *AnnotationMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *AnnotationMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *AnnotationMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *AnnotationMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetHash sets the "hash" field.
func (m *AnnotationMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *AnnotationMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *AnnotationMutation) ResetHash() {
	m.hash = nil
}

// SetData sets the "data" field.
func (m *AnnotationMutation) SetData(b []byte) {
	m.data = &b
}

// Data returns the value of the "data" field in the mutation.
func (m *AnnotationMutation) Data() (r []byte, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldData(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *AnnotationMutation) ResetData() {
	m.data = nil
}

// SetMimeType sets the "mime_type" field.
func (m *AnnotationMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *AnnotationMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Annotation entity.
// If the Annotation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnnotationMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *AnnotationMutation) ResetMimeType() {
	m.mime_type = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *AnnotationMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *AnnotationMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *AnnotationMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *AnnotationMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *AnnotationMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *AnnotationMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *AnnotationMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *AnnotationMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *AnnotationMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *AnnotationMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *AnnotationMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *AnnotationMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// Where appends a list predicates to the AnnotationMutation builder.
func (m *AnnotationMutation) Where(ps ...predicate.Annotation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AnnotationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AnnotationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Annotation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AnnotationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AnnotationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Annotation).
func (m *AnnotationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnnotationMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, annotation.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, annotation.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, annotation.FieldUpdatedAt)
	}
	if m.size != nil {
		fields = append(fields, annotation.FieldSize)
	}
	if m.hash != nil {
		fields = append(fields, annotation.FieldHash)
	}
	if m.data != nil {
		fields = append(fields, annotation.FieldData)
	}
	if m.mime_type != nil {
		fields = append(fields, annotation.FieldMimeType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnnotationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case annotation.FieldName:
		return m.Name()
	case annotation.FieldCreatedAt:
		return m.CreatedAt()
	case annotation.FieldUpdatedAt:
		return m.UpdatedAt()
	case annotation.FieldSize:
		return m.Size()
	case annotation.FieldHash:
		return m.Hash()
	case annotation.FieldData:
		return m.Data()
	case annotation.FieldMimeType:
		return m.MimeType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnnotationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case annotation.FieldName:
		return m.OldName(ctx)
	case annotation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case annotation.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case annotation.FieldSize:
		return m.OldSize(ctx)
	case annotation.FieldHash:
		return m.OldHash(ctx)
	case annotation.FieldData:
		return m.OldData(ctx)
	case annotation.FieldMimeType:
		return m.OldMimeType(ctx)
	}
	return nil, fmt.Errorf("unknown Annotation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnotationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case annotation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case annotation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case annotation.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case annotation.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case annotation.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case annotation.FieldData:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case annotation.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	}
	return fmt.Errorf("unknown Annotation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnnotationMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, annotation.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnnotationMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case annotation.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnnotationMutation) AddField(name string, value ent.Value) error {
	switch name {
	case annotation.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Annotation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnnotationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnnotationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnnotationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Annotation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnnotationMutation) ResetField(name string) error {
	switch name {
	case annotation.FieldName:
		m.ResetName()
		return nil
	case annotation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case annotation.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case annotation.FieldSize:
		m.ResetSize()
		return nil
	case annotation.FieldHash:
		m.ResetHash()
		return nil
	case annotation.FieldData:
		m.ResetData()
		return nil
	case annotation.FieldMimeType:
		m.ResetMimeType()
		return nil
	}
	return fmt.Errorf("unknown Annotation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnnotationMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.namespace != nil {
		edges = append(edges, annotation.EdgeNamespace)
	}
	if m.instance != nil {
		edges = append(edges, annotation.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnnotationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case annotation.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case annotation.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnnotationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnnotationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnnotationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednamespace {
		edges = append(edges, annotation.EdgeNamespace)
	}
	if m.clearedinstance {
		edges = append(edges, annotation.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnnotationMutation) EdgeCleared(name string) bool {
	switch name {
	case annotation.EdgeNamespace:
		return m.clearednamespace
	case annotation.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnnotationMutation) ClearEdge(name string) error {
	switch name {
	case annotation.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case annotation.EdgeInstance:
		m.ClearInstance()
		return nil
	}
	return fmt.Errorf("unknown Annotation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnnotationMutation) ResetEdge(name string) error {
	switch name {
	case annotation.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case annotation.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown Annotation edge %s", name)
}

// CloudEventFiltersMutation represents an operation that mutates the CloudEventFilters nodes in the graph.
type CloudEventFiltersMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	jscode           *string
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	done             bool
	oldValue         func(context.Context) (*CloudEventFilters, error)
	predicates       []predicate.CloudEventFilters
}

var _ ent.Mutation = (*CloudEventFiltersMutation)(nil)

// cloudeventfiltersOption allows management of the mutation configuration using functional options.
type cloudeventfiltersOption func(*CloudEventFiltersMutation)

// newCloudEventFiltersMutation creates new mutation for the CloudEventFilters entity.
func newCloudEventFiltersMutation(c config, op Op, opts ...cloudeventfiltersOption) *CloudEventFiltersMutation {
	m := &CloudEventFiltersMutation{
		config:        c,
		op:            op,
		typ:           TypeCloudEventFilters,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCloudEventFiltersID sets the ID field of the mutation.
func withCloudEventFiltersID(id int) cloudeventfiltersOption {
	return func(m *CloudEventFiltersMutation) {
		var (
			err   error
			once  sync.Once
			value *CloudEventFilters
		)
		m.oldValue = func(ctx context.Context) (*CloudEventFilters, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CloudEventFilters.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCloudEventFilters sets the old CloudEventFilters of the mutation.
func withCloudEventFilters(node *CloudEventFilters) cloudeventfiltersOption {
	return func(m *CloudEventFiltersMutation) {
		m.oldValue = func(context.Context) (*CloudEventFilters, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CloudEventFiltersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CloudEventFiltersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CloudEventFiltersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CloudEventFiltersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CloudEventFilters.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *CloudEventFiltersMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CloudEventFiltersMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the CloudEventFilters entity.
// If the CloudEventFilters object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventFiltersMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CloudEventFiltersMutation) ResetName() {
	m.name = nil
}

// SetJscode sets the "jscode" field.
func (m *CloudEventFiltersMutation) SetJscode(s string) {
	m.jscode = &s
}

// Jscode returns the value of the "jscode" field in the mutation.
func (m *CloudEventFiltersMutation) Jscode() (r string, exists bool) {
	v := m.jscode
	if v == nil {
		return
	}
	return *v, true
}

// OldJscode returns the old "jscode" field's value of the CloudEventFilters entity.
// If the CloudEventFilters object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventFiltersMutation) OldJscode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldJscode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldJscode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldJscode: %w", err)
	}
	return oldValue.Jscode, nil
}

// ResetJscode resets all changes to the "jscode" field.
func (m *CloudEventFiltersMutation) ResetJscode() {
	m.jscode = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *CloudEventFiltersMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *CloudEventFiltersMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *CloudEventFiltersMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *CloudEventFiltersMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *CloudEventFiltersMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *CloudEventFiltersMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the CloudEventFiltersMutation builder.
func (m *CloudEventFiltersMutation) Where(ps ...predicate.CloudEventFilters) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CloudEventFiltersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CloudEventFiltersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CloudEventFilters, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CloudEventFiltersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CloudEventFiltersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CloudEventFilters).
func (m *CloudEventFiltersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CloudEventFiltersMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, cloudeventfilters.FieldName)
	}
	if m.jscode != nil {
		fields = append(fields, cloudeventfilters.FieldJscode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CloudEventFiltersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cloudeventfilters.FieldName:
		return m.Name()
	case cloudeventfilters.FieldJscode:
		return m.Jscode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CloudEventFiltersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cloudeventfilters.FieldName:
		return m.OldName(ctx)
	case cloudeventfilters.FieldJscode:
		return m.OldJscode(ctx)
	}
	return nil, fmt.Errorf("unknown CloudEventFilters field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventFiltersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cloudeventfilters.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case cloudeventfilters.FieldJscode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetJscode(v)
		return nil
	}
	return fmt.Errorf("unknown CloudEventFilters field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CloudEventFiltersMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CloudEventFiltersMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventFiltersMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CloudEventFilters numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CloudEventFiltersMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CloudEventFiltersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CloudEventFiltersMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CloudEventFilters nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CloudEventFiltersMutation) ResetField(name string) error {
	switch name {
	case cloudeventfilters.FieldName:
		m.ResetName()
		return nil
	case cloudeventfilters.FieldJscode:
		m.ResetJscode()
		return nil
	}
	return fmt.Errorf("unknown CloudEventFilters field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CloudEventFiltersMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespace != nil {
		edges = append(edges, cloudeventfilters.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CloudEventFiltersMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cloudeventfilters.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CloudEventFiltersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CloudEventFiltersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CloudEventFiltersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespace {
		edges = append(edges, cloudeventfilters.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CloudEventFiltersMutation) EdgeCleared(name string) bool {
	switch name {
	case cloudeventfilters.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CloudEventFiltersMutation) ClearEdge(name string) error {
	switch name {
	case cloudeventfilters.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEventFilters unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CloudEventFiltersMutation) ResetEdge(name string) error {
	switch name {
	case cloudeventfilters.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEventFilters edge %s", name)
}

// CloudEventsMutation represents an operation that mutates the CloudEvents nodes in the graph.
type CloudEventsMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	eventId          *string
	event            *event.Event
	fire             *time.Time
	created          *time.Time
	processed        *bool
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	done             bool
	oldValue         func(context.Context) (*CloudEvents, error)
	predicates       []predicate.CloudEvents
}

var _ ent.Mutation = (*CloudEventsMutation)(nil)

// cloudeventsOption allows management of the mutation configuration using functional options.
type cloudeventsOption func(*CloudEventsMutation)

// newCloudEventsMutation creates new mutation for the CloudEvents entity.
func newCloudEventsMutation(c config, op Op, opts ...cloudeventsOption) *CloudEventsMutation {
	m := &CloudEventsMutation{
		config:        c,
		op:            op,
		typ:           TypeCloudEvents,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCloudEventsID sets the ID field of the mutation.
func withCloudEventsID(id uuid.UUID) cloudeventsOption {
	return func(m *CloudEventsMutation) {
		var (
			err   error
			once  sync.Once
			value *CloudEvents
		)
		m.oldValue = func(ctx context.Context) (*CloudEvents, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CloudEvents.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCloudEvents sets the old CloudEvents of the mutation.
func withCloudEvents(node *CloudEvents) cloudeventsOption {
	return func(m *CloudEventsMutation) {
		m.oldValue = func(context.Context) (*CloudEvents, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CloudEventsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CloudEventsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CloudEvents entities.
func (m *CloudEventsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CloudEventsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CloudEventsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CloudEvents.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventId sets the "eventId" field.
func (m *CloudEventsMutation) SetEventId(s string) {
	m.eventId = &s
}

// EventId returns the value of the "eventId" field in the mutation.
func (m *CloudEventsMutation) EventId() (r string, exists bool) {
	v := m.eventId
	if v == nil {
		return
	}
	return *v, true
}

// OldEventId returns the old "eventId" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldEventId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventId: %w", err)
	}
	return oldValue.EventId, nil
}

// ResetEventId resets all changes to the "eventId" field.
func (m *CloudEventsMutation) ResetEventId() {
	m.eventId = nil
}

// SetEvent sets the "event" field.
func (m *CloudEventsMutation) SetEvent(e event.Event) {
	m.event = &e
}

// Event returns the value of the "event" field in the mutation.
func (m *CloudEventsMutation) Event() (r event.Event, exists bool) {
	v := m.event
	if v == nil {
		return
	}
	return *v, true
}

// OldEvent returns the old "event" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldEvent(ctx context.Context) (v event.Event, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvent: %w", err)
	}
	return oldValue.Event, nil
}

// ResetEvent resets all changes to the "event" field.
func (m *CloudEventsMutation) ResetEvent() {
	m.event = nil
}

// SetFire sets the "fire" field.
func (m *CloudEventsMutation) SetFire(t time.Time) {
	m.fire = &t
}

// Fire returns the value of the "fire" field in the mutation.
func (m *CloudEventsMutation) Fire() (r time.Time, exists bool) {
	v := m.fire
	if v == nil {
		return
	}
	return *v, true
}

// OldFire returns the old "fire" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldFire(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFire is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFire requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFire: %w", err)
	}
	return oldValue.Fire, nil
}

// ResetFire resets all changes to the "fire" field.
func (m *CloudEventsMutation) ResetFire() {
	m.fire = nil
}

// SetCreated sets the "created" field.
func (m *CloudEventsMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *CloudEventsMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *CloudEventsMutation) ResetCreated() {
	m.created = nil
}

// SetProcessed sets the "processed" field.
func (m *CloudEventsMutation) SetProcessed(b bool) {
	m.processed = &b
}

// Processed returns the value of the "processed" field in the mutation.
func (m *CloudEventsMutation) Processed() (r bool, exists bool) {
	v := m.processed
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessed returns the old "processed" field's value of the CloudEvents entity.
// If the CloudEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CloudEventsMutation) OldProcessed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessed: %w", err)
	}
	return oldValue.Processed, nil
}

// ResetProcessed resets all changes to the "processed" field.
func (m *CloudEventsMutation) ResetProcessed() {
	m.processed = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *CloudEventsMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *CloudEventsMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *CloudEventsMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *CloudEventsMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *CloudEventsMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *CloudEventsMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the CloudEventsMutation builder.
func (m *CloudEventsMutation) Where(ps ...predicate.CloudEvents) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CloudEventsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CloudEventsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CloudEvents, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CloudEventsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CloudEventsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CloudEvents).
func (m *CloudEventsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CloudEventsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.eventId != nil {
		fields = append(fields, cloudevents.FieldEventId)
	}
	if m.event != nil {
		fields = append(fields, cloudevents.FieldEvent)
	}
	if m.fire != nil {
		fields = append(fields, cloudevents.FieldFire)
	}
	if m.created != nil {
		fields = append(fields, cloudevents.FieldCreated)
	}
	if m.processed != nil {
		fields = append(fields, cloudevents.FieldProcessed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CloudEventsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case cloudevents.FieldEventId:
		return m.EventId()
	case cloudevents.FieldEvent:
		return m.Event()
	case cloudevents.FieldFire:
		return m.Fire()
	case cloudevents.FieldCreated:
		return m.Created()
	case cloudevents.FieldProcessed:
		return m.Processed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CloudEventsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case cloudevents.FieldEventId:
		return m.OldEventId(ctx)
	case cloudevents.FieldEvent:
		return m.OldEvent(ctx)
	case cloudevents.FieldFire:
		return m.OldFire(ctx)
	case cloudevents.FieldCreated:
		return m.OldCreated(ctx)
	case cloudevents.FieldProcessed:
		return m.OldProcessed(ctx)
	}
	return nil, fmt.Errorf("unknown CloudEvents field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case cloudevents.FieldEventId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventId(v)
		return nil
	case cloudevents.FieldEvent:
		v, ok := value.(event.Event)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvent(v)
		return nil
	case cloudevents.FieldFire:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFire(v)
		return nil
	case cloudevents.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case cloudevents.FieldProcessed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessed(v)
		return nil
	}
	return fmt.Errorf("unknown CloudEvents field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CloudEventsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CloudEventsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CloudEventsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CloudEvents numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CloudEventsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CloudEventsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CloudEventsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CloudEvents nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CloudEventsMutation) ResetField(name string) error {
	switch name {
	case cloudevents.FieldEventId:
		m.ResetEventId()
		return nil
	case cloudevents.FieldEvent:
		m.ResetEvent()
		return nil
	case cloudevents.FieldFire:
		m.ResetFire()
		return nil
	case cloudevents.FieldCreated:
		m.ResetCreated()
		return nil
	case cloudevents.FieldProcessed:
		m.ResetProcessed()
		return nil
	}
	return fmt.Errorf("unknown CloudEvents field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CloudEventsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespace != nil {
		edges = append(edges, cloudevents.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CloudEventsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case cloudevents.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CloudEventsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CloudEventsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CloudEventsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespace {
		edges = append(edges, cloudevents.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CloudEventsMutation) EdgeCleared(name string) bool {
	switch name {
	case cloudevents.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CloudEventsMutation) ClearEdge(name string) error {
	switch name {
	case cloudevents.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEvents unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CloudEventsMutation) ResetEdge(name string) error {
	switch name {
	case cloudevents.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown CloudEvents edge %s", name)
}

// EventsMutation represents an operation that mutates the Events nodes in the graph.
type EventsMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	events              *[]map[string]interface{}
	appendevents        []map[string]interface{}
	correlations        *[]string
	appendcorrelations  []string
	signature           *[]byte
	count               *int
	addcount            *int
	created_at          *time.Time
	updated_at          *time.Time
	workflow_id         *uuid.UUID
	clearedFields       map[string]struct{}
	wfeventswait        map[uuid.UUID]struct{}
	removedwfeventswait map[uuid.UUID]struct{}
	clearedwfeventswait bool
	instance            *uuid.UUID
	clearedinstance     bool
	namespace           *uuid.UUID
	clearednamespace    bool
	done                bool
	oldValue            func(context.Context) (*Events, error)
	predicates          []predicate.Events
}

var _ ent.Mutation = (*EventsMutation)(nil)

// eventsOption allows management of the mutation configuration using functional options.
type eventsOption func(*EventsMutation)

// newEventsMutation creates new mutation for the Events entity.
func newEventsMutation(c config, op Op, opts ...eventsOption) *EventsMutation {
	m := &EventsMutation{
		config:        c,
		op:            op,
		typ:           TypeEvents,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventsID sets the ID field of the mutation.
func withEventsID(id uuid.UUID) eventsOption {
	return func(m *EventsMutation) {
		var (
			err   error
			once  sync.Once
			value *Events
		)
		m.oldValue = func(ctx context.Context) (*Events, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Events.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEvents sets the old Events of the mutation.
func withEvents(node *Events) eventsOption {
	return func(m *EventsMutation) {
		m.oldValue = func(context.Context) (*Events, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Events entities.
func (m *EventsMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventsMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventsMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Events.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEvents sets the "events" field.
func (m *EventsMutation) SetEvents(value []map[string]interface{}) {
	m.events = &value
	m.appendevents = nil
}

// Events returns the value of the "events" field in the mutation.
func (m *EventsMutation) Events() (r []map[string]interface{}, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldEvents(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// AppendEvents adds value to the "events" field.
func (m *EventsMutation) AppendEvents(value []map[string]interface{}) {
	m.appendevents = append(m.appendevents, value...)
}

// AppendedEvents returns the list of values that were appended to the "events" field in this mutation.
func (m *EventsMutation) AppendedEvents() ([]map[string]interface{}, bool) {
	if len(m.appendevents) == 0 {
		return nil, false
	}
	return m.appendevents, true
}

// ResetEvents resets all changes to the "events" field.
func (m *EventsMutation) ResetEvents() {
	m.events = nil
	m.appendevents = nil
}

// SetCorrelations sets the "correlations" field.
func (m *EventsMutation) SetCorrelations(s []string) {
	m.correlations = &s
	m.appendcorrelations = nil
}

// Correlations returns the value of the "correlations" field in the mutation.
func (m *EventsMutation) Correlations() (r []string, exists bool) {
	v := m.correlations
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelations returns the old "correlations" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldCorrelations(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCorrelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCorrelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelations: %w", err)
	}
	return oldValue.Correlations, nil
}

// AppendCorrelations adds s to the "correlations" field.
func (m *EventsMutation) AppendCorrelations(s []string) {
	m.appendcorrelations = append(m.appendcorrelations, s...)
}

// AppendedCorrelations returns the list of values that were appended to the "correlations" field in this mutation.
func (m *EventsMutation) AppendedCorrelations() ([]string, bool) {
	if len(m.appendcorrelations) == 0 {
		return nil, false
	}
	return m.appendcorrelations, true
}

// ResetCorrelations resets all changes to the "correlations" field.
func (m *EventsMutation) ResetCorrelations() {
	m.correlations = nil
	m.appendcorrelations = nil
}

// SetSignature sets the "signature" field.
func (m *EventsMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *EventsMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *EventsMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[events.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *EventsMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[events.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *EventsMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, events.FieldSignature)
}

// SetCount sets the "count" field.
func (m *EventsMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *EventsMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *EventsMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *EventsMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *EventsMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EventsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EventsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EventsMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EventsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EventsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EventsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetWorkflowID sets the "workflow_id" field.
func (m *EventsMutation) SetWorkflowID(u uuid.UUID) {
	m.workflow_id = &u
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *EventsMutation) WorkflowID() (r uuid.UUID, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the Events entity.
// If the Events object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsMutation) OldWorkflowID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ClearWorkflowID clears the value of the "workflow_id" field.
func (m *EventsMutation) ClearWorkflowID() {
	m.workflow_id = nil
	m.clearedFields[events.FieldWorkflowID] = struct{}{}
}

// WorkflowIDCleared returns if the "workflow_id" field was cleared in this mutation.
func (m *EventsMutation) WorkflowIDCleared() bool {
	_, ok := m.clearedFields[events.FieldWorkflowID]
	return ok
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *EventsMutation) ResetWorkflowID() {
	m.workflow_id = nil
	delete(m.clearedFields, events.FieldWorkflowID)
}

// AddWfeventswaitIDs adds the "wfeventswait" edge to the EventsWait entity by ids.
func (m *EventsMutation) AddWfeventswaitIDs(ids ...uuid.UUID) {
	if m.wfeventswait == nil {
		m.wfeventswait = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.wfeventswait[ids[i]] = struct{}{}
	}
}

// ClearWfeventswait clears the "wfeventswait" edge to the EventsWait entity.
func (m *EventsMutation) ClearWfeventswait() {
	m.clearedwfeventswait = true
}

// WfeventswaitCleared reports if the "wfeventswait" edge to the EventsWait entity was cleared.
func (m *EventsMutation) WfeventswaitCleared() bool {
	return m.clearedwfeventswait
}

// RemoveWfeventswaitIDs removes the "wfeventswait" edge to the EventsWait entity by IDs.
func (m *EventsMutation) RemoveWfeventswaitIDs(ids ...uuid.UUID) {
	if m.removedwfeventswait == nil {
		m.removedwfeventswait = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.wfeventswait, ids[i])
		m.removedwfeventswait[ids[i]] = struct{}{}
	}
}

// RemovedWfeventswait returns the removed IDs of the "wfeventswait" edge to the EventsWait entity.
func (m *EventsMutation) RemovedWfeventswaitIDs() (ids []uuid.UUID) {
	for id := range m.removedwfeventswait {
		ids = append(ids, id)
	}
	return
}

// WfeventswaitIDs returns the "wfeventswait" edge IDs in the mutation.
func (m *EventsMutation) WfeventswaitIDs() (ids []uuid.UUID) {
	for id := range m.wfeventswait {
		ids = append(ids, id)
	}
	return
}

// ResetWfeventswait resets all changes to the "wfeventswait" edge.
func (m *EventsMutation) ResetWfeventswait() {
	m.wfeventswait = nil
	m.clearedwfeventswait = false
	m.removedwfeventswait = nil
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *EventsMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *EventsMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *EventsMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *EventsMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *EventsMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *EventsMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *EventsMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *EventsMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *EventsMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *EventsMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *EventsMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *EventsMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the EventsMutation builder.
func (m *EventsMutation) Where(ps ...predicate.Events) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Events, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Events).
func (m *EventsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventsMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.events != nil {
		fields = append(fields, events.FieldEvents)
	}
	if m.correlations != nil {
		fields = append(fields, events.FieldCorrelations)
	}
	if m.signature != nil {
		fields = append(fields, events.FieldSignature)
	}
	if m.count != nil {
		fields = append(fields, events.FieldCount)
	}
	if m.created_at != nil {
		fields = append(fields, events.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, events.FieldUpdatedAt)
	}
	if m.workflow_id != nil {
		fields = append(fields, events.FieldWorkflowID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case events.FieldEvents:
		return m.Events()
	case events.FieldCorrelations:
		return m.Correlations()
	case events.FieldSignature:
		return m.Signature()
	case events.FieldCount:
		return m.Count()
	case events.FieldCreatedAt:
		return m.CreatedAt()
	case events.FieldUpdatedAt:
		return m.UpdatedAt()
	case events.FieldWorkflowID:
		return m.WorkflowID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case events.FieldEvents:
		return m.OldEvents(ctx)
	case events.FieldCorrelations:
		return m.OldCorrelations(ctx)
	case events.FieldSignature:
		return m.OldSignature(ctx)
	case events.FieldCount:
		return m.OldCount(ctx)
	case events.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case events.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case events.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	}
	return nil, fmt.Errorf("unknown Events field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case events.FieldEvents:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	case events.FieldCorrelations:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelations(v)
		return nil
	case events.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case events.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	case events.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case events.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case events.FieldWorkflowID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	}
	return fmt.Errorf("unknown Events field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventsMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, events.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case events.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case events.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown Events numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(events.FieldSignature) {
		fields = append(fields, events.FieldSignature)
	}
	if m.FieldCleared(events.FieldWorkflowID) {
		fields = append(fields, events.FieldWorkflowID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventsMutation) ClearField(name string) error {
	switch name {
	case events.FieldSignature:
		m.ClearSignature()
		return nil
	case events.FieldWorkflowID:
		m.ClearWorkflowID()
		return nil
	}
	return fmt.Errorf("unknown Events nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventsMutation) ResetField(name string) error {
	switch name {
	case events.FieldEvents:
		m.ResetEvents()
		return nil
	case events.FieldCorrelations:
		m.ResetCorrelations()
		return nil
	case events.FieldSignature:
		m.ResetSignature()
		return nil
	case events.FieldCount:
		m.ResetCount()
		return nil
	case events.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case events.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case events.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	}
	return fmt.Errorf("unknown Events field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.wfeventswait != nil {
		edges = append(edges, events.EdgeWfeventswait)
	}
	if m.instance != nil {
		edges = append(edges, events.EdgeInstance)
	}
	if m.namespace != nil {
		edges = append(edges, events.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case events.EdgeWfeventswait:
		ids := make([]ent.Value, 0, len(m.wfeventswait))
		for id := range m.wfeventswait {
			ids = append(ids, id)
		}
		return ids
	case events.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	case events.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedwfeventswait != nil {
		edges = append(edges, events.EdgeWfeventswait)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case events.EdgeWfeventswait:
		ids := make([]ent.Value, 0, len(m.removedwfeventswait))
		for id := range m.removedwfeventswait {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedwfeventswait {
		edges = append(edges, events.EdgeWfeventswait)
	}
	if m.clearedinstance {
		edges = append(edges, events.EdgeInstance)
	}
	if m.clearednamespace {
		edges = append(edges, events.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventsMutation) EdgeCleared(name string) bool {
	switch name {
	case events.EdgeWfeventswait:
		return m.clearedwfeventswait
	case events.EdgeInstance:
		return m.clearedinstance
	case events.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventsMutation) ClearEdge(name string) error {
	switch name {
	case events.EdgeInstance:
		m.ClearInstance()
		return nil
	case events.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Events unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventsMutation) ResetEdge(name string) error {
	switch name {
	case events.EdgeWfeventswait:
		m.ResetWfeventswait()
		return nil
	case events.EdgeInstance:
		m.ResetInstance()
		return nil
	case events.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown Events edge %s", name)
}

// EventsWaitMutation represents an operation that mutates the EventsWait nodes in the graph.
type EventsWaitMutation struct {
	config
	op                   Op
	typ                  string
	id                   *uuid.UUID
	events               *map[string]interface{}
	clearedFields        map[string]struct{}
	workflowevent        *uuid.UUID
	clearedworkflowevent bool
	done                 bool
	oldValue             func(context.Context) (*EventsWait, error)
	predicates           []predicate.EventsWait
}

var _ ent.Mutation = (*EventsWaitMutation)(nil)

// eventswaitOption allows management of the mutation configuration using functional options.
type eventswaitOption func(*EventsWaitMutation)

// newEventsWaitMutation creates new mutation for the EventsWait entity.
func newEventsWaitMutation(c config, op Op, opts ...eventswaitOption) *EventsWaitMutation {
	m := &EventsWaitMutation{
		config:        c,
		op:            op,
		typ:           TypeEventsWait,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventsWaitID sets the ID field of the mutation.
func withEventsWaitID(id uuid.UUID) eventswaitOption {
	return func(m *EventsWaitMutation) {
		var (
			err   error
			once  sync.Once
			value *EventsWait
		)
		m.oldValue = func(ctx context.Context) (*EventsWait, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventsWait.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventsWait sets the old EventsWait of the mutation.
func withEventsWait(node *EventsWait) eventswaitOption {
	return func(m *EventsWaitMutation) {
		m.oldValue = func(context.Context) (*EventsWait, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventsWaitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventsWaitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EventsWait entities.
func (m *EventsWaitMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventsWaitMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventsWaitMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventsWait.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEvents sets the "events" field.
func (m *EventsWaitMutation) SetEvents(value map[string]interface{}) {
	m.events = &value
}

// Events returns the value of the "events" field in the mutation.
func (m *EventsWaitMutation) Events() (r map[string]interface{}, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the EventsWait entity.
// If the EventsWait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventsWaitMutation) OldEvents(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// ResetEvents resets all changes to the "events" field.
func (m *EventsWaitMutation) ResetEvents() {
	m.events = nil
}

// SetWorkfloweventID sets the "workflowevent" edge to the Events entity by id.
func (m *EventsWaitMutation) SetWorkfloweventID(id uuid.UUID) {
	m.workflowevent = &id
}

// ClearWorkflowevent clears the "workflowevent" edge to the Events entity.
func (m *EventsWaitMutation) ClearWorkflowevent() {
	m.clearedworkflowevent = true
}

// WorkfloweventCleared reports if the "workflowevent" edge to the Events entity was cleared.
func (m *EventsWaitMutation) WorkfloweventCleared() bool {
	return m.clearedworkflowevent
}

// WorkfloweventID returns the "workflowevent" edge ID in the mutation.
func (m *EventsWaitMutation) WorkfloweventID() (id uuid.UUID, exists bool) {
	if m.workflowevent != nil {
		return *m.workflowevent, true
	}
	return
}

// WorkfloweventIDs returns the "workflowevent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkfloweventID instead. It exists only for internal usage by the builders.
func (m *EventsWaitMutation) WorkfloweventIDs() (ids []uuid.UUID) {
	if id := m.workflowevent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowevent resets all changes to the "workflowevent" edge.
func (m *EventsWaitMutation) ResetWorkflowevent() {
	m.workflowevent = nil
	m.clearedworkflowevent = false
}

// Where appends a list predicates to the EventsWaitMutation builder.
func (m *EventsWaitMutation) Where(ps ...predicate.EventsWait) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EventsWaitMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EventsWaitMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EventsWait, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EventsWaitMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EventsWaitMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EventsWait).
func (m *EventsWaitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventsWaitMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.events != nil {
		fields = append(fields, eventswait.FieldEvents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventsWaitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventswait.FieldEvents:
		return m.Events()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventsWaitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventswait.FieldEvents:
		return m.OldEvents(ctx)
	}
	return nil, fmt.Errorf("unknown EventsWait field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsWaitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventswait.FieldEvents:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	}
	return fmt.Errorf("unknown EventsWait field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventsWaitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventsWaitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventsWaitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventsWait numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventsWaitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventsWaitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventsWaitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventsWait nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventsWaitMutation) ResetField(name string) error {
	switch name {
	case eventswait.FieldEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown EventsWait field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventsWaitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflowevent != nil {
		edges = append(edges, eventswait.EdgeWorkflowevent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventsWaitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventswait.EdgeWorkflowevent:
		if id := m.workflowevent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventsWaitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventsWaitMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventsWaitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflowevent {
		edges = append(edges, eventswait.EdgeWorkflowevent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventsWaitMutation) EdgeCleared(name string) bool {
	switch name {
	case eventswait.EdgeWorkflowevent:
		return m.clearedworkflowevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventsWaitMutation) ClearEdge(name string) error {
	switch name {
	case eventswait.EdgeWorkflowevent:
		m.ClearWorkflowevent()
		return nil
	}
	return fmt.Errorf("unknown EventsWait unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventsWaitMutation) ResetEdge(name string) error {
	switch name {
	case eventswait.EdgeWorkflowevent:
		m.ResetWorkflowevent()
		return nil
	}
	return fmt.Errorf("unknown EventsWait edge %s", name)
}

// InstanceMutation represents an operation that mutates the Instance nodes in the graph.
type InstanceMutation struct {
	config
	op                    Op
	typ                   string
	id                    *uuid.UUID
	created_at            *time.Time
	updated_at            *time.Time
	end_at                *time.Time
	status                *string
	as                    *string
	errorCode             *string
	errorMessage          *string
	invoker               *string
	invokerState          *string
	callpath              *string
	workflow_id           *uuid.UUID
	revision_id           *uuid.UUID
	clearedFields         map[string]struct{}
	namespace             *uuid.UUID
	clearednamespace      bool
	logs                  map[uuid.UUID]struct{}
	removedlogs           map[uuid.UUID]struct{}
	clearedlogs           bool
	runtime               *uuid.UUID
	clearedruntime        bool
	children              map[uuid.UUID]struct{}
	removedchildren       map[uuid.UUID]struct{}
	clearedchildren       bool
	eventlisteners        map[uuid.UUID]struct{}
	removedeventlisteners map[uuid.UUID]struct{}
	clearedeventlisteners bool
	annotations           map[uuid.UUID]struct{}
	removedannotations    map[uuid.UUID]struct{}
	clearedannotations    bool
	done                  bool
	oldValue              func(context.Context) (*Instance, error)
	predicates            []predicate.Instance
}

var _ ent.Mutation = (*InstanceMutation)(nil)

// instanceOption allows management of the mutation configuration using functional options.
type instanceOption func(*InstanceMutation)

// newInstanceMutation creates new mutation for the Instance entity.
func newInstanceMutation(c config, op Op, opts ...instanceOption) *InstanceMutation {
	m := &InstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceID sets the ID field of the mutation.
func withInstanceID(id uuid.UUID) instanceOption {
	return func(m *InstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *Instance
		)
		m.oldValue = func(ctx context.Context) (*Instance, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Instance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstance sets the old Instance of the mutation.
func withInstance(node *Instance) instanceOption {
	return func(m *InstanceMutation) {
		m.oldValue = func(context.Context) (*Instance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Instance entities.
func (m *InstanceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Instance.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *InstanceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *InstanceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *InstanceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *InstanceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *InstanceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *InstanceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *InstanceMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *InstanceMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ClearEndAt clears the value of the "end_at" field.
func (m *InstanceMutation) ClearEndAt() {
	m.end_at = nil
	m.clearedFields[instance.FieldEndAt] = struct{}{}
}

// EndAtCleared returns if the "end_at" field was cleared in this mutation.
func (m *InstanceMutation) EndAtCleared() bool {
	_, ok := m.clearedFields[instance.FieldEndAt]
	return ok
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *InstanceMutation) ResetEndAt() {
	m.end_at = nil
	delete(m.clearedFields, instance.FieldEndAt)
}

// SetStatus sets the "status" field.
func (m *InstanceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *InstanceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *InstanceMutation) ResetStatus() {
	m.status = nil
}

// SetAs sets the "as" field.
func (m *InstanceMutation) SetAs(s string) {
	m.as = &s
}

// As returns the value of the "as" field in the mutation.
func (m *InstanceMutation) As() (r string, exists bool) {
	v := m.as
	if v == nil {
		return
	}
	return *v, true
}

// OldAs returns the old "as" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldAs(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAs: %w", err)
	}
	return oldValue.As, nil
}

// ResetAs resets all changes to the "as" field.
func (m *InstanceMutation) ResetAs() {
	m.as = nil
}

// SetErrorCode sets the "errorCode" field.
func (m *InstanceMutation) SetErrorCode(s string) {
	m.errorCode = &s
}

// ErrorCode returns the value of the "errorCode" field in the mutation.
func (m *InstanceMutation) ErrorCode() (r string, exists bool) {
	v := m.errorCode
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "errorCode" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// ClearErrorCode clears the value of the "errorCode" field.
func (m *InstanceMutation) ClearErrorCode() {
	m.errorCode = nil
	m.clearedFields[instance.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "errorCode" field was cleared in this mutation.
func (m *InstanceMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[instance.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "errorCode" field.
func (m *InstanceMutation) ResetErrorCode() {
	m.errorCode = nil
	delete(m.clearedFields, instance.FieldErrorCode)
}

// SetErrorMessage sets the "errorMessage" field.
func (m *InstanceMutation) SetErrorMessage(s string) {
	m.errorMessage = &s
}

// ErrorMessage returns the value of the "errorMessage" field in the mutation.
func (m *InstanceMutation) ErrorMessage() (r string, exists bool) {
	v := m.errorMessage
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "errorMessage" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "errorMessage" field.
func (m *InstanceMutation) ClearErrorMessage() {
	m.errorMessage = nil
	m.clearedFields[instance.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "errorMessage" field was cleared in this mutation.
func (m *InstanceMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[instance.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "errorMessage" field.
func (m *InstanceMutation) ResetErrorMessage() {
	m.errorMessage = nil
	delete(m.clearedFields, instance.FieldErrorMessage)
}

// SetInvoker sets the "invoker" field.
func (m *InstanceMutation) SetInvoker(s string) {
	m.invoker = &s
}

// Invoker returns the value of the "invoker" field in the mutation.
func (m *InstanceMutation) Invoker() (r string, exists bool) {
	v := m.invoker
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoker returns the old "invoker" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldInvoker(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoker is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoker requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoker: %w", err)
	}
	return oldValue.Invoker, nil
}

// ClearInvoker clears the value of the "invoker" field.
func (m *InstanceMutation) ClearInvoker() {
	m.invoker = nil
	m.clearedFields[instance.FieldInvoker] = struct{}{}
}

// InvokerCleared returns if the "invoker" field was cleared in this mutation.
func (m *InstanceMutation) InvokerCleared() bool {
	_, ok := m.clearedFields[instance.FieldInvoker]
	return ok
}

// ResetInvoker resets all changes to the "invoker" field.
func (m *InstanceMutation) ResetInvoker() {
	m.invoker = nil
	delete(m.clearedFields, instance.FieldInvoker)
}

// SetInvokerState sets the "invokerState" field.
func (m *InstanceMutation) SetInvokerState(s string) {
	m.invokerState = &s
}

// InvokerState returns the value of the "invokerState" field in the mutation.
func (m *InstanceMutation) InvokerState() (r string, exists bool) {
	v := m.invokerState
	if v == nil {
		return
	}
	return *v, true
}

// OldInvokerState returns the old "invokerState" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldInvokerState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvokerState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvokerState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvokerState: %w", err)
	}
	return oldValue.InvokerState, nil
}

// ClearInvokerState clears the value of the "invokerState" field.
func (m *InstanceMutation) ClearInvokerState() {
	m.invokerState = nil
	m.clearedFields[instance.FieldInvokerState] = struct{}{}
}

// InvokerStateCleared returns if the "invokerState" field was cleared in this mutation.
func (m *InstanceMutation) InvokerStateCleared() bool {
	_, ok := m.clearedFields[instance.FieldInvokerState]
	return ok
}

// ResetInvokerState resets all changes to the "invokerState" field.
func (m *InstanceMutation) ResetInvokerState() {
	m.invokerState = nil
	delete(m.clearedFields, instance.FieldInvokerState)
}

// SetCallpath sets the "callpath" field.
func (m *InstanceMutation) SetCallpath(s string) {
	m.callpath = &s
}

// Callpath returns the value of the "callpath" field in the mutation.
func (m *InstanceMutation) Callpath() (r string, exists bool) {
	v := m.callpath
	if v == nil {
		return
	}
	return *v, true
}

// OldCallpath returns the old "callpath" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldCallpath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallpath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallpath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallpath: %w", err)
	}
	return oldValue.Callpath, nil
}

// ClearCallpath clears the value of the "callpath" field.
func (m *InstanceMutation) ClearCallpath() {
	m.callpath = nil
	m.clearedFields[instance.FieldCallpath] = struct{}{}
}

// CallpathCleared returns if the "callpath" field was cleared in this mutation.
func (m *InstanceMutation) CallpathCleared() bool {
	_, ok := m.clearedFields[instance.FieldCallpath]
	return ok
}

// ResetCallpath resets all changes to the "callpath" field.
func (m *InstanceMutation) ResetCallpath() {
	m.callpath = nil
	delete(m.clearedFields, instance.FieldCallpath)
}

// SetWorkflowID sets the "workflow_id" field.
func (m *InstanceMutation) SetWorkflowID(u uuid.UUID) {
	m.workflow_id = &u
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *InstanceMutation) WorkflowID() (r uuid.UUID, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldWorkflowID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *InstanceMutation) ResetWorkflowID() {
	m.workflow_id = nil
}

// SetRevisionID sets the "revision_id" field.
func (m *InstanceMutation) SetRevisionID(u uuid.UUID) {
	m.revision_id = &u
}

// RevisionID returns the value of the "revision_id" field in the mutation.
func (m *InstanceMutation) RevisionID() (r uuid.UUID, exists bool) {
	v := m.revision_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRevisionID returns the old "revision_id" field's value of the Instance entity.
// If the Instance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceMutation) OldRevisionID(ctx context.Context) (v *uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRevisionID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRevisionID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevisionID: %w", err)
	}
	return oldValue.RevisionID, nil
}

// ResetRevisionID resets all changes to the "revision_id" field.
func (m *InstanceMutation) ResetRevisionID() {
	m.revision_id = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *InstanceMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *InstanceMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *InstanceMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *InstanceMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *InstanceMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddLogIDs adds the "logs" edge to the LogMsg entity by ids.
func (m *InstanceMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the LogMsg entity.
func (m *InstanceMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the LogMsg entity was cleared.
func (m *InstanceMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the LogMsg entity by IDs.
func (m *InstanceMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the LogMsg entity.
func (m *InstanceMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *InstanceMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *InstanceMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// SetRuntimeID sets the "runtime" edge to the InstanceRuntime entity by id.
func (m *InstanceMutation) SetRuntimeID(id uuid.UUID) {
	m.runtime = &id
}

// ClearRuntime clears the "runtime" edge to the InstanceRuntime entity.
func (m *InstanceMutation) ClearRuntime() {
	m.clearedruntime = true
}

// RuntimeCleared reports if the "runtime" edge to the InstanceRuntime entity was cleared.
func (m *InstanceMutation) RuntimeCleared() bool {
	return m.clearedruntime
}

// RuntimeID returns the "runtime" edge ID in the mutation.
func (m *InstanceMutation) RuntimeID() (id uuid.UUID, exists bool) {
	if m.runtime != nil {
		return *m.runtime, true
	}
	return
}

// RuntimeIDs returns the "runtime" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RuntimeID instead. It exists only for internal usage by the builders.
func (m *InstanceMutation) RuntimeIDs() (ids []uuid.UUID) {
	if id := m.runtime; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRuntime resets all changes to the "runtime" edge.
func (m *InstanceMutation) ResetRuntime() {
	m.runtime = nil
	m.clearedruntime = false
}

// AddChildIDs adds the "children" edge to the InstanceRuntime entity by ids.
func (m *InstanceMutation) AddChildIDs(ids ...uuid.UUID) {
	if m.children == nil {
		m.children = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the InstanceRuntime entity.
func (m *InstanceMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the InstanceRuntime entity was cleared.
func (m *InstanceMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the InstanceRuntime entity by IDs.
func (m *InstanceMutation) RemoveChildIDs(ids ...uuid.UUID) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the InstanceRuntime entity.
func (m *InstanceMutation) RemovedChildrenIDs() (ids []uuid.UUID) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *InstanceMutation) ChildrenIDs() (ids []uuid.UUID) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *InstanceMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// AddEventlistenerIDs adds the "eventlisteners" edge to the Events entity by ids.
func (m *InstanceMutation) AddEventlistenerIDs(ids ...uuid.UUID) {
	if m.eventlisteners == nil {
		m.eventlisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.eventlisteners[ids[i]] = struct{}{}
	}
}

// ClearEventlisteners clears the "eventlisteners" edge to the Events entity.
func (m *InstanceMutation) ClearEventlisteners() {
	m.clearedeventlisteners = true
}

// EventlistenersCleared reports if the "eventlisteners" edge to the Events entity was cleared.
func (m *InstanceMutation) EventlistenersCleared() bool {
	return m.clearedeventlisteners
}

// RemoveEventlistenerIDs removes the "eventlisteners" edge to the Events entity by IDs.
func (m *InstanceMutation) RemoveEventlistenerIDs(ids ...uuid.UUID) {
	if m.removedeventlisteners == nil {
		m.removedeventlisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.eventlisteners, ids[i])
		m.removedeventlisteners[ids[i]] = struct{}{}
	}
}

// RemovedEventlisteners returns the removed IDs of the "eventlisteners" edge to the Events entity.
func (m *InstanceMutation) RemovedEventlistenersIDs() (ids []uuid.UUID) {
	for id := range m.removedeventlisteners {
		ids = append(ids, id)
	}
	return
}

// EventlistenersIDs returns the "eventlisteners" edge IDs in the mutation.
func (m *InstanceMutation) EventlistenersIDs() (ids []uuid.UUID) {
	for id := range m.eventlisteners {
		ids = append(ids, id)
	}
	return
}

// ResetEventlisteners resets all changes to the "eventlisteners" edge.
func (m *InstanceMutation) ResetEventlisteners() {
	m.eventlisteners = nil
	m.clearedeventlisteners = false
	m.removedeventlisteners = nil
}

// AddAnnotationIDs adds the "annotations" edge to the Annotation entity by ids.
func (m *InstanceMutation) AddAnnotationIDs(ids ...uuid.UUID) {
	if m.annotations == nil {
		m.annotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.annotations[ids[i]] = struct{}{}
	}
}

// ClearAnnotations clears the "annotations" edge to the Annotation entity.
func (m *InstanceMutation) ClearAnnotations() {
	m.clearedannotations = true
}

// AnnotationsCleared reports if the "annotations" edge to the Annotation entity was cleared.
func (m *InstanceMutation) AnnotationsCleared() bool {
	return m.clearedannotations
}

// RemoveAnnotationIDs removes the "annotations" edge to the Annotation entity by IDs.
func (m *InstanceMutation) RemoveAnnotationIDs(ids ...uuid.UUID) {
	if m.removedannotations == nil {
		m.removedannotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.annotations, ids[i])
		m.removedannotations[ids[i]] = struct{}{}
	}
}

// RemovedAnnotations returns the removed IDs of the "annotations" edge to the Annotation entity.
func (m *InstanceMutation) RemovedAnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.removedannotations {
		ids = append(ids, id)
	}
	return
}

// AnnotationsIDs returns the "annotations" edge IDs in the mutation.
func (m *InstanceMutation) AnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.annotations {
		ids = append(ids, id)
	}
	return
}

// ResetAnnotations resets all changes to the "annotations" edge.
func (m *InstanceMutation) ResetAnnotations() {
	m.annotations = nil
	m.clearedannotations = false
	m.removedannotations = nil
}

// Where appends a list predicates to the InstanceMutation builder.
func (m *InstanceMutation) Where(ps ...predicate.Instance) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstanceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstanceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Instance, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstanceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstanceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Instance).
func (m *InstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, instance.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, instance.FieldUpdatedAt)
	}
	if m.end_at != nil {
		fields = append(fields, instance.FieldEndAt)
	}
	if m.status != nil {
		fields = append(fields, instance.FieldStatus)
	}
	if m.as != nil {
		fields = append(fields, instance.FieldAs)
	}
	if m.errorCode != nil {
		fields = append(fields, instance.FieldErrorCode)
	}
	if m.errorMessage != nil {
		fields = append(fields, instance.FieldErrorMessage)
	}
	if m.invoker != nil {
		fields = append(fields, instance.FieldInvoker)
	}
	if m.invokerState != nil {
		fields = append(fields, instance.FieldInvokerState)
	}
	if m.callpath != nil {
		fields = append(fields, instance.FieldCallpath)
	}
	if m.workflow_id != nil {
		fields = append(fields, instance.FieldWorkflowID)
	}
	if m.revision_id != nil {
		fields = append(fields, instance.FieldRevisionID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instance.FieldCreatedAt:
		return m.CreatedAt()
	case instance.FieldUpdatedAt:
		return m.UpdatedAt()
	case instance.FieldEndAt:
		return m.EndAt()
	case instance.FieldStatus:
		return m.Status()
	case instance.FieldAs:
		return m.As()
	case instance.FieldErrorCode:
		return m.ErrorCode()
	case instance.FieldErrorMessage:
		return m.ErrorMessage()
	case instance.FieldInvoker:
		return m.Invoker()
	case instance.FieldInvokerState:
		return m.InvokerState()
	case instance.FieldCallpath:
		return m.Callpath()
	case instance.FieldWorkflowID:
		return m.WorkflowID()
	case instance.FieldRevisionID:
		return m.RevisionID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instance.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case instance.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case instance.FieldEndAt:
		return m.OldEndAt(ctx)
	case instance.FieldStatus:
		return m.OldStatus(ctx)
	case instance.FieldAs:
		return m.OldAs(ctx)
	case instance.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case instance.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case instance.FieldInvoker:
		return m.OldInvoker(ctx)
	case instance.FieldInvokerState:
		return m.OldInvokerState(ctx)
	case instance.FieldCallpath:
		return m.OldCallpath(ctx)
	case instance.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case instance.FieldRevisionID:
		return m.OldRevisionID(ctx)
	}
	return nil, fmt.Errorf("unknown Instance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instance.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case instance.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case instance.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case instance.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case instance.FieldAs:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAs(v)
		return nil
	case instance.FieldErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case instance.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case instance.FieldInvoker:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoker(v)
		return nil
	case instance.FieldInvokerState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvokerState(v)
		return nil
	case instance.FieldCallpath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallpath(v)
		return nil
	case instance.FieldWorkflowID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case instance.FieldRevisionID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevisionID(v)
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Instance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(instance.FieldEndAt) {
		fields = append(fields, instance.FieldEndAt)
	}
	if m.FieldCleared(instance.FieldErrorCode) {
		fields = append(fields, instance.FieldErrorCode)
	}
	if m.FieldCleared(instance.FieldErrorMessage) {
		fields = append(fields, instance.FieldErrorMessage)
	}
	if m.FieldCleared(instance.FieldInvoker) {
		fields = append(fields, instance.FieldInvoker)
	}
	if m.FieldCleared(instance.FieldInvokerState) {
		fields = append(fields, instance.FieldInvokerState)
	}
	if m.FieldCleared(instance.FieldCallpath) {
		fields = append(fields, instance.FieldCallpath)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceMutation) ClearField(name string) error {
	switch name {
	case instance.FieldEndAt:
		m.ClearEndAt()
		return nil
	case instance.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case instance.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case instance.FieldInvoker:
		m.ClearInvoker()
		return nil
	case instance.FieldInvokerState:
		m.ClearInvokerState()
		return nil
	case instance.FieldCallpath:
		m.ClearCallpath()
		return nil
	}
	return fmt.Errorf("unknown Instance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceMutation) ResetField(name string) error {
	switch name {
	case instance.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case instance.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case instance.FieldEndAt:
		m.ResetEndAt()
		return nil
	case instance.FieldStatus:
		m.ResetStatus()
		return nil
	case instance.FieldAs:
		m.ResetAs()
		return nil
	case instance.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case instance.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case instance.FieldInvoker:
		m.ResetInvoker()
		return nil
	case instance.FieldInvokerState:
		m.ResetInvokerState()
		return nil
	case instance.FieldCallpath:
		m.ResetCallpath()
		return nil
	case instance.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case instance.FieldRevisionID:
		m.ResetRevisionID()
		return nil
	}
	return fmt.Errorf("unknown Instance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.namespace != nil {
		edges = append(edges, instance.EdgeNamespace)
	}
	if m.logs != nil {
		edges = append(edges, instance.EdgeLogs)
	}
	if m.runtime != nil {
		edges = append(edges, instance.EdgeRuntime)
	}
	if m.children != nil {
		edges = append(edges, instance.EdgeChildren)
	}
	if m.eventlisteners != nil {
		edges = append(edges, instance.EdgeEventlisteners)
	}
	if m.annotations != nil {
		edges = append(edges, instance.EdgeAnnotations)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeRuntime:
		if id := m.runtime; id != nil {
			return []ent.Value{*id}
		}
	case instance.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeEventlisteners:
		ids := make([]ent.Value, 0, len(m.eventlisteners))
		for id := range m.eventlisteners {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.annotations))
		for id := range m.annotations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedlogs != nil {
		edges = append(edges, instance.EdgeLogs)
	}
	if m.removedchildren != nil {
		edges = append(edges, instance.EdgeChildren)
	}
	if m.removedeventlisteners != nil {
		edges = append(edges, instance.EdgeEventlisteners)
	}
	if m.removedannotations != nil {
		edges = append(edges, instance.EdgeAnnotations)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case instance.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeEventlisteners:
		ids := make([]ent.Value, 0, len(m.removedeventlisteners))
		for id := range m.removedeventlisteners {
			ids = append(ids, id)
		}
		return ids
	case instance.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.removedannotations))
		for id := range m.removedannotations {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearednamespace {
		edges = append(edges, instance.EdgeNamespace)
	}
	if m.clearedlogs {
		edges = append(edges, instance.EdgeLogs)
	}
	if m.clearedruntime {
		edges = append(edges, instance.EdgeRuntime)
	}
	if m.clearedchildren {
		edges = append(edges, instance.EdgeChildren)
	}
	if m.clearedeventlisteners {
		edges = append(edges, instance.EdgeEventlisteners)
	}
	if m.clearedannotations {
		edges = append(edges, instance.EdgeAnnotations)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case instance.EdgeNamespace:
		return m.clearednamespace
	case instance.EdgeLogs:
		return m.clearedlogs
	case instance.EdgeRuntime:
		return m.clearedruntime
	case instance.EdgeChildren:
		return m.clearedchildren
	case instance.EdgeEventlisteners:
		return m.clearedeventlisteners
	case instance.EdgeAnnotations:
		return m.clearedannotations
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceMutation) ClearEdge(name string) error {
	switch name {
	case instance.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case instance.EdgeRuntime:
		m.ClearRuntime()
		return nil
	}
	return fmt.Errorf("unknown Instance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceMutation) ResetEdge(name string) error {
	switch name {
	case instance.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case instance.EdgeLogs:
		m.ResetLogs()
		return nil
	case instance.EdgeRuntime:
		m.ResetRuntime()
		return nil
	case instance.EdgeChildren:
		m.ResetChildren()
		return nil
	case instance.EdgeEventlisteners:
		m.ResetEventlisteners()
		return nil
	case instance.EdgeAnnotations:
		m.ResetAnnotations()
		return nil
	}
	return fmt.Errorf("unknown Instance edge %s", name)
}

// InstanceRuntimeMutation represents an operation that mutates the InstanceRuntime nodes in the graph.
type InstanceRuntimeMutation struct {
	config
	op              Op
	typ             string
	id              *uuid.UUID
	input           *[]byte
	data            *string
	controller      *string
	memory          *string
	flow            *[]string
	appendflow      []string
	output          *string
	stateBeginTime  *time.Time
	deadline        *time.Time
	attempts        *int
	addattempts     *int
	caller_data     *string
	instanceContext *string
	stateContext    *string
	metadata        *string
	logToEvents     *string
	clearedFields   map[string]struct{}
	instance        *uuid.UUID
	clearedinstance bool
	caller          *uuid.UUID
	clearedcaller   bool
	done            bool
	oldValue        func(context.Context) (*InstanceRuntime, error)
	predicates      []predicate.InstanceRuntime
}

var _ ent.Mutation = (*InstanceRuntimeMutation)(nil)

// instanceruntimeOption allows management of the mutation configuration using functional options.
type instanceruntimeOption func(*InstanceRuntimeMutation)

// newInstanceRuntimeMutation creates new mutation for the InstanceRuntime entity.
func newInstanceRuntimeMutation(c config, op Op, opts ...instanceruntimeOption) *InstanceRuntimeMutation {
	m := &InstanceRuntimeMutation{
		config:        c,
		op:            op,
		typ:           TypeInstanceRuntime,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInstanceRuntimeID sets the ID field of the mutation.
func withInstanceRuntimeID(id uuid.UUID) instanceruntimeOption {
	return func(m *InstanceRuntimeMutation) {
		var (
			err   error
			once  sync.Once
			value *InstanceRuntime
		)
		m.oldValue = func(ctx context.Context) (*InstanceRuntime, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InstanceRuntime.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInstanceRuntime sets the old InstanceRuntime of the mutation.
func withInstanceRuntime(node *InstanceRuntime) instanceruntimeOption {
	return func(m *InstanceRuntimeMutation) {
		m.oldValue = func(context.Context) (*InstanceRuntime, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InstanceRuntimeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InstanceRuntimeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InstanceRuntime entities.
func (m *InstanceRuntimeMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InstanceRuntimeMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InstanceRuntimeMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InstanceRuntime.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetInput sets the "input" field.
func (m *InstanceRuntimeMutation) SetInput(b []byte) {
	m.input = &b
}

// Input returns the value of the "input" field in the mutation.
func (m *InstanceRuntimeMutation) Input() (r []byte, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldInput(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *InstanceRuntimeMutation) ResetInput() {
	m.input = nil
}

// SetData sets the "data" field.
func (m *InstanceRuntimeMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *InstanceRuntimeMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *InstanceRuntimeMutation) ResetData() {
	m.data = nil
}

// SetController sets the "controller" field.
func (m *InstanceRuntimeMutation) SetController(s string) {
	m.controller = &s
}

// Controller returns the value of the "controller" field in the mutation.
func (m *InstanceRuntimeMutation) Controller() (r string, exists bool) {
	v := m.controller
	if v == nil {
		return
	}
	return *v, true
}

// OldController returns the old "controller" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldController(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldController: %w", err)
	}
	return oldValue.Controller, nil
}

// ClearController clears the value of the "controller" field.
func (m *InstanceRuntimeMutation) ClearController() {
	m.controller = nil
	m.clearedFields[instanceruntime.FieldController] = struct{}{}
}

// ControllerCleared returns if the "controller" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) ControllerCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldController]
	return ok
}

// ResetController resets all changes to the "controller" field.
func (m *InstanceRuntimeMutation) ResetController() {
	m.controller = nil
	delete(m.clearedFields, instanceruntime.FieldController)
}

// SetMemory sets the "memory" field.
func (m *InstanceRuntimeMutation) SetMemory(s string) {
	m.memory = &s
}

// Memory returns the value of the "memory" field in the mutation.
func (m *InstanceRuntimeMutation) Memory() (r string, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldMemory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// ClearMemory clears the value of the "memory" field.
func (m *InstanceRuntimeMutation) ClearMemory() {
	m.memory = nil
	m.clearedFields[instanceruntime.FieldMemory] = struct{}{}
}

// MemoryCleared returns if the "memory" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) MemoryCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldMemory]
	return ok
}

// ResetMemory resets all changes to the "memory" field.
func (m *InstanceRuntimeMutation) ResetMemory() {
	m.memory = nil
	delete(m.clearedFields, instanceruntime.FieldMemory)
}

// SetFlow sets the "flow" field.
func (m *InstanceRuntimeMutation) SetFlow(s []string) {
	m.flow = &s
	m.appendflow = nil
}

// Flow returns the value of the "flow" field in the mutation.
func (m *InstanceRuntimeMutation) Flow() (r []string, exists bool) {
	v := m.flow
	if v == nil {
		return
	}
	return *v, true
}

// OldFlow returns the old "flow" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldFlow(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlow: %w", err)
	}
	return oldValue.Flow, nil
}

// AppendFlow adds s to the "flow" field.
func (m *InstanceRuntimeMutation) AppendFlow(s []string) {
	m.appendflow = append(m.appendflow, s...)
}

// AppendedFlow returns the list of values that were appended to the "flow" field in this mutation.
func (m *InstanceRuntimeMutation) AppendedFlow() ([]string, bool) {
	if len(m.appendflow) == 0 {
		return nil, false
	}
	return m.appendflow, true
}

// ClearFlow clears the value of the "flow" field.
func (m *InstanceRuntimeMutation) ClearFlow() {
	m.flow = nil
	m.appendflow = nil
	m.clearedFields[instanceruntime.FieldFlow] = struct{}{}
}

// FlowCleared returns if the "flow" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) FlowCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldFlow]
	return ok
}

// ResetFlow resets all changes to the "flow" field.
func (m *InstanceRuntimeMutation) ResetFlow() {
	m.flow = nil
	m.appendflow = nil
	delete(m.clearedFields, instanceruntime.FieldFlow)
}

// SetOutput sets the "output" field.
func (m *InstanceRuntimeMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *InstanceRuntimeMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *InstanceRuntimeMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[instanceruntime.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) OutputCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *InstanceRuntimeMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, instanceruntime.FieldOutput)
}

// SetStateBeginTime sets the "stateBeginTime" field.
func (m *InstanceRuntimeMutation) SetStateBeginTime(t time.Time) {
	m.stateBeginTime = &t
}

// StateBeginTime returns the value of the "stateBeginTime" field in the mutation.
func (m *InstanceRuntimeMutation) StateBeginTime() (r time.Time, exists bool) {
	v := m.stateBeginTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStateBeginTime returns the old "stateBeginTime" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldStateBeginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateBeginTime: %w", err)
	}
	return oldValue.StateBeginTime, nil
}

// ClearStateBeginTime clears the value of the "stateBeginTime" field.
func (m *InstanceRuntimeMutation) ClearStateBeginTime() {
	m.stateBeginTime = nil
	m.clearedFields[instanceruntime.FieldStateBeginTime] = struct{}{}
}

// StateBeginTimeCleared returns if the "stateBeginTime" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) StateBeginTimeCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldStateBeginTime]
	return ok
}

// ResetStateBeginTime resets all changes to the "stateBeginTime" field.
func (m *InstanceRuntimeMutation) ResetStateBeginTime() {
	m.stateBeginTime = nil
	delete(m.clearedFields, instanceruntime.FieldStateBeginTime)
}

// SetDeadline sets the "deadline" field.
func (m *InstanceRuntimeMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *InstanceRuntimeMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ClearDeadline clears the value of the "deadline" field.
func (m *InstanceRuntimeMutation) ClearDeadline() {
	m.deadline = nil
	m.clearedFields[instanceruntime.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *InstanceRuntimeMutation) ResetDeadline() {
	m.deadline = nil
	delete(m.clearedFields, instanceruntime.FieldDeadline)
}

// SetAttempts sets the "attempts" field.
func (m *InstanceRuntimeMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *InstanceRuntimeMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *InstanceRuntimeMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *InstanceRuntimeMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ClearAttempts clears the value of the "attempts" field.
func (m *InstanceRuntimeMutation) ClearAttempts() {
	m.attempts = nil
	m.addattempts = nil
	m.clearedFields[instanceruntime.FieldAttempts] = struct{}{}
}

// AttemptsCleared returns if the "attempts" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) AttemptsCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldAttempts]
	return ok
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *InstanceRuntimeMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
	delete(m.clearedFields, instanceruntime.FieldAttempts)
}

// SetCallerData sets the "caller_data" field.
func (m *InstanceRuntimeMutation) SetCallerData(s string) {
	m.caller_data = &s
}

// CallerData returns the value of the "caller_data" field in the mutation.
func (m *InstanceRuntimeMutation) CallerData() (r string, exists bool) {
	v := m.caller_data
	if v == nil {
		return
	}
	return *v, true
}

// OldCallerData returns the old "caller_data" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldCallerData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCallerData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCallerData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCallerData: %w", err)
	}
	return oldValue.CallerData, nil
}

// ClearCallerData clears the value of the "caller_data" field.
func (m *InstanceRuntimeMutation) ClearCallerData() {
	m.caller_data = nil
	m.clearedFields[instanceruntime.FieldCallerData] = struct{}{}
}

// CallerDataCleared returns if the "caller_data" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) CallerDataCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldCallerData]
	return ok
}

// ResetCallerData resets all changes to the "caller_data" field.
func (m *InstanceRuntimeMutation) ResetCallerData() {
	m.caller_data = nil
	delete(m.clearedFields, instanceruntime.FieldCallerData)
}

// SetInstanceContext sets the "instanceContext" field.
func (m *InstanceRuntimeMutation) SetInstanceContext(s string) {
	m.instanceContext = &s
}

// InstanceContext returns the value of the "instanceContext" field in the mutation.
func (m *InstanceRuntimeMutation) InstanceContext() (r string, exists bool) {
	v := m.instanceContext
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceContext returns the old "instanceContext" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldInstanceContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInstanceContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInstanceContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceContext: %w", err)
	}
	return oldValue.InstanceContext, nil
}

// ClearInstanceContext clears the value of the "instanceContext" field.
func (m *InstanceRuntimeMutation) ClearInstanceContext() {
	m.instanceContext = nil
	m.clearedFields[instanceruntime.FieldInstanceContext] = struct{}{}
}

// InstanceContextCleared returns if the "instanceContext" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) InstanceContextCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldInstanceContext]
	return ok
}

// ResetInstanceContext resets all changes to the "instanceContext" field.
func (m *InstanceRuntimeMutation) ResetInstanceContext() {
	m.instanceContext = nil
	delete(m.clearedFields, instanceruntime.FieldInstanceContext)
}

// SetStateContext sets the "stateContext" field.
func (m *InstanceRuntimeMutation) SetStateContext(s string) {
	m.stateContext = &s
}

// StateContext returns the value of the "stateContext" field in the mutation.
func (m *InstanceRuntimeMutation) StateContext() (r string, exists bool) {
	v := m.stateContext
	if v == nil {
		return
	}
	return *v, true
}

// OldStateContext returns the old "stateContext" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldStateContext(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStateContext is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStateContext requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateContext: %w", err)
	}
	return oldValue.StateContext, nil
}

// ClearStateContext clears the value of the "stateContext" field.
func (m *InstanceRuntimeMutation) ClearStateContext() {
	m.stateContext = nil
	m.clearedFields[instanceruntime.FieldStateContext] = struct{}{}
}

// StateContextCleared returns if the "stateContext" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) StateContextCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldStateContext]
	return ok
}

// ResetStateContext resets all changes to the "stateContext" field.
func (m *InstanceRuntimeMutation) ResetStateContext() {
	m.stateContext = nil
	delete(m.clearedFields, instanceruntime.FieldStateContext)
}

// SetMetadata sets the "metadata" field.
func (m *InstanceRuntimeMutation) SetMetadata(s string) {
	m.metadata = &s
}

// Metadata returns the value of the "metadata" field in the mutation.
func (m *InstanceRuntimeMutation) Metadata() (r string, exists bool) {
	v := m.metadata
	if v == nil {
		return
	}
	return *v, true
}

// OldMetadata returns the old "metadata" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldMetadata(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetadata is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetadata requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetadata: %w", err)
	}
	return oldValue.Metadata, nil
}

// ClearMetadata clears the value of the "metadata" field.
func (m *InstanceRuntimeMutation) ClearMetadata() {
	m.metadata = nil
	m.clearedFields[instanceruntime.FieldMetadata] = struct{}{}
}

// MetadataCleared returns if the "metadata" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) MetadataCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldMetadata]
	return ok
}

// ResetMetadata resets all changes to the "metadata" field.
func (m *InstanceRuntimeMutation) ResetMetadata() {
	m.metadata = nil
	delete(m.clearedFields, instanceruntime.FieldMetadata)
}

// SetLogToEvents sets the "logToEvents" field.
func (m *InstanceRuntimeMutation) SetLogToEvents(s string) {
	m.logToEvents = &s
}

// LogToEvents returns the value of the "logToEvents" field in the mutation.
func (m *InstanceRuntimeMutation) LogToEvents() (r string, exists bool) {
	v := m.logToEvents
	if v == nil {
		return
	}
	return *v, true
}

// OldLogToEvents returns the old "logToEvents" field's value of the InstanceRuntime entity.
// If the InstanceRuntime object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InstanceRuntimeMutation) OldLogToEvents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogToEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogToEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogToEvents: %w", err)
	}
	return oldValue.LogToEvents, nil
}

// ClearLogToEvents clears the value of the "logToEvents" field.
func (m *InstanceRuntimeMutation) ClearLogToEvents() {
	m.logToEvents = nil
	m.clearedFields[instanceruntime.FieldLogToEvents] = struct{}{}
}

// LogToEventsCleared returns if the "logToEvents" field was cleared in this mutation.
func (m *InstanceRuntimeMutation) LogToEventsCleared() bool {
	_, ok := m.clearedFields[instanceruntime.FieldLogToEvents]
	return ok
}

// ResetLogToEvents resets all changes to the "logToEvents" field.
func (m *InstanceRuntimeMutation) ResetLogToEvents() {
	m.logToEvents = nil
	delete(m.clearedFields, instanceruntime.FieldLogToEvents)
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *InstanceRuntimeMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *InstanceRuntimeMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *InstanceRuntimeMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *InstanceRuntimeMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *InstanceRuntimeMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *InstanceRuntimeMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// SetCallerID sets the "caller" edge to the Instance entity by id.
func (m *InstanceRuntimeMutation) SetCallerID(id uuid.UUID) {
	m.caller = &id
}

// ClearCaller clears the "caller" edge to the Instance entity.
func (m *InstanceRuntimeMutation) ClearCaller() {
	m.clearedcaller = true
}

// CallerCleared reports if the "caller" edge to the Instance entity was cleared.
func (m *InstanceRuntimeMutation) CallerCleared() bool {
	return m.clearedcaller
}

// CallerID returns the "caller" edge ID in the mutation.
func (m *InstanceRuntimeMutation) CallerID() (id uuid.UUID, exists bool) {
	if m.caller != nil {
		return *m.caller, true
	}
	return
}

// CallerIDs returns the "caller" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CallerID instead. It exists only for internal usage by the builders.
func (m *InstanceRuntimeMutation) CallerIDs() (ids []uuid.UUID) {
	if id := m.caller; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCaller resets all changes to the "caller" edge.
func (m *InstanceRuntimeMutation) ResetCaller() {
	m.caller = nil
	m.clearedcaller = false
}

// Where appends a list predicates to the InstanceRuntimeMutation builder.
func (m *InstanceRuntimeMutation) Where(ps ...predicate.InstanceRuntime) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InstanceRuntimeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InstanceRuntimeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InstanceRuntime, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InstanceRuntimeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InstanceRuntimeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InstanceRuntime).
func (m *InstanceRuntimeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InstanceRuntimeMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.input != nil {
		fields = append(fields, instanceruntime.FieldInput)
	}
	if m.data != nil {
		fields = append(fields, instanceruntime.FieldData)
	}
	if m.controller != nil {
		fields = append(fields, instanceruntime.FieldController)
	}
	if m.memory != nil {
		fields = append(fields, instanceruntime.FieldMemory)
	}
	if m.flow != nil {
		fields = append(fields, instanceruntime.FieldFlow)
	}
	if m.output != nil {
		fields = append(fields, instanceruntime.FieldOutput)
	}
	if m.stateBeginTime != nil {
		fields = append(fields, instanceruntime.FieldStateBeginTime)
	}
	if m.deadline != nil {
		fields = append(fields, instanceruntime.FieldDeadline)
	}
	if m.attempts != nil {
		fields = append(fields, instanceruntime.FieldAttempts)
	}
	if m.caller_data != nil {
		fields = append(fields, instanceruntime.FieldCallerData)
	}
	if m.instanceContext != nil {
		fields = append(fields, instanceruntime.FieldInstanceContext)
	}
	if m.stateContext != nil {
		fields = append(fields, instanceruntime.FieldStateContext)
	}
	if m.metadata != nil {
		fields = append(fields, instanceruntime.FieldMetadata)
	}
	if m.logToEvents != nil {
		fields = append(fields, instanceruntime.FieldLogToEvents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InstanceRuntimeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case instanceruntime.FieldInput:
		return m.Input()
	case instanceruntime.FieldData:
		return m.Data()
	case instanceruntime.FieldController:
		return m.Controller()
	case instanceruntime.FieldMemory:
		return m.Memory()
	case instanceruntime.FieldFlow:
		return m.Flow()
	case instanceruntime.FieldOutput:
		return m.Output()
	case instanceruntime.FieldStateBeginTime:
		return m.StateBeginTime()
	case instanceruntime.FieldDeadline:
		return m.Deadline()
	case instanceruntime.FieldAttempts:
		return m.Attempts()
	case instanceruntime.FieldCallerData:
		return m.CallerData()
	case instanceruntime.FieldInstanceContext:
		return m.InstanceContext()
	case instanceruntime.FieldStateContext:
		return m.StateContext()
	case instanceruntime.FieldMetadata:
		return m.Metadata()
	case instanceruntime.FieldLogToEvents:
		return m.LogToEvents()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InstanceRuntimeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case instanceruntime.FieldInput:
		return m.OldInput(ctx)
	case instanceruntime.FieldData:
		return m.OldData(ctx)
	case instanceruntime.FieldController:
		return m.OldController(ctx)
	case instanceruntime.FieldMemory:
		return m.OldMemory(ctx)
	case instanceruntime.FieldFlow:
		return m.OldFlow(ctx)
	case instanceruntime.FieldOutput:
		return m.OldOutput(ctx)
	case instanceruntime.FieldStateBeginTime:
		return m.OldStateBeginTime(ctx)
	case instanceruntime.FieldDeadline:
		return m.OldDeadline(ctx)
	case instanceruntime.FieldAttempts:
		return m.OldAttempts(ctx)
	case instanceruntime.FieldCallerData:
		return m.OldCallerData(ctx)
	case instanceruntime.FieldInstanceContext:
		return m.OldInstanceContext(ctx)
	case instanceruntime.FieldStateContext:
		return m.OldStateContext(ctx)
	case instanceruntime.FieldMetadata:
		return m.OldMetadata(ctx)
	case instanceruntime.FieldLogToEvents:
		return m.OldLogToEvents(ctx)
	}
	return nil, fmt.Errorf("unknown InstanceRuntime field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceRuntimeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case instanceruntime.FieldInput:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case instanceruntime.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case instanceruntime.FieldController:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetController(v)
		return nil
	case instanceruntime.FieldMemory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case instanceruntime.FieldFlow:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlow(v)
		return nil
	case instanceruntime.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case instanceruntime.FieldStateBeginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateBeginTime(v)
		return nil
	case instanceruntime.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case instanceruntime.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case instanceruntime.FieldCallerData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCallerData(v)
		return nil
	case instanceruntime.FieldInstanceContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceContext(v)
		return nil
	case instanceruntime.FieldStateContext:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateContext(v)
		return nil
	case instanceruntime.FieldMetadata:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetadata(v)
		return nil
	case instanceruntime.FieldLogToEvents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogToEvents(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InstanceRuntimeMutation) AddedFields() []string {
	var fields []string
	if m.addattempts != nil {
		fields = append(fields, instanceruntime.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InstanceRuntimeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case instanceruntime.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InstanceRuntimeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case instanceruntime.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InstanceRuntimeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(instanceruntime.FieldController) {
		fields = append(fields, instanceruntime.FieldController)
	}
	if m.FieldCleared(instanceruntime.FieldMemory) {
		fields = append(fields, instanceruntime.FieldMemory)
	}
	if m.FieldCleared(instanceruntime.FieldFlow) {
		fields = append(fields, instanceruntime.FieldFlow)
	}
	if m.FieldCleared(instanceruntime.FieldOutput) {
		fields = append(fields, instanceruntime.FieldOutput)
	}
	if m.FieldCleared(instanceruntime.FieldStateBeginTime) {
		fields = append(fields, instanceruntime.FieldStateBeginTime)
	}
	if m.FieldCleared(instanceruntime.FieldDeadline) {
		fields = append(fields, instanceruntime.FieldDeadline)
	}
	if m.FieldCleared(instanceruntime.FieldAttempts) {
		fields = append(fields, instanceruntime.FieldAttempts)
	}
	if m.FieldCleared(instanceruntime.FieldCallerData) {
		fields = append(fields, instanceruntime.FieldCallerData)
	}
	if m.FieldCleared(instanceruntime.FieldInstanceContext) {
		fields = append(fields, instanceruntime.FieldInstanceContext)
	}
	if m.FieldCleared(instanceruntime.FieldStateContext) {
		fields = append(fields, instanceruntime.FieldStateContext)
	}
	if m.FieldCleared(instanceruntime.FieldMetadata) {
		fields = append(fields, instanceruntime.FieldMetadata)
	}
	if m.FieldCleared(instanceruntime.FieldLogToEvents) {
		fields = append(fields, instanceruntime.FieldLogToEvents)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InstanceRuntimeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InstanceRuntimeMutation) ClearField(name string) error {
	switch name {
	case instanceruntime.FieldController:
		m.ClearController()
		return nil
	case instanceruntime.FieldMemory:
		m.ClearMemory()
		return nil
	case instanceruntime.FieldFlow:
		m.ClearFlow()
		return nil
	case instanceruntime.FieldOutput:
		m.ClearOutput()
		return nil
	case instanceruntime.FieldStateBeginTime:
		m.ClearStateBeginTime()
		return nil
	case instanceruntime.FieldDeadline:
		m.ClearDeadline()
		return nil
	case instanceruntime.FieldAttempts:
		m.ClearAttempts()
		return nil
	case instanceruntime.FieldCallerData:
		m.ClearCallerData()
		return nil
	case instanceruntime.FieldInstanceContext:
		m.ClearInstanceContext()
		return nil
	case instanceruntime.FieldStateContext:
		m.ClearStateContext()
		return nil
	case instanceruntime.FieldMetadata:
		m.ClearMetadata()
		return nil
	case instanceruntime.FieldLogToEvents:
		m.ClearLogToEvents()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InstanceRuntimeMutation) ResetField(name string) error {
	switch name {
	case instanceruntime.FieldInput:
		m.ResetInput()
		return nil
	case instanceruntime.FieldData:
		m.ResetData()
		return nil
	case instanceruntime.FieldController:
		m.ResetController()
		return nil
	case instanceruntime.FieldMemory:
		m.ResetMemory()
		return nil
	case instanceruntime.FieldFlow:
		m.ResetFlow()
		return nil
	case instanceruntime.FieldOutput:
		m.ResetOutput()
		return nil
	case instanceruntime.FieldStateBeginTime:
		m.ResetStateBeginTime()
		return nil
	case instanceruntime.FieldDeadline:
		m.ResetDeadline()
		return nil
	case instanceruntime.FieldAttempts:
		m.ResetAttempts()
		return nil
	case instanceruntime.FieldCallerData:
		m.ResetCallerData()
		return nil
	case instanceruntime.FieldInstanceContext:
		m.ResetInstanceContext()
		return nil
	case instanceruntime.FieldStateContext:
		m.ResetStateContext()
		return nil
	case instanceruntime.FieldMetadata:
		m.ResetMetadata()
		return nil
	case instanceruntime.FieldLogToEvents:
		m.ResetLogToEvents()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InstanceRuntimeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.instance != nil {
		edges = append(edges, instanceruntime.EdgeInstance)
	}
	if m.caller != nil {
		edges = append(edges, instanceruntime.EdgeCaller)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InstanceRuntimeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case instanceruntime.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	case instanceruntime.EdgeCaller:
		if id := m.caller; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InstanceRuntimeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InstanceRuntimeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InstanceRuntimeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedinstance {
		edges = append(edges, instanceruntime.EdgeInstance)
	}
	if m.clearedcaller {
		edges = append(edges, instanceruntime.EdgeCaller)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InstanceRuntimeMutation) EdgeCleared(name string) bool {
	switch name {
	case instanceruntime.EdgeInstance:
		return m.clearedinstance
	case instanceruntime.EdgeCaller:
		return m.clearedcaller
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InstanceRuntimeMutation) ClearEdge(name string) error {
	switch name {
	case instanceruntime.EdgeInstance:
		m.ClearInstance()
		return nil
	case instanceruntime.EdgeCaller:
		m.ClearCaller()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InstanceRuntimeMutation) ResetEdge(name string) error {
	switch name {
	case instanceruntime.EdgeInstance:
		m.ResetInstance()
		return nil
	case instanceruntime.EdgeCaller:
		m.ResetCaller()
		return nil
	}
	return fmt.Errorf("unknown InstanceRuntime edge %s", name)
}

// LogMsgMutation represents an operation that mutates the LogMsg nodes in the graph.
type LogMsgMutation struct {
	config
	op                  Op
	typ                 string
	id                  *uuid.UUID
	t                   *time.Time
	msg                 *string
	level               *string
	rootInstanceId      *string
	logInstanceCallPath *string
	tags                *map[string]string
	workflow_id         *uuid.UUID
	mirror_activity_id  *uuid.UUID
	clearedFields       map[string]struct{}
	namespace           *uuid.UUID
	clearednamespace    bool
	instance            *uuid.UUID
	clearedinstance     bool
	done                bool
	oldValue            func(context.Context) (*LogMsg, error)
	predicates          []predicate.LogMsg
}

var _ ent.Mutation = (*LogMsgMutation)(nil)

// logmsgOption allows management of the mutation configuration using functional options.
type logmsgOption func(*LogMsgMutation)

// newLogMsgMutation creates new mutation for the LogMsg entity.
func newLogMsgMutation(c config, op Op, opts ...logmsgOption) *LogMsgMutation {
	m := &LogMsgMutation{
		config:        c,
		op:            op,
		typ:           TypeLogMsg,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogMsgID sets the ID field of the mutation.
func withLogMsgID(id uuid.UUID) logmsgOption {
	return func(m *LogMsgMutation) {
		var (
			err   error
			once  sync.Once
			value *LogMsg
		)
		m.oldValue = func(ctx context.Context) (*LogMsg, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LogMsg.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogMsg sets the old LogMsg of the mutation.
func withLogMsg(node *LogMsg) logmsgOption {
	return func(m *LogMsgMutation) {
		m.oldValue = func(context.Context) (*LogMsg, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogMsgMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogMsgMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LogMsg entities.
func (m *LogMsgMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogMsgMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogMsgMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LogMsg.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetT sets the "t" field.
func (m *LogMsgMutation) SetT(t time.Time) {
	m.t = &t
}

// T returns the value of the "t" field in the mutation.
func (m *LogMsgMutation) T() (r time.Time, exists bool) {
	v := m.t
	if v == nil {
		return
	}
	return *v, true
}

// OldT returns the old "t" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldT(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldT is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldT requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldT: %w", err)
	}
	return oldValue.T, nil
}

// ResetT resets all changes to the "t" field.
func (m *LogMsgMutation) ResetT() {
	m.t = nil
}

// SetMsg sets the "msg" field.
func (m *LogMsgMutation) SetMsg(s string) {
	m.msg = &s
}

// Msg returns the value of the "msg" field in the mutation.
func (m *LogMsgMutation) Msg() (r string, exists bool) {
	v := m.msg
	if v == nil {
		return
	}
	return *v, true
}

// OldMsg returns the old "msg" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldMsg(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMsg is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMsg requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMsg: %w", err)
	}
	return oldValue.Msg, nil
}

// ResetMsg resets all changes to the "msg" field.
func (m *LogMsgMutation) ResetMsg() {
	m.msg = nil
}

// SetLevel sets the "level" field.
func (m *LogMsgMutation) SetLevel(s string) {
	m.level = &s
}

// Level returns the value of the "level" field in the mutation.
func (m *LogMsgMutation) Level() (r string, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldLevel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *LogMsgMutation) ResetLevel() {
	m.level = nil
}

// SetRootInstanceId sets the "rootInstanceId" field.
func (m *LogMsgMutation) SetRootInstanceId(s string) {
	m.rootInstanceId = &s
}

// RootInstanceId returns the value of the "rootInstanceId" field in the mutation.
func (m *LogMsgMutation) RootInstanceId() (r string, exists bool) {
	v := m.rootInstanceId
	if v == nil {
		return
	}
	return *v, true
}

// OldRootInstanceId returns the old "rootInstanceId" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldRootInstanceId(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRootInstanceId is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRootInstanceId requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRootInstanceId: %w", err)
	}
	return oldValue.RootInstanceId, nil
}

// ResetRootInstanceId resets all changes to the "rootInstanceId" field.
func (m *LogMsgMutation) ResetRootInstanceId() {
	m.rootInstanceId = nil
}

// SetLogInstanceCallPath sets the "logInstanceCallPath" field.
func (m *LogMsgMutation) SetLogInstanceCallPath(s string) {
	m.logInstanceCallPath = &s
}

// LogInstanceCallPath returns the value of the "logInstanceCallPath" field in the mutation.
func (m *LogMsgMutation) LogInstanceCallPath() (r string, exists bool) {
	v := m.logInstanceCallPath
	if v == nil {
		return
	}
	return *v, true
}

// OldLogInstanceCallPath returns the old "logInstanceCallPath" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldLogInstanceCallPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogInstanceCallPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogInstanceCallPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogInstanceCallPath: %w", err)
	}
	return oldValue.LogInstanceCallPath, nil
}

// ResetLogInstanceCallPath resets all changes to the "logInstanceCallPath" field.
func (m *LogMsgMutation) ResetLogInstanceCallPath() {
	m.logInstanceCallPath = nil
}

// SetTags sets the "tags" field.
func (m *LogMsgMutation) SetTags(value map[string]string) {
	m.tags = &value
}

// Tags returns the value of the "tags" field in the mutation.
func (m *LogMsgMutation) Tags() (r map[string]string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldTags(ctx context.Context) (v map[string]string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ClearTags clears the value of the "tags" field.
func (m *LogMsgMutation) ClearTags() {
	m.tags = nil
	m.clearedFields[logmsg.FieldTags] = struct{}{}
}

// TagsCleared returns if the "tags" field was cleared in this mutation.
func (m *LogMsgMutation) TagsCleared() bool {
	_, ok := m.clearedFields[logmsg.FieldTags]
	return ok
}

// ResetTags resets all changes to the "tags" field.
func (m *LogMsgMutation) ResetTags() {
	m.tags = nil
	delete(m.clearedFields, logmsg.FieldTags)
}

// SetWorkflowID sets the "workflow_id" field.
func (m *LogMsgMutation) SetWorkflowID(u uuid.UUID) {
	m.workflow_id = &u
}

// WorkflowID returns the value of the "workflow_id" field in the mutation.
func (m *LogMsgMutation) WorkflowID() (r uuid.UUID, exists bool) {
	v := m.workflow_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflowID returns the old "workflow_id" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldWorkflowID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkflowID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkflowID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflowID: %w", err)
	}
	return oldValue.WorkflowID, nil
}

// ClearWorkflowID clears the value of the "workflow_id" field.
func (m *LogMsgMutation) ClearWorkflowID() {
	m.workflow_id = nil
	m.clearedFields[logmsg.FieldWorkflowID] = struct{}{}
}

// WorkflowIDCleared returns if the "workflow_id" field was cleared in this mutation.
func (m *LogMsgMutation) WorkflowIDCleared() bool {
	_, ok := m.clearedFields[logmsg.FieldWorkflowID]
	return ok
}

// ResetWorkflowID resets all changes to the "workflow_id" field.
func (m *LogMsgMutation) ResetWorkflowID() {
	m.workflow_id = nil
	delete(m.clearedFields, logmsg.FieldWorkflowID)
}

// SetMirrorActivityID sets the "mirror_activity_id" field.
func (m *LogMsgMutation) SetMirrorActivityID(u uuid.UUID) {
	m.mirror_activity_id = &u
}

// MirrorActivityID returns the value of the "mirror_activity_id" field in the mutation.
func (m *LogMsgMutation) MirrorActivityID() (r uuid.UUID, exists bool) {
	v := m.mirror_activity_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMirrorActivityID returns the old "mirror_activity_id" field's value of the LogMsg entity.
// If the LogMsg object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogMsgMutation) OldMirrorActivityID(ctx context.Context) (v uuid.UUID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMirrorActivityID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMirrorActivityID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMirrorActivityID: %w", err)
	}
	return oldValue.MirrorActivityID, nil
}

// ClearMirrorActivityID clears the value of the "mirror_activity_id" field.
func (m *LogMsgMutation) ClearMirrorActivityID() {
	m.mirror_activity_id = nil
	m.clearedFields[logmsg.FieldMirrorActivityID] = struct{}{}
}

// MirrorActivityIDCleared returns if the "mirror_activity_id" field was cleared in this mutation.
func (m *LogMsgMutation) MirrorActivityIDCleared() bool {
	_, ok := m.clearedFields[logmsg.FieldMirrorActivityID]
	return ok
}

// ResetMirrorActivityID resets all changes to the "mirror_activity_id" field.
func (m *LogMsgMutation) ResetMirrorActivityID() {
	m.mirror_activity_id = nil
	delete(m.clearedFields, logmsg.FieldMirrorActivityID)
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *LogMsgMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *LogMsgMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *LogMsgMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *LogMsgMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *LogMsgMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *LogMsgMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// SetInstanceID sets the "instance" edge to the Instance entity by id.
func (m *LogMsgMutation) SetInstanceID(id uuid.UUID) {
	m.instance = &id
}

// ClearInstance clears the "instance" edge to the Instance entity.
func (m *LogMsgMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the Instance entity was cleared.
func (m *LogMsgMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// InstanceID returns the "instance" edge ID in the mutation.
func (m *LogMsgMutation) InstanceID() (id uuid.UUID, exists bool) {
	if m.instance != nil {
		return *m.instance, true
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InstanceID instead. It exists only for internal usage by the builders.
func (m *LogMsgMutation) InstanceIDs() (ids []uuid.UUID) {
	if id := m.instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *LogMsgMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
}

// Where appends a list predicates to the LogMsgMutation builder.
func (m *LogMsgMutation) Where(ps ...predicate.LogMsg) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogMsgMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogMsgMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LogMsg, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogMsgMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogMsgMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LogMsg).
func (m *LogMsgMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogMsgMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.t != nil {
		fields = append(fields, logmsg.FieldT)
	}
	if m.msg != nil {
		fields = append(fields, logmsg.FieldMsg)
	}
	if m.level != nil {
		fields = append(fields, logmsg.FieldLevel)
	}
	if m.rootInstanceId != nil {
		fields = append(fields, logmsg.FieldRootInstanceId)
	}
	if m.logInstanceCallPath != nil {
		fields = append(fields, logmsg.FieldLogInstanceCallPath)
	}
	if m.tags != nil {
		fields = append(fields, logmsg.FieldTags)
	}
	if m.workflow_id != nil {
		fields = append(fields, logmsg.FieldWorkflowID)
	}
	if m.mirror_activity_id != nil {
		fields = append(fields, logmsg.FieldMirrorActivityID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogMsgMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logmsg.FieldT:
		return m.T()
	case logmsg.FieldMsg:
		return m.Msg()
	case logmsg.FieldLevel:
		return m.Level()
	case logmsg.FieldRootInstanceId:
		return m.RootInstanceId()
	case logmsg.FieldLogInstanceCallPath:
		return m.LogInstanceCallPath()
	case logmsg.FieldTags:
		return m.Tags()
	case logmsg.FieldWorkflowID:
		return m.WorkflowID()
	case logmsg.FieldMirrorActivityID:
		return m.MirrorActivityID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogMsgMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logmsg.FieldT:
		return m.OldT(ctx)
	case logmsg.FieldMsg:
		return m.OldMsg(ctx)
	case logmsg.FieldLevel:
		return m.OldLevel(ctx)
	case logmsg.FieldRootInstanceId:
		return m.OldRootInstanceId(ctx)
	case logmsg.FieldLogInstanceCallPath:
		return m.OldLogInstanceCallPath(ctx)
	case logmsg.FieldTags:
		return m.OldTags(ctx)
	case logmsg.FieldWorkflowID:
		return m.OldWorkflowID(ctx)
	case logmsg.FieldMirrorActivityID:
		return m.OldMirrorActivityID(ctx)
	}
	return nil, fmt.Errorf("unknown LogMsg field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogMsgMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logmsg.FieldT:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetT(v)
		return nil
	case logmsg.FieldMsg:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMsg(v)
		return nil
	case logmsg.FieldLevel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case logmsg.FieldRootInstanceId:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRootInstanceId(v)
		return nil
	case logmsg.FieldLogInstanceCallPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogInstanceCallPath(v)
		return nil
	case logmsg.FieldTags:
		v, ok := value.(map[string]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	case logmsg.FieldWorkflowID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflowID(v)
		return nil
	case logmsg.FieldMirrorActivityID:
		v, ok := value.(uuid.UUID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMirrorActivityID(v)
		return nil
	}
	return fmt.Errorf("unknown LogMsg field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogMsgMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogMsgMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogMsgMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LogMsg numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogMsgMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(logmsg.FieldTags) {
		fields = append(fields, logmsg.FieldTags)
	}
	if m.FieldCleared(logmsg.FieldWorkflowID) {
		fields = append(fields, logmsg.FieldWorkflowID)
	}
	if m.FieldCleared(logmsg.FieldMirrorActivityID) {
		fields = append(fields, logmsg.FieldMirrorActivityID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogMsgMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogMsgMutation) ClearField(name string) error {
	switch name {
	case logmsg.FieldTags:
		m.ClearTags()
		return nil
	case logmsg.FieldWorkflowID:
		m.ClearWorkflowID()
		return nil
	case logmsg.FieldMirrorActivityID:
		m.ClearMirrorActivityID()
		return nil
	}
	return fmt.Errorf("unknown LogMsg nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogMsgMutation) ResetField(name string) error {
	switch name {
	case logmsg.FieldT:
		m.ResetT()
		return nil
	case logmsg.FieldMsg:
		m.ResetMsg()
		return nil
	case logmsg.FieldLevel:
		m.ResetLevel()
		return nil
	case logmsg.FieldRootInstanceId:
		m.ResetRootInstanceId()
		return nil
	case logmsg.FieldLogInstanceCallPath:
		m.ResetLogInstanceCallPath()
		return nil
	case logmsg.FieldTags:
		m.ResetTags()
		return nil
	case logmsg.FieldWorkflowID:
		m.ResetWorkflowID()
		return nil
	case logmsg.FieldMirrorActivityID:
		m.ResetMirrorActivityID()
		return nil
	}
	return fmt.Errorf("unknown LogMsg field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogMsgMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.namespace != nil {
		edges = append(edges, logmsg.EdgeNamespace)
	}
	if m.instance != nil {
		edges = append(edges, logmsg.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogMsgMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case logmsg.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case logmsg.EdgeInstance:
		if id := m.instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogMsgMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogMsgMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogMsgMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearednamespace {
		edges = append(edges, logmsg.EdgeNamespace)
	}
	if m.clearedinstance {
		edges = append(edges, logmsg.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogMsgMutation) EdgeCleared(name string) bool {
	switch name {
	case logmsg.EdgeNamespace:
		return m.clearednamespace
	case logmsg.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogMsgMutation) ClearEdge(name string) error {
	switch name {
	case logmsg.EdgeNamespace:
		m.ClearNamespace()
		return nil
	case logmsg.EdgeInstance:
		m.ClearInstance()
		return nil
	}
	return fmt.Errorf("unknown LogMsg unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogMsgMutation) ResetEdge(name string) error {
	switch name {
	case logmsg.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case logmsg.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown LogMsg edge %s", name)
}

// NamespaceMutation represents an operation that mutates the Namespace nodes in the graph.
type NamespaceMutation struct {
	config
	op                        Op
	typ                       string
	id                        *uuid.UUID
	created_at                *time.Time
	updated_at                *time.Time
	_config                   *string
	name                      *string
	clearedFields             map[string]struct{}
	instances                 map[uuid.UUID]struct{}
	removedinstances          map[uuid.UUID]struct{}
	clearedinstances          bool
	logs                      map[uuid.UUID]struct{}
	removedlogs               map[uuid.UUID]struct{}
	clearedlogs               bool
	cloudevents               map[uuid.UUID]struct{}
	removedcloudevents        map[uuid.UUID]struct{}
	clearedcloudevents        bool
	namespacelisteners        map[uuid.UUID]struct{}
	removednamespacelisteners map[uuid.UUID]struct{}
	clearednamespacelisteners bool
	annotations               map[uuid.UUID]struct{}
	removedannotations        map[uuid.UUID]struct{}
	clearedannotations        bool
	cloudeventfilters         map[int]struct{}
	removedcloudeventfilters  map[int]struct{}
	clearedcloudeventfilters  bool
	services                  map[uuid.UUID]struct{}
	removedservices           map[uuid.UUID]struct{}
	clearedservices           bool
	done                      bool
	oldValue                  func(context.Context) (*Namespace, error)
	predicates                []predicate.Namespace
}

var _ ent.Mutation = (*NamespaceMutation)(nil)

// namespaceOption allows management of the mutation configuration using functional options.
type namespaceOption func(*NamespaceMutation)

// newNamespaceMutation creates new mutation for the Namespace entity.
func newNamespaceMutation(c config, op Op, opts ...namespaceOption) *NamespaceMutation {
	m := &NamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceID sets the ID field of the mutation.
func withNamespaceID(id uuid.UUID) namespaceOption {
	return func(m *NamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Namespace
		)
		m.oldValue = func(ctx context.Context) (*Namespace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Namespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespace sets the old Namespace of the mutation.
func withNamespace(node *Namespace) namespaceOption {
	return func(m *NamespaceMutation) {
		m.oldValue = func(context.Context) (*Namespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Namespace entities.
func (m *NamespaceMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamespaceMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NamespaceMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Namespace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *NamespaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *NamespaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *NamespaceMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *NamespaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *NamespaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *NamespaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetConfig sets the "config" field.
func (m *NamespaceMutation) SetConfig(s string) {
	m._config = &s
}

// Config returns the value of the "config" field in the mutation.
func (m *NamespaceMutation) Config() (r string, exists bool) {
	v := m._config
	if v == nil {
		return
	}
	return *v, true
}

// OldConfig returns the old "config" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldConfig(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConfig is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConfig requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConfig: %w", err)
	}
	return oldValue.Config, nil
}

// ResetConfig resets all changes to the "config" field.
func (m *NamespaceMutation) ResetConfig() {
	m._config = nil
}

// SetName sets the "name" field.
func (m *NamespaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NamespaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NamespaceMutation) ResetName() {
	m.name = nil
}

// AddInstanceIDs adds the "instances" edge to the Instance entity by ids.
func (m *NamespaceMutation) AddInstanceIDs(ids ...uuid.UUID) {
	if m.instances == nil {
		m.instances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the Instance entity.
func (m *NamespaceMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the Instance entity was cleared.
func (m *NamespaceMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the Instance entity by IDs.
func (m *NamespaceMutation) RemoveInstanceIDs(ids ...uuid.UUID) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the Instance entity.
func (m *NamespaceMutation) RemovedInstancesIDs() (ids []uuid.UUID) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *NamespaceMutation) InstancesIDs() (ids []uuid.UUID) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *NamespaceMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// AddLogIDs adds the "logs" edge to the LogMsg entity by ids.
func (m *NamespaceMutation) AddLogIDs(ids ...uuid.UUID) {
	if m.logs == nil {
		m.logs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.logs[ids[i]] = struct{}{}
	}
}

// ClearLogs clears the "logs" edge to the LogMsg entity.
func (m *NamespaceMutation) ClearLogs() {
	m.clearedlogs = true
}

// LogsCleared reports if the "logs" edge to the LogMsg entity was cleared.
func (m *NamespaceMutation) LogsCleared() bool {
	return m.clearedlogs
}

// RemoveLogIDs removes the "logs" edge to the LogMsg entity by IDs.
func (m *NamespaceMutation) RemoveLogIDs(ids ...uuid.UUID) {
	if m.removedlogs == nil {
		m.removedlogs = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.logs, ids[i])
		m.removedlogs[ids[i]] = struct{}{}
	}
}

// RemovedLogs returns the removed IDs of the "logs" edge to the LogMsg entity.
func (m *NamespaceMutation) RemovedLogsIDs() (ids []uuid.UUID) {
	for id := range m.removedlogs {
		ids = append(ids, id)
	}
	return
}

// LogsIDs returns the "logs" edge IDs in the mutation.
func (m *NamespaceMutation) LogsIDs() (ids []uuid.UUID) {
	for id := range m.logs {
		ids = append(ids, id)
	}
	return
}

// ResetLogs resets all changes to the "logs" edge.
func (m *NamespaceMutation) ResetLogs() {
	m.logs = nil
	m.clearedlogs = false
	m.removedlogs = nil
}

// AddCloudeventIDs adds the "cloudevents" edge to the CloudEvents entity by ids.
func (m *NamespaceMutation) AddCloudeventIDs(ids ...uuid.UUID) {
	if m.cloudevents == nil {
		m.cloudevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.cloudevents[ids[i]] = struct{}{}
	}
}

// ClearCloudevents clears the "cloudevents" edge to the CloudEvents entity.
func (m *NamespaceMutation) ClearCloudevents() {
	m.clearedcloudevents = true
}

// CloudeventsCleared reports if the "cloudevents" edge to the CloudEvents entity was cleared.
func (m *NamespaceMutation) CloudeventsCleared() bool {
	return m.clearedcloudevents
}

// RemoveCloudeventIDs removes the "cloudevents" edge to the CloudEvents entity by IDs.
func (m *NamespaceMutation) RemoveCloudeventIDs(ids ...uuid.UUID) {
	if m.removedcloudevents == nil {
		m.removedcloudevents = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.cloudevents, ids[i])
		m.removedcloudevents[ids[i]] = struct{}{}
	}
}

// RemovedCloudevents returns the removed IDs of the "cloudevents" edge to the CloudEvents entity.
func (m *NamespaceMutation) RemovedCloudeventsIDs() (ids []uuid.UUID) {
	for id := range m.removedcloudevents {
		ids = append(ids, id)
	}
	return
}

// CloudeventsIDs returns the "cloudevents" edge IDs in the mutation.
func (m *NamespaceMutation) CloudeventsIDs() (ids []uuid.UUID) {
	for id := range m.cloudevents {
		ids = append(ids, id)
	}
	return
}

// ResetCloudevents resets all changes to the "cloudevents" edge.
func (m *NamespaceMutation) ResetCloudevents() {
	m.cloudevents = nil
	m.clearedcloudevents = false
	m.removedcloudevents = nil
}

// AddNamespacelistenerIDs adds the "namespacelisteners" edge to the Events entity by ids.
func (m *NamespaceMutation) AddNamespacelistenerIDs(ids ...uuid.UUID) {
	if m.namespacelisteners == nil {
		m.namespacelisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.namespacelisteners[ids[i]] = struct{}{}
	}
}

// ClearNamespacelisteners clears the "namespacelisteners" edge to the Events entity.
func (m *NamespaceMutation) ClearNamespacelisteners() {
	m.clearednamespacelisteners = true
}

// NamespacelistenersCleared reports if the "namespacelisteners" edge to the Events entity was cleared.
func (m *NamespaceMutation) NamespacelistenersCleared() bool {
	return m.clearednamespacelisteners
}

// RemoveNamespacelistenerIDs removes the "namespacelisteners" edge to the Events entity by IDs.
func (m *NamespaceMutation) RemoveNamespacelistenerIDs(ids ...uuid.UUID) {
	if m.removednamespacelisteners == nil {
		m.removednamespacelisteners = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.namespacelisteners, ids[i])
		m.removednamespacelisteners[ids[i]] = struct{}{}
	}
}

// RemovedNamespacelisteners returns the removed IDs of the "namespacelisteners" edge to the Events entity.
func (m *NamespaceMutation) RemovedNamespacelistenersIDs() (ids []uuid.UUID) {
	for id := range m.removednamespacelisteners {
		ids = append(ids, id)
	}
	return
}

// NamespacelistenersIDs returns the "namespacelisteners" edge IDs in the mutation.
func (m *NamespaceMutation) NamespacelistenersIDs() (ids []uuid.UUID) {
	for id := range m.namespacelisteners {
		ids = append(ids, id)
	}
	return
}

// ResetNamespacelisteners resets all changes to the "namespacelisteners" edge.
func (m *NamespaceMutation) ResetNamespacelisteners() {
	m.namespacelisteners = nil
	m.clearednamespacelisteners = false
	m.removednamespacelisteners = nil
}

// AddAnnotationIDs adds the "annotations" edge to the Annotation entity by ids.
func (m *NamespaceMutation) AddAnnotationIDs(ids ...uuid.UUID) {
	if m.annotations == nil {
		m.annotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.annotations[ids[i]] = struct{}{}
	}
}

// ClearAnnotations clears the "annotations" edge to the Annotation entity.
func (m *NamespaceMutation) ClearAnnotations() {
	m.clearedannotations = true
}

// AnnotationsCleared reports if the "annotations" edge to the Annotation entity was cleared.
func (m *NamespaceMutation) AnnotationsCleared() bool {
	return m.clearedannotations
}

// RemoveAnnotationIDs removes the "annotations" edge to the Annotation entity by IDs.
func (m *NamespaceMutation) RemoveAnnotationIDs(ids ...uuid.UUID) {
	if m.removedannotations == nil {
		m.removedannotations = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.annotations, ids[i])
		m.removedannotations[ids[i]] = struct{}{}
	}
}

// RemovedAnnotations returns the removed IDs of the "annotations" edge to the Annotation entity.
func (m *NamespaceMutation) RemovedAnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.removedannotations {
		ids = append(ids, id)
	}
	return
}

// AnnotationsIDs returns the "annotations" edge IDs in the mutation.
func (m *NamespaceMutation) AnnotationsIDs() (ids []uuid.UUID) {
	for id := range m.annotations {
		ids = append(ids, id)
	}
	return
}

// ResetAnnotations resets all changes to the "annotations" edge.
func (m *NamespaceMutation) ResetAnnotations() {
	m.annotations = nil
	m.clearedannotations = false
	m.removedannotations = nil
}

// AddCloudeventfilterIDs adds the "cloudeventfilters" edge to the CloudEventFilters entity by ids.
func (m *NamespaceMutation) AddCloudeventfilterIDs(ids ...int) {
	if m.cloudeventfilters == nil {
		m.cloudeventfilters = make(map[int]struct{})
	}
	for i := range ids {
		m.cloudeventfilters[ids[i]] = struct{}{}
	}
}

// ClearCloudeventfilters clears the "cloudeventfilters" edge to the CloudEventFilters entity.
func (m *NamespaceMutation) ClearCloudeventfilters() {
	m.clearedcloudeventfilters = true
}

// CloudeventfiltersCleared reports if the "cloudeventfilters" edge to the CloudEventFilters entity was cleared.
func (m *NamespaceMutation) CloudeventfiltersCleared() bool {
	return m.clearedcloudeventfilters
}

// RemoveCloudeventfilterIDs removes the "cloudeventfilters" edge to the CloudEventFilters entity by IDs.
func (m *NamespaceMutation) RemoveCloudeventfilterIDs(ids ...int) {
	if m.removedcloudeventfilters == nil {
		m.removedcloudeventfilters = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.cloudeventfilters, ids[i])
		m.removedcloudeventfilters[ids[i]] = struct{}{}
	}
}

// RemovedCloudeventfilters returns the removed IDs of the "cloudeventfilters" edge to the CloudEventFilters entity.
func (m *NamespaceMutation) RemovedCloudeventfiltersIDs() (ids []int) {
	for id := range m.removedcloudeventfilters {
		ids = append(ids, id)
	}
	return
}

// CloudeventfiltersIDs returns the "cloudeventfilters" edge IDs in the mutation.
func (m *NamespaceMutation) CloudeventfiltersIDs() (ids []int) {
	for id := range m.cloudeventfilters {
		ids = append(ids, id)
	}
	return
}

// ResetCloudeventfilters resets all changes to the "cloudeventfilters" edge.
func (m *NamespaceMutation) ResetCloudeventfilters() {
	m.cloudeventfilters = nil
	m.clearedcloudeventfilters = false
	m.removedcloudeventfilters = nil
}

// AddServiceIDs adds the "services" edge to the Services entity by ids.
func (m *NamespaceMutation) AddServiceIDs(ids ...uuid.UUID) {
	if m.services == nil {
		m.services = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.services[ids[i]] = struct{}{}
	}
}

// ClearServices clears the "services" edge to the Services entity.
func (m *NamespaceMutation) ClearServices() {
	m.clearedservices = true
}

// ServicesCleared reports if the "services" edge to the Services entity was cleared.
func (m *NamespaceMutation) ServicesCleared() bool {
	return m.clearedservices
}

// RemoveServiceIDs removes the "services" edge to the Services entity by IDs.
func (m *NamespaceMutation) RemoveServiceIDs(ids ...uuid.UUID) {
	if m.removedservices == nil {
		m.removedservices = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.services, ids[i])
		m.removedservices[ids[i]] = struct{}{}
	}
}

// RemovedServices returns the removed IDs of the "services" edge to the Services entity.
func (m *NamespaceMutation) RemovedServicesIDs() (ids []uuid.UUID) {
	for id := range m.removedservices {
		ids = append(ids, id)
	}
	return
}

// ServicesIDs returns the "services" edge IDs in the mutation.
func (m *NamespaceMutation) ServicesIDs() (ids []uuid.UUID) {
	for id := range m.services {
		ids = append(ids, id)
	}
	return
}

// ResetServices resets all changes to the "services" edge.
func (m *NamespaceMutation) ResetServices() {
	m.services = nil
	m.clearedservices = false
	m.removedservices = nil
}

// Where appends a list predicates to the NamespaceMutation builder.
func (m *NamespaceMutation) Where(ps ...predicate.Namespace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NamespaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NamespaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Namespace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NamespaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NamespaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Namespace).
func (m *NamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamespaceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, namespace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, namespace.FieldUpdatedAt)
	}
	if m._config != nil {
		fields = append(fields, namespace.FieldConfig)
	}
	if m.name != nil {
		fields = append(fields, namespace.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.CreatedAt()
	case namespace.FieldUpdatedAt:
		return m.UpdatedAt()
	case namespace.FieldConfig:
		return m.Config()
	case namespace.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case namespace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case namespace.FieldConfig:
		return m.OldConfig(ctx)
	case namespace.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Namespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case namespace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case namespace.FieldConfig:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConfig(v)
		return nil
	case namespace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamespaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamespaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Namespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamespaceMutation) ResetField(name string) error {
	switch name {
	case namespace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case namespace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case namespace.FieldConfig:
		m.ResetConfig()
		return nil
	case namespace.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.instances != nil {
		edges = append(edges, namespace.EdgeInstances)
	}
	if m.logs != nil {
		edges = append(edges, namespace.EdgeLogs)
	}
	if m.cloudevents != nil {
		edges = append(edges, namespace.EdgeCloudevents)
	}
	if m.namespacelisteners != nil {
		edges = append(edges, namespace.EdgeNamespacelisteners)
	}
	if m.annotations != nil {
		edges = append(edges, namespace.EdgeAnnotations)
	}
	if m.cloudeventfilters != nil {
		edges = append(edges, namespace.EdgeCloudeventfilters)
	}
	if m.services != nil {
		edges = append(edges, namespace.EdgeServices)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.logs))
		for id := range m.logs {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudevents:
		ids := make([]ent.Value, 0, len(m.cloudevents))
		for id := range m.cloudevents {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeNamespacelisteners:
		ids := make([]ent.Value, 0, len(m.namespacelisteners))
		for id := range m.namespacelisteners {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.annotations))
		for id := range m.annotations {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudeventfilters:
		ids := make([]ent.Value, 0, len(m.cloudeventfilters))
		for id := range m.cloudeventfilters {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeServices:
		ids := make([]ent.Value, 0, len(m.services))
		for id := range m.services {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedinstances != nil {
		edges = append(edges, namespace.EdgeInstances)
	}
	if m.removedlogs != nil {
		edges = append(edges, namespace.EdgeLogs)
	}
	if m.removedcloudevents != nil {
		edges = append(edges, namespace.EdgeCloudevents)
	}
	if m.removednamespacelisteners != nil {
		edges = append(edges, namespace.EdgeNamespacelisteners)
	}
	if m.removedannotations != nil {
		edges = append(edges, namespace.EdgeAnnotations)
	}
	if m.removedcloudeventfilters != nil {
		edges = append(edges, namespace.EdgeCloudeventfilters)
	}
	if m.removedservices != nil {
		edges = append(edges, namespace.EdgeServices)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeLogs:
		ids := make([]ent.Value, 0, len(m.removedlogs))
		for id := range m.removedlogs {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudevents:
		ids := make([]ent.Value, 0, len(m.removedcloudevents))
		for id := range m.removedcloudevents {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeNamespacelisteners:
		ids := make([]ent.Value, 0, len(m.removednamespacelisteners))
		for id := range m.removednamespacelisteners {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeAnnotations:
		ids := make([]ent.Value, 0, len(m.removedannotations))
		for id := range m.removedannotations {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeCloudeventfilters:
		ids := make([]ent.Value, 0, len(m.removedcloudeventfilters))
		for id := range m.removedcloudeventfilters {
			ids = append(ids, id)
		}
		return ids
	case namespace.EdgeServices:
		ids := make([]ent.Value, 0, len(m.removedservices))
		for id := range m.removedservices {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedinstances {
		edges = append(edges, namespace.EdgeInstances)
	}
	if m.clearedlogs {
		edges = append(edges, namespace.EdgeLogs)
	}
	if m.clearedcloudevents {
		edges = append(edges, namespace.EdgeCloudevents)
	}
	if m.clearednamespacelisteners {
		edges = append(edges, namespace.EdgeNamespacelisteners)
	}
	if m.clearedannotations {
		edges = append(edges, namespace.EdgeAnnotations)
	}
	if m.clearedcloudeventfilters {
		edges = append(edges, namespace.EdgeCloudeventfilters)
	}
	if m.clearedservices {
		edges = append(edges, namespace.EdgeServices)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case namespace.EdgeInstances:
		return m.clearedinstances
	case namespace.EdgeLogs:
		return m.clearedlogs
	case namespace.EdgeCloudevents:
		return m.clearedcloudevents
	case namespace.EdgeNamespacelisteners:
		return m.clearednamespacelisteners
	case namespace.EdgeAnnotations:
		return m.clearedannotations
	case namespace.EdgeCloudeventfilters:
		return m.clearedcloudeventfilters
	case namespace.EdgeServices:
		return m.clearedservices
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamespaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamespaceMutation) ResetEdge(name string) error {
	switch name {
	case namespace.EdgeInstances:
		m.ResetInstances()
		return nil
	case namespace.EdgeLogs:
		m.ResetLogs()
		return nil
	case namespace.EdgeCloudevents:
		m.ResetCloudevents()
		return nil
	case namespace.EdgeNamespacelisteners:
		m.ResetNamespacelisteners()
		return nil
	case namespace.EdgeAnnotations:
		m.ResetAnnotations()
		return nil
	case namespace.EdgeCloudeventfilters:
		m.ResetCloudeventfilters()
		return nil
	case namespace.EdgeServices:
		m.ResetServices()
		return nil
	}
	return fmt.Errorf("unknown Namespace edge %s", name)
}

// ServicesMutation represents an operation that mutates the Services nodes in the graph.
type ServicesMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	created_at       *time.Time
	updated_at       *time.Time
	url              *string
	name             *string
	data             *string
	clearedFields    map[string]struct{}
	namespace        *uuid.UUID
	clearednamespace bool
	done             bool
	oldValue         func(context.Context) (*Services, error)
	predicates       []predicate.Services
}

var _ ent.Mutation = (*ServicesMutation)(nil)

// servicesOption allows management of the mutation configuration using functional options.
type servicesOption func(*ServicesMutation)

// newServicesMutation creates new mutation for the Services entity.
func newServicesMutation(c config, op Op, opts ...servicesOption) *ServicesMutation {
	m := &ServicesMutation{
		config:        c,
		op:            op,
		typ:           TypeServices,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withServicesID sets the ID field of the mutation.
func withServicesID(id uuid.UUID) servicesOption {
	return func(m *ServicesMutation) {
		var (
			err   error
			once  sync.Once
			value *Services
		)
		m.oldValue = func(ctx context.Context) (*Services, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Services.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withServices sets the old Services of the mutation.
func withServices(node *Services) servicesOption {
	return func(m *ServicesMutation) {
		m.oldValue = func(context.Context) (*Services, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ServicesMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ServicesMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Services entities.
func (m *ServicesMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ServicesMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ServicesMutation) IDs(ctx context.Context) ([]uuid.UUID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []uuid.UUID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Services.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *ServicesMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ServicesMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ServicesMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ServicesMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ServicesMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ServicesMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetURL sets the "url" field.
func (m *ServicesMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ServicesMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ServicesMutation) ResetURL() {
	m.url = nil
}

// SetName sets the "name" field.
func (m *ServicesMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ServicesMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ServicesMutation) ResetName() {
	m.name = nil
}

// SetData sets the "data" field.
func (m *ServicesMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *ServicesMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the Services entity.
// If the Services object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ServicesMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ResetData resets all changes to the "data" field.
func (m *ServicesMutation) ResetData() {
	m.data = nil
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *ServicesMutation) SetNamespaceID(id uuid.UUID) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *ServicesMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *ServicesMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *ServicesMutation) NamespaceID() (id uuid.UUID, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *ServicesMutation) NamespaceIDs() (ids []uuid.UUID) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *ServicesMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// Where appends a list predicates to the ServicesMutation builder.
func (m *ServicesMutation) Where(ps ...predicate.Services) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ServicesMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ServicesMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Services, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ServicesMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ServicesMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Services).
func (m *ServicesMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ServicesMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, services.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, services.FieldUpdatedAt)
	}
	if m.url != nil {
		fields = append(fields, services.FieldURL)
	}
	if m.name != nil {
		fields = append(fields, services.FieldName)
	}
	if m.data != nil {
		fields = append(fields, services.FieldData)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ServicesMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case services.FieldCreatedAt:
		return m.CreatedAt()
	case services.FieldUpdatedAt:
		return m.UpdatedAt()
	case services.FieldURL:
		return m.URL()
	case services.FieldName:
		return m.Name()
	case services.FieldData:
		return m.Data()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ServicesMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case services.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case services.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case services.FieldURL:
		return m.OldURL(ctx)
	case services.FieldName:
		return m.OldName(ctx)
	case services.FieldData:
		return m.OldData(ctx)
	}
	return nil, fmt.Errorf("unknown Services field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServicesMutation) SetField(name string, value ent.Value) error {
	switch name {
	case services.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case services.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case services.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case services.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case services.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	}
	return fmt.Errorf("unknown Services field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ServicesMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ServicesMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ServicesMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Services numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ServicesMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ServicesMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ServicesMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Services nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ServicesMutation) ResetField(name string) error {
	switch name {
	case services.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case services.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case services.FieldURL:
		m.ResetURL()
		return nil
	case services.FieldName:
		m.ResetName()
		return nil
	case services.FieldData:
		m.ResetData()
		return nil
	}
	return fmt.Errorf("unknown Services field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ServicesMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.namespace != nil {
		edges = append(edges, services.EdgeNamespace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ServicesMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case services.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ServicesMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ServicesMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ServicesMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearednamespace {
		edges = append(edges, services.EdgeNamespace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ServicesMutation) EdgeCleared(name string) bool {
	switch name {
	case services.EdgeNamespace:
		return m.clearednamespace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ServicesMutation) ClearEdge(name string) error {
	switch name {
	case services.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Services unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ServicesMutation) ResetEdge(name string) error {
	switch name {
	case services.EdgeNamespace:
		m.ResetNamespace()
		return nil
	}
	return fmt.Errorf("unknown Services edge %s", name)
}
