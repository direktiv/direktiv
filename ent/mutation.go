// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/google/uuid"
	"github.com/vorteil/direktiv/ent/namespace"
	"github.com/vorteil/direktiv/ent/predicate"
	"github.com/vorteil/direktiv/ent/workflow"
	"github.com/vorteil/direktiv/ent/workflowevents"
	"github.com/vorteil/direktiv/ent/workfloweventswait"
	"github.com/vorteil/direktiv/ent/workflowinstance"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeNamespace          = "Namespace"
	TypeWorkflow           = "Workflow"
	TypeWorkflowEvents     = "WorkflowEvents"
	TypeWorkflowEventsWait = "WorkflowEventsWait"
	TypeWorkflowInstance   = "WorkflowInstance"
)

// NamespaceMutation represents an operation that mutates the Namespace nodes in the graph.
type NamespaceMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created          *time.Time
	clearedFields    map[string]struct{}
	workflows        map[uuid.UUID]struct{}
	removedworkflows map[uuid.UUID]struct{}
	clearedworkflows bool
	done             bool
	oldValue         func(context.Context) (*Namespace, error)
	predicates       []predicate.Namespace
}

var _ ent.Mutation = (*NamespaceMutation)(nil)

// namespaceOption allows management of the mutation configuration using functional options.
type namespaceOption func(*NamespaceMutation)

// newNamespaceMutation creates new mutation for the Namespace entity.
func newNamespaceMutation(c config, op Op, opts ...namespaceOption) *NamespaceMutation {
	m := &NamespaceMutation{
		config:        c,
		op:            op,
		typ:           TypeNamespace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNamespaceID sets the ID field of the mutation.
func withNamespaceID(id string) namespaceOption {
	return func(m *NamespaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Namespace
		)
		m.oldValue = func(ctx context.Context) (*Namespace, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Namespace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNamespace sets the old Namespace of the mutation.
func withNamespace(node *Namespace) namespaceOption {
	return func(m *NamespaceMutation) {
		m.oldValue = func(context.Context) (*Namespace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NamespaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NamespaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Namespace entities.
func (m *NamespaceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NamespaceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreated sets the "created" field.
func (m *NamespaceMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *NamespaceMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Namespace entity.
// If the Namespace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NamespaceMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *NamespaceMutation) ResetCreated() {
	m.created = nil
}

// AddWorkflowIDs adds the "workflows" edge to the Workflow entity by ids.
func (m *NamespaceMutation) AddWorkflowIDs(ids ...uuid.UUID) {
	if m.workflows == nil {
		m.workflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		m.workflows[ids[i]] = struct{}{}
	}
}

// ClearWorkflows clears the "workflows" edge to the Workflow entity.
func (m *NamespaceMutation) ClearWorkflows() {
	m.clearedworkflows = true
}

// WorkflowsCleared reports if the "workflows" edge to the Workflow entity was cleared.
func (m *NamespaceMutation) WorkflowsCleared() bool {
	return m.clearedworkflows
}

// RemoveWorkflowIDs removes the "workflows" edge to the Workflow entity by IDs.
func (m *NamespaceMutation) RemoveWorkflowIDs(ids ...uuid.UUID) {
	if m.removedworkflows == nil {
		m.removedworkflows = make(map[uuid.UUID]struct{})
	}
	for i := range ids {
		delete(m.workflows, ids[i])
		m.removedworkflows[ids[i]] = struct{}{}
	}
}

// RemovedWorkflows returns the removed IDs of the "workflows" edge to the Workflow entity.
func (m *NamespaceMutation) RemovedWorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.removedworkflows {
		ids = append(ids, id)
	}
	return
}

// WorkflowsIDs returns the "workflows" edge IDs in the mutation.
func (m *NamespaceMutation) WorkflowsIDs() (ids []uuid.UUID) {
	for id := range m.workflows {
		ids = append(ids, id)
	}
	return
}

// ResetWorkflows resets all changes to the "workflows" edge.
func (m *NamespaceMutation) ResetWorkflows() {
	m.workflows = nil
	m.clearedworkflows = false
	m.removedworkflows = nil
}

// Where appends a list predicates to the NamespaceMutation builder.
func (m *NamespaceMutation) Where(ps ...predicate.Namespace) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *NamespaceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Namespace).
func (m *NamespaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NamespaceMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.created != nil {
		fields = append(fields, namespace.FieldCreated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NamespaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case namespace.FieldCreated:
		return m.Created()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NamespaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case namespace.FieldCreated:
		return m.OldCreated(ctx)
	}
	return nil, fmt.Errorf("unknown Namespace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case namespace.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NamespaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NamespaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NamespaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NamespaceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NamespaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NamespaceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Namespace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NamespaceMutation) ResetField(name string) error {
	switch name {
	case namespace.FieldCreated:
		m.ResetCreated()
		return nil
	}
	return fmt.Errorf("unknown Namespace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NamespaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflows != nil {
		edges = append(edges, namespace.EdgeWorkflows)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NamespaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.workflows))
		for id := range m.workflows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NamespaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedworkflows != nil {
		edges = append(edges, namespace.EdgeWorkflows)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NamespaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case namespace.EdgeWorkflows:
		ids := make([]ent.Value, 0, len(m.removedworkflows))
		for id := range m.removedworkflows {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NamespaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflows {
		edges = append(edges, namespace.EdgeWorkflows)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NamespaceMutation) EdgeCleared(name string) bool {
	switch name {
	case namespace.EdgeWorkflows:
		return m.clearedworkflows
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NamespaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Namespace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NamespaceMutation) ResetEdge(name string) error {
	switch name {
	case namespace.EdgeWorkflows:
		m.ResetWorkflows()
		return nil
	}
	return fmt.Errorf("unknown Namespace edge %s", name)
}

// WorkflowMutation represents an operation that mutates the Workflow nodes in the graph.
type WorkflowMutation struct {
	config
	op               Op
	typ              string
	id               *uuid.UUID
	name             *string
	created          *time.Time
	description      *string
	active           *bool
	revision         *int
	addrevision      *int
	workflow         *[]byte
	logToEvents      *string
	clearedFields    map[string]struct{}
	namespace        *string
	clearednamespace bool
	instances        map[int]struct{}
	removedinstances map[int]struct{}
	clearedinstances bool
	wfevents         map[int]struct{}
	removedwfevents  map[int]struct{}
	clearedwfevents  bool
	done             bool
	oldValue         func(context.Context) (*Workflow, error)
	predicates       []predicate.Workflow
}

var _ ent.Mutation = (*WorkflowMutation)(nil)

// workflowOption allows management of the mutation configuration using functional options.
type workflowOption func(*WorkflowMutation)

// newWorkflowMutation creates new mutation for the Workflow entity.
func newWorkflowMutation(c config, op Op, opts ...workflowOption) *WorkflowMutation {
	m := &WorkflowMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflow,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowID sets the ID field of the mutation.
func withWorkflowID(id uuid.UUID) workflowOption {
	return func(m *WorkflowMutation) {
		var (
			err   error
			once  sync.Once
			value *Workflow
		)
		m.oldValue = func(ctx context.Context) (*Workflow, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workflow.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflow sets the old Workflow of the mutation.
func withWorkflow(node *Workflow) workflowOption {
	return func(m *WorkflowMutation) {
		m.oldValue = func(context.Context) (*Workflow, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workflow entities.
func (m *WorkflowMutation) SetID(id uuid.UUID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowMutation) ID() (id uuid.UUID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *WorkflowMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkflowMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkflowMutation) ResetName() {
	m.name = nil
}

// SetCreated sets the "created" field.
func (m *WorkflowMutation) SetCreated(t time.Time) {
	m.created = &t
}

// Created returns the value of the "created" field in the mutation.
func (m *WorkflowMutation) Created() (r time.Time, exists bool) {
	v := m.created
	if v == nil {
		return
	}
	return *v, true
}

// OldCreated returns the old "created" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldCreated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreated: %w", err)
	}
	return oldValue.Created, nil
}

// ResetCreated resets all changes to the "created" field.
func (m *WorkflowMutation) ResetCreated() {
	m.created = nil
}

// SetDescription sets the "description" field.
func (m *WorkflowMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *WorkflowMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *WorkflowMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[workflow.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *WorkflowMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[workflow.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *WorkflowMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, workflow.FieldDescription)
}

// SetActive sets the "active" field.
func (m *WorkflowMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *WorkflowMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *WorkflowMutation) ResetActive() {
	m.active = nil
}

// SetRevision sets the "revision" field.
func (m *WorkflowMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *WorkflowMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *WorkflowMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *WorkflowMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *WorkflowMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetWorkflow sets the "workflow" field.
func (m *WorkflowMutation) SetWorkflow(b []byte) {
	m.workflow = &b
}

// Workflow returns the value of the "workflow" field in the mutation.
func (m *WorkflowMutation) Workflow() (r []byte, exists bool) {
	v := m.workflow
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkflow returns the old "workflow" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldWorkflow(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWorkflow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWorkflow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkflow: %w", err)
	}
	return oldValue.Workflow, nil
}

// ResetWorkflow resets all changes to the "workflow" field.
func (m *WorkflowMutation) ResetWorkflow() {
	m.workflow = nil
}

// SetLogToEvents sets the "logToEvents" field.
func (m *WorkflowMutation) SetLogToEvents(s string) {
	m.logToEvents = &s
}

// LogToEvents returns the value of the "logToEvents" field in the mutation.
func (m *WorkflowMutation) LogToEvents() (r string, exists bool) {
	v := m.logToEvents
	if v == nil {
		return
	}
	return *v, true
}

// OldLogToEvents returns the old "logToEvents" field's value of the Workflow entity.
// If the Workflow object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowMutation) OldLogToEvents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldLogToEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldLogToEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogToEvents: %w", err)
	}
	return oldValue.LogToEvents, nil
}

// ClearLogToEvents clears the value of the "logToEvents" field.
func (m *WorkflowMutation) ClearLogToEvents() {
	m.logToEvents = nil
	m.clearedFields[workflow.FieldLogToEvents] = struct{}{}
}

// LogToEventsCleared returns if the "logToEvents" field was cleared in this mutation.
func (m *WorkflowMutation) LogToEventsCleared() bool {
	_, ok := m.clearedFields[workflow.FieldLogToEvents]
	return ok
}

// ResetLogToEvents resets all changes to the "logToEvents" field.
func (m *WorkflowMutation) ResetLogToEvents() {
	m.logToEvents = nil
	delete(m.clearedFields, workflow.FieldLogToEvents)
}

// SetNamespaceID sets the "namespace" edge to the Namespace entity by id.
func (m *WorkflowMutation) SetNamespaceID(id string) {
	m.namespace = &id
}

// ClearNamespace clears the "namespace" edge to the Namespace entity.
func (m *WorkflowMutation) ClearNamespace() {
	m.clearednamespace = true
}

// NamespaceCleared reports if the "namespace" edge to the Namespace entity was cleared.
func (m *WorkflowMutation) NamespaceCleared() bool {
	return m.clearednamespace
}

// NamespaceID returns the "namespace" edge ID in the mutation.
func (m *WorkflowMutation) NamespaceID() (id string, exists bool) {
	if m.namespace != nil {
		return *m.namespace, true
	}
	return
}

// NamespaceIDs returns the "namespace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// NamespaceID instead. It exists only for internal usage by the builders.
func (m *WorkflowMutation) NamespaceIDs() (ids []string) {
	if id := m.namespace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNamespace resets all changes to the "namespace" edge.
func (m *WorkflowMutation) ResetNamespace() {
	m.namespace = nil
	m.clearednamespace = false
}

// AddInstanceIDs adds the "instances" edge to the WorkflowInstance entity by ids.
func (m *WorkflowMutation) AddInstanceIDs(ids ...int) {
	if m.instances == nil {
		m.instances = make(map[int]struct{})
	}
	for i := range ids {
		m.instances[ids[i]] = struct{}{}
	}
}

// ClearInstances clears the "instances" edge to the WorkflowInstance entity.
func (m *WorkflowMutation) ClearInstances() {
	m.clearedinstances = true
}

// InstancesCleared reports if the "instances" edge to the WorkflowInstance entity was cleared.
func (m *WorkflowMutation) InstancesCleared() bool {
	return m.clearedinstances
}

// RemoveInstanceIDs removes the "instances" edge to the WorkflowInstance entity by IDs.
func (m *WorkflowMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstances == nil {
		m.removedinstances = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.instances, ids[i])
		m.removedinstances[ids[i]] = struct{}{}
	}
}

// RemovedInstances returns the removed IDs of the "instances" edge to the WorkflowInstance entity.
func (m *WorkflowMutation) RemovedInstancesIDs() (ids []int) {
	for id := range m.removedinstances {
		ids = append(ids, id)
	}
	return
}

// InstancesIDs returns the "instances" edge IDs in the mutation.
func (m *WorkflowMutation) InstancesIDs() (ids []int) {
	for id := range m.instances {
		ids = append(ids, id)
	}
	return
}

// ResetInstances resets all changes to the "instances" edge.
func (m *WorkflowMutation) ResetInstances() {
	m.instances = nil
	m.clearedinstances = false
	m.removedinstances = nil
}

// AddWfeventIDs adds the "wfevents" edge to the WorkflowEvents entity by ids.
func (m *WorkflowMutation) AddWfeventIDs(ids ...int) {
	if m.wfevents == nil {
		m.wfevents = make(map[int]struct{})
	}
	for i := range ids {
		m.wfevents[ids[i]] = struct{}{}
	}
}

// ClearWfevents clears the "wfevents" edge to the WorkflowEvents entity.
func (m *WorkflowMutation) ClearWfevents() {
	m.clearedwfevents = true
}

// WfeventsCleared reports if the "wfevents" edge to the WorkflowEvents entity was cleared.
func (m *WorkflowMutation) WfeventsCleared() bool {
	return m.clearedwfevents
}

// RemoveWfeventIDs removes the "wfevents" edge to the WorkflowEvents entity by IDs.
func (m *WorkflowMutation) RemoveWfeventIDs(ids ...int) {
	if m.removedwfevents == nil {
		m.removedwfevents = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.wfevents, ids[i])
		m.removedwfevents[ids[i]] = struct{}{}
	}
}

// RemovedWfevents returns the removed IDs of the "wfevents" edge to the WorkflowEvents entity.
func (m *WorkflowMutation) RemovedWfeventsIDs() (ids []int) {
	for id := range m.removedwfevents {
		ids = append(ids, id)
	}
	return
}

// WfeventsIDs returns the "wfevents" edge IDs in the mutation.
func (m *WorkflowMutation) WfeventsIDs() (ids []int) {
	for id := range m.wfevents {
		ids = append(ids, id)
	}
	return
}

// ResetWfevents resets all changes to the "wfevents" edge.
func (m *WorkflowMutation) ResetWfevents() {
	m.wfevents = nil
	m.clearedwfevents = false
	m.removedwfevents = nil
}

// Where appends a list predicates to the WorkflowMutation builder.
func (m *WorkflowMutation) Where(ps ...predicate.Workflow) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkflowMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Workflow).
func (m *WorkflowMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, workflow.FieldName)
	}
	if m.created != nil {
		fields = append(fields, workflow.FieldCreated)
	}
	if m.description != nil {
		fields = append(fields, workflow.FieldDescription)
	}
	if m.active != nil {
		fields = append(fields, workflow.FieldActive)
	}
	if m.revision != nil {
		fields = append(fields, workflow.FieldRevision)
	}
	if m.workflow != nil {
		fields = append(fields, workflow.FieldWorkflow)
	}
	if m.logToEvents != nil {
		fields = append(fields, workflow.FieldLogToEvents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldName:
		return m.Name()
	case workflow.FieldCreated:
		return m.Created()
	case workflow.FieldDescription:
		return m.Description()
	case workflow.FieldActive:
		return m.Active()
	case workflow.FieldRevision:
		return m.Revision()
	case workflow.FieldWorkflow:
		return m.Workflow()
	case workflow.FieldLogToEvents:
		return m.LogToEvents()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflow.FieldName:
		return m.OldName(ctx)
	case workflow.FieldCreated:
		return m.OldCreated(ctx)
	case workflow.FieldDescription:
		return m.OldDescription(ctx)
	case workflow.FieldActive:
		return m.OldActive(ctx)
	case workflow.FieldRevision:
		return m.OldRevision(ctx)
	case workflow.FieldWorkflow:
		return m.OldWorkflow(ctx)
	case workflow.FieldLogToEvents:
		return m.OldLogToEvents(ctx)
	}
	return nil, fmt.Errorf("unknown Workflow field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workflow.FieldCreated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreated(v)
		return nil
	case workflow.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case workflow.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case workflow.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case workflow.FieldWorkflow:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkflow(v)
		return nil
	case workflow.FieldLogToEvents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogToEvents(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, workflow.FieldRevision)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflow.FieldRevision:
		return m.AddedRevision()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflow.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	}
	return fmt.Errorf("unknown Workflow numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflow.FieldDescription) {
		fields = append(fields, workflow.FieldDescription)
	}
	if m.FieldCleared(workflow.FieldLogToEvents) {
		fields = append(fields, workflow.FieldLogToEvents)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowMutation) ClearField(name string) error {
	switch name {
	case workflow.FieldDescription:
		m.ClearDescription()
		return nil
	case workflow.FieldLogToEvents:
		m.ClearLogToEvents()
		return nil
	}
	return fmt.Errorf("unknown Workflow nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowMutation) ResetField(name string) error {
	switch name {
	case workflow.FieldName:
		m.ResetName()
		return nil
	case workflow.FieldCreated:
		m.ResetCreated()
		return nil
	case workflow.FieldDescription:
		m.ResetDescription()
		return nil
	case workflow.FieldActive:
		m.ResetActive()
		return nil
	case workflow.FieldRevision:
		m.ResetRevision()
		return nil
	case workflow.FieldWorkflow:
		m.ResetWorkflow()
		return nil
	case workflow.FieldLogToEvents:
		m.ResetLogToEvents()
		return nil
	}
	return fmt.Errorf("unknown Workflow field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.namespace != nil {
		edges = append(edges, workflow.EdgeNamespace)
	}
	if m.instances != nil {
		edges = append(edges, workflow.EdgeInstances)
	}
	if m.wfevents != nil {
		edges = append(edges, workflow.EdgeWfevents)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeNamespace:
		if id := m.namespace; id != nil {
			return []ent.Value{*id}
		}
	case workflow.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.instances))
		for id := range m.instances {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeWfevents:
		ids := make([]ent.Value, 0, len(m.wfevents))
		for id := range m.wfevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedinstances != nil {
		edges = append(edges, workflow.EdgeInstances)
	}
	if m.removedwfevents != nil {
		edges = append(edges, workflow.EdgeWfevents)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflow.EdgeInstances:
		ids := make([]ent.Value, 0, len(m.removedinstances))
		for id := range m.removedinstances {
			ids = append(ids, id)
		}
		return ids
	case workflow.EdgeWfevents:
		ids := make([]ent.Value, 0, len(m.removedwfevents))
		for id := range m.removedwfevents {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearednamespace {
		edges = append(edges, workflow.EdgeNamespace)
	}
	if m.clearedinstances {
		edges = append(edges, workflow.EdgeInstances)
	}
	if m.clearedwfevents {
		edges = append(edges, workflow.EdgeWfevents)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowMutation) EdgeCleared(name string) bool {
	switch name {
	case workflow.EdgeNamespace:
		return m.clearednamespace
	case workflow.EdgeInstances:
		return m.clearedinstances
	case workflow.EdgeWfevents:
		return m.clearedwfevents
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowMutation) ClearEdge(name string) error {
	switch name {
	case workflow.EdgeNamespace:
		m.ClearNamespace()
		return nil
	}
	return fmt.Errorf("unknown Workflow unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowMutation) ResetEdge(name string) error {
	switch name {
	case workflow.EdgeNamespace:
		m.ResetNamespace()
		return nil
	case workflow.EdgeInstances:
		m.ResetInstances()
		return nil
	case workflow.EdgeWfevents:
		m.ResetWfevents()
		return nil
	}
	return fmt.Errorf("unknown Workflow edge %s", name)
}

// WorkflowEventsMutation represents an operation that mutates the WorkflowEvents nodes in the graph.
type WorkflowEventsMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	events                  *[]map[string]interface{}
	correlations            *[]string
	signature               *[]byte
	count                   *int
	addcount                *int
	clearedFields           map[string]struct{}
	workflow                *uuid.UUID
	clearedworkflow         bool
	wfeventswait            map[int]struct{}
	removedwfeventswait     map[int]struct{}
	clearedwfeventswait     bool
	workflowinstance        *int
	clearedworkflowinstance bool
	done                    bool
	oldValue                func(context.Context) (*WorkflowEvents, error)
	predicates              []predicate.WorkflowEvents
}

var _ ent.Mutation = (*WorkflowEventsMutation)(nil)

// workfloweventsOption allows management of the mutation configuration using functional options.
type workfloweventsOption func(*WorkflowEventsMutation)

// newWorkflowEventsMutation creates new mutation for the WorkflowEvents entity.
func newWorkflowEventsMutation(c config, op Op, opts ...workfloweventsOption) *WorkflowEventsMutation {
	m := &WorkflowEventsMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowEvents,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowEventsID sets the ID field of the mutation.
func withWorkflowEventsID(id int) workfloweventsOption {
	return func(m *WorkflowEventsMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowEvents
		)
		m.oldValue = func(ctx context.Context) (*WorkflowEvents, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowEvents.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowEvents sets the old WorkflowEvents of the mutation.
func withWorkflowEvents(node *WorkflowEvents) workfloweventsOption {
	return func(m *WorkflowEventsMutation) {
		m.oldValue = func(context.Context) (*WorkflowEvents, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowEventsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowEventsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowEventsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEvents sets the "events" field.
func (m *WorkflowEventsMutation) SetEvents(value []map[string]interface{}) {
	m.events = &value
}

// Events returns the value of the "events" field in the mutation.
func (m *WorkflowEventsMutation) Events() (r []map[string]interface{}, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the WorkflowEvents entity.
// If the WorkflowEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventsMutation) OldEvents(ctx context.Context) (v []map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// ResetEvents resets all changes to the "events" field.
func (m *WorkflowEventsMutation) ResetEvents() {
	m.events = nil
}

// SetCorrelations sets the "correlations" field.
func (m *WorkflowEventsMutation) SetCorrelations(s []string) {
	m.correlations = &s
}

// Correlations returns the value of the "correlations" field in the mutation.
func (m *WorkflowEventsMutation) Correlations() (r []string, exists bool) {
	v := m.correlations
	if v == nil {
		return
	}
	return *v, true
}

// OldCorrelations returns the old "correlations" field's value of the WorkflowEvents entity.
// If the WorkflowEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventsMutation) OldCorrelations(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCorrelations is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCorrelations requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCorrelations: %w", err)
	}
	return oldValue.Correlations, nil
}

// ResetCorrelations resets all changes to the "correlations" field.
func (m *WorkflowEventsMutation) ResetCorrelations() {
	m.correlations = nil
}

// SetSignature sets the "signature" field.
func (m *WorkflowEventsMutation) SetSignature(b []byte) {
	m.signature = &b
}

// Signature returns the value of the "signature" field in the mutation.
func (m *WorkflowEventsMutation) Signature() (r []byte, exists bool) {
	v := m.signature
	if v == nil {
		return
	}
	return *v, true
}

// OldSignature returns the old "signature" field's value of the WorkflowEvents entity.
// If the WorkflowEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventsMutation) OldSignature(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSignature is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSignature requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSignature: %w", err)
	}
	return oldValue.Signature, nil
}

// ClearSignature clears the value of the "signature" field.
func (m *WorkflowEventsMutation) ClearSignature() {
	m.signature = nil
	m.clearedFields[workflowevents.FieldSignature] = struct{}{}
}

// SignatureCleared returns if the "signature" field was cleared in this mutation.
func (m *WorkflowEventsMutation) SignatureCleared() bool {
	_, ok := m.clearedFields[workflowevents.FieldSignature]
	return ok
}

// ResetSignature resets all changes to the "signature" field.
func (m *WorkflowEventsMutation) ResetSignature() {
	m.signature = nil
	delete(m.clearedFields, workflowevents.FieldSignature)
}

// SetCount sets the "count" field.
func (m *WorkflowEventsMutation) SetCount(i int) {
	m.count = &i
	m.addcount = nil
}

// Count returns the value of the "count" field in the mutation.
func (m *WorkflowEventsMutation) Count() (r int, exists bool) {
	v := m.count
	if v == nil {
		return
	}
	return *v, true
}

// OldCount returns the old "count" field's value of the WorkflowEvents entity.
// If the WorkflowEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventsMutation) OldCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCount: %w", err)
	}
	return oldValue.Count, nil
}

// AddCount adds i to the "count" field.
func (m *WorkflowEventsMutation) AddCount(i int) {
	if m.addcount != nil {
		*m.addcount += i
	} else {
		m.addcount = &i
	}
}

// AddedCount returns the value that was added to the "count" field in this mutation.
func (m *WorkflowEventsMutation) AddedCount() (r int, exists bool) {
	v := m.addcount
	if v == nil {
		return
	}
	return *v, true
}

// ResetCount resets all changes to the "count" field.
func (m *WorkflowEventsMutation) ResetCount() {
	m.count = nil
	m.addcount = nil
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *WorkflowEventsMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *WorkflowEventsMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *WorkflowEventsMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *WorkflowEventsMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowEventsMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowEventsMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddWfeventswaitIDs adds the "wfeventswait" edge to the WorkflowEventsWait entity by ids.
func (m *WorkflowEventsMutation) AddWfeventswaitIDs(ids ...int) {
	if m.wfeventswait == nil {
		m.wfeventswait = make(map[int]struct{})
	}
	for i := range ids {
		m.wfeventswait[ids[i]] = struct{}{}
	}
}

// ClearWfeventswait clears the "wfeventswait" edge to the WorkflowEventsWait entity.
func (m *WorkflowEventsMutation) ClearWfeventswait() {
	m.clearedwfeventswait = true
}

// WfeventswaitCleared reports if the "wfeventswait" edge to the WorkflowEventsWait entity was cleared.
func (m *WorkflowEventsMutation) WfeventswaitCleared() bool {
	return m.clearedwfeventswait
}

// RemoveWfeventswaitIDs removes the "wfeventswait" edge to the WorkflowEventsWait entity by IDs.
func (m *WorkflowEventsMutation) RemoveWfeventswaitIDs(ids ...int) {
	if m.removedwfeventswait == nil {
		m.removedwfeventswait = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.wfeventswait, ids[i])
		m.removedwfeventswait[ids[i]] = struct{}{}
	}
}

// RemovedWfeventswait returns the removed IDs of the "wfeventswait" edge to the WorkflowEventsWait entity.
func (m *WorkflowEventsMutation) RemovedWfeventswaitIDs() (ids []int) {
	for id := range m.removedwfeventswait {
		ids = append(ids, id)
	}
	return
}

// WfeventswaitIDs returns the "wfeventswait" edge IDs in the mutation.
func (m *WorkflowEventsMutation) WfeventswaitIDs() (ids []int) {
	for id := range m.wfeventswait {
		ids = append(ids, id)
	}
	return
}

// ResetWfeventswait resets all changes to the "wfeventswait" edge.
func (m *WorkflowEventsMutation) ResetWfeventswait() {
	m.wfeventswait = nil
	m.clearedwfeventswait = false
	m.removedwfeventswait = nil
}

// SetWorkflowinstanceID sets the "workflowinstance" edge to the WorkflowInstance entity by id.
func (m *WorkflowEventsMutation) SetWorkflowinstanceID(id int) {
	m.workflowinstance = &id
}

// ClearWorkflowinstance clears the "workflowinstance" edge to the WorkflowInstance entity.
func (m *WorkflowEventsMutation) ClearWorkflowinstance() {
	m.clearedworkflowinstance = true
}

// WorkflowinstanceCleared reports if the "workflowinstance" edge to the WorkflowInstance entity was cleared.
func (m *WorkflowEventsMutation) WorkflowinstanceCleared() bool {
	return m.clearedworkflowinstance
}

// WorkflowinstanceID returns the "workflowinstance" edge ID in the mutation.
func (m *WorkflowEventsMutation) WorkflowinstanceID() (id int, exists bool) {
	if m.workflowinstance != nil {
		return *m.workflowinstance, true
	}
	return
}

// WorkflowinstanceIDs returns the "workflowinstance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowinstanceID instead. It exists only for internal usage by the builders.
func (m *WorkflowEventsMutation) WorkflowinstanceIDs() (ids []int) {
	if id := m.workflowinstance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowinstance resets all changes to the "workflowinstance" edge.
func (m *WorkflowEventsMutation) ResetWorkflowinstance() {
	m.workflowinstance = nil
	m.clearedworkflowinstance = false
}

// Where appends a list predicates to the WorkflowEventsMutation builder.
func (m *WorkflowEventsMutation) Where(ps ...predicate.WorkflowEvents) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkflowEventsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkflowEvents).
func (m *WorkflowEventsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowEventsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.events != nil {
		fields = append(fields, workflowevents.FieldEvents)
	}
	if m.correlations != nil {
		fields = append(fields, workflowevents.FieldCorrelations)
	}
	if m.signature != nil {
		fields = append(fields, workflowevents.FieldSignature)
	}
	if m.count != nil {
		fields = append(fields, workflowevents.FieldCount)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowEventsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowevents.FieldEvents:
		return m.Events()
	case workflowevents.FieldCorrelations:
		return m.Correlations()
	case workflowevents.FieldSignature:
		return m.Signature()
	case workflowevents.FieldCount:
		return m.Count()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowEventsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowevents.FieldEvents:
		return m.OldEvents(ctx)
	case workflowevents.FieldCorrelations:
		return m.OldCorrelations(ctx)
	case workflowevents.FieldSignature:
		return m.OldSignature(ctx)
	case workflowevents.FieldCount:
		return m.OldCount(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowEvents field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowEventsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowevents.FieldEvents:
		v, ok := value.([]map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	case workflowevents.FieldCorrelations:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCorrelations(v)
		return nil
	case workflowevents.FieldSignature:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSignature(v)
		return nil
	case workflowevents.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCount(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowEvents field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowEventsMutation) AddedFields() []string {
	var fields []string
	if m.addcount != nil {
		fields = append(fields, workflowevents.FieldCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowEventsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowevents.FieldCount:
		return m.AddedCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowEventsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowevents.FieldCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCount(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowEvents numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowEventsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowevents.FieldSignature) {
		fields = append(fields, workflowevents.FieldSignature)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowEventsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowEventsMutation) ClearField(name string) error {
	switch name {
	case workflowevents.FieldSignature:
		m.ClearSignature()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEvents nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowEventsMutation) ResetField(name string) error {
	switch name {
	case workflowevents.FieldEvents:
		m.ResetEvents()
		return nil
	case workflowevents.FieldCorrelations:
		m.ResetCorrelations()
		return nil
	case workflowevents.FieldSignature:
		m.ResetSignature()
		return nil
	case workflowevents.FieldCount:
		m.ResetCount()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEvents field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowEventsMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.workflow != nil {
		edges = append(edges, workflowevents.EdgeWorkflow)
	}
	if m.wfeventswait != nil {
		edges = append(edges, workflowevents.EdgeWfeventswait)
	}
	if m.workflowinstance != nil {
		edges = append(edges, workflowevents.EdgeWorkflowinstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowEventsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowevents.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case workflowevents.EdgeWfeventswait:
		ids := make([]ent.Value, 0, len(m.wfeventswait))
		for id := range m.wfeventswait {
			ids = append(ids, id)
		}
		return ids
	case workflowevents.EdgeWorkflowinstance:
		if id := m.workflowinstance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowEventsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedwfeventswait != nil {
		edges = append(edges, workflowevents.EdgeWfeventswait)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowEventsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflowevents.EdgeWfeventswait:
		ids := make([]ent.Value, 0, len(m.removedwfeventswait))
		for id := range m.removedwfeventswait {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowEventsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedworkflow {
		edges = append(edges, workflowevents.EdgeWorkflow)
	}
	if m.clearedwfeventswait {
		edges = append(edges, workflowevents.EdgeWfeventswait)
	}
	if m.clearedworkflowinstance {
		edges = append(edges, workflowevents.EdgeWorkflowinstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowEventsMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowevents.EdgeWorkflow:
		return m.clearedworkflow
	case workflowevents.EdgeWfeventswait:
		return m.clearedwfeventswait
	case workflowevents.EdgeWorkflowinstance:
		return m.clearedworkflowinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowEventsMutation) ClearEdge(name string) error {
	switch name {
	case workflowevents.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	case workflowevents.EdgeWorkflowinstance:
		m.ClearWorkflowinstance()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEvents unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowEventsMutation) ResetEdge(name string) error {
	switch name {
	case workflowevents.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case workflowevents.EdgeWfeventswait:
		m.ResetWfeventswait()
		return nil
	case workflowevents.EdgeWorkflowinstance:
		m.ResetWorkflowinstance()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEvents edge %s", name)
}

// WorkflowEventsWaitMutation represents an operation that mutates the WorkflowEventsWait nodes in the graph.
type WorkflowEventsWaitMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	events               *map[string]interface{}
	clearedFields        map[string]struct{}
	workflowevent        *int
	clearedworkflowevent bool
	done                 bool
	oldValue             func(context.Context) (*WorkflowEventsWait, error)
	predicates           []predicate.WorkflowEventsWait
}

var _ ent.Mutation = (*WorkflowEventsWaitMutation)(nil)

// workfloweventswaitOption allows management of the mutation configuration using functional options.
type workfloweventswaitOption func(*WorkflowEventsWaitMutation)

// newWorkflowEventsWaitMutation creates new mutation for the WorkflowEventsWait entity.
func newWorkflowEventsWaitMutation(c config, op Op, opts ...workfloweventswaitOption) *WorkflowEventsWaitMutation {
	m := &WorkflowEventsWaitMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowEventsWait,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowEventsWaitID sets the ID field of the mutation.
func withWorkflowEventsWaitID(id int) workfloweventswaitOption {
	return func(m *WorkflowEventsWaitMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowEventsWait
		)
		m.oldValue = func(ctx context.Context) (*WorkflowEventsWait, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowEventsWait.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowEventsWait sets the old WorkflowEventsWait of the mutation.
func withWorkflowEventsWait(node *WorkflowEventsWait) workfloweventswaitOption {
	return func(m *WorkflowEventsWaitMutation) {
		m.oldValue = func(context.Context) (*WorkflowEventsWait, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowEventsWaitMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowEventsWaitMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowEventsWaitMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEvents sets the "events" field.
func (m *WorkflowEventsWaitMutation) SetEvents(value map[string]interface{}) {
	m.events = &value
}

// Events returns the value of the "events" field in the mutation.
func (m *WorkflowEventsWaitMutation) Events() (r map[string]interface{}, exists bool) {
	v := m.events
	if v == nil {
		return
	}
	return *v, true
}

// OldEvents returns the old "events" field's value of the WorkflowEventsWait entity.
// If the WorkflowEventsWait object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowEventsWaitMutation) OldEvents(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEvents: %w", err)
	}
	return oldValue.Events, nil
}

// ResetEvents resets all changes to the "events" field.
func (m *WorkflowEventsWaitMutation) ResetEvents() {
	m.events = nil
}

// SetWorkfloweventID sets the "workflowevent" edge to the WorkflowEvents entity by id.
func (m *WorkflowEventsWaitMutation) SetWorkfloweventID(id int) {
	m.workflowevent = &id
}

// ClearWorkflowevent clears the "workflowevent" edge to the WorkflowEvents entity.
func (m *WorkflowEventsWaitMutation) ClearWorkflowevent() {
	m.clearedworkflowevent = true
}

// WorkfloweventCleared reports if the "workflowevent" edge to the WorkflowEvents entity was cleared.
func (m *WorkflowEventsWaitMutation) WorkfloweventCleared() bool {
	return m.clearedworkflowevent
}

// WorkfloweventID returns the "workflowevent" edge ID in the mutation.
func (m *WorkflowEventsWaitMutation) WorkfloweventID() (id int, exists bool) {
	if m.workflowevent != nil {
		return *m.workflowevent, true
	}
	return
}

// WorkfloweventIDs returns the "workflowevent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkfloweventID instead. It exists only for internal usage by the builders.
func (m *WorkflowEventsWaitMutation) WorkfloweventIDs() (ids []int) {
	if id := m.workflowevent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflowevent resets all changes to the "workflowevent" edge.
func (m *WorkflowEventsWaitMutation) ResetWorkflowevent() {
	m.workflowevent = nil
	m.clearedworkflowevent = false
}

// Where appends a list predicates to the WorkflowEventsWaitMutation builder.
func (m *WorkflowEventsWaitMutation) Where(ps ...predicate.WorkflowEventsWait) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkflowEventsWaitMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkflowEventsWait).
func (m *WorkflowEventsWaitMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowEventsWaitMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.events != nil {
		fields = append(fields, workfloweventswait.FieldEvents)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowEventsWaitMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workfloweventswait.FieldEvents:
		return m.Events()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowEventsWaitMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workfloweventswait.FieldEvents:
		return m.OldEvents(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowEventsWait field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowEventsWaitMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workfloweventswait.FieldEvents:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEvents(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowEventsWait field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowEventsWaitMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowEventsWaitMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowEventsWaitMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkflowEventsWait numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowEventsWaitMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowEventsWaitMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowEventsWaitMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkflowEventsWait nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowEventsWaitMutation) ResetField(name string) error {
	switch name {
	case workfloweventswait.FieldEvents:
		m.ResetEvents()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEventsWait field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowEventsWaitMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workflowevent != nil {
		edges = append(edges, workfloweventswait.EdgeWorkflowevent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowEventsWaitMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workfloweventswait.EdgeWorkflowevent:
		if id := m.workflowevent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowEventsWaitMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowEventsWaitMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowEventsWaitMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkflowevent {
		edges = append(edges, workfloweventswait.EdgeWorkflowevent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowEventsWaitMutation) EdgeCleared(name string) bool {
	switch name {
	case workfloweventswait.EdgeWorkflowevent:
		return m.clearedworkflowevent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowEventsWaitMutation) ClearEdge(name string) error {
	switch name {
	case workfloweventswait.EdgeWorkflowevent:
		m.ClearWorkflowevent()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEventsWait unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowEventsWaitMutation) ResetEdge(name string) error {
	switch name {
	case workfloweventswait.EdgeWorkflowevent:
		m.ResetWorkflowevent()
		return nil
	}
	return fmt.Errorf("unknown WorkflowEventsWait edge %s", name)
}

// WorkflowInstanceMutation represents an operation that mutates the WorkflowInstance nodes in the graph.
type WorkflowInstanceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	instanceID      *string
	invokedBy       *string
	status          *string
	revision        *int
	addrevision     *int
	beginTime       *time.Time
	endTime         *time.Time
	flow            *[]string
	input           *string
	output          *string
	stateData       *string
	memory          *string
	deadline        *time.Time
	attempts        *int
	addattempts     *int
	errorCode       *string
	errorMessage    *string
	stateBeginTime  *time.Time
	controller      *string
	clearedFields   map[string]struct{}
	workflow        *uuid.UUID
	clearedworkflow bool
	instance        map[int]struct{}
	removedinstance map[int]struct{}
	clearedinstance bool
	done            bool
	oldValue        func(context.Context) (*WorkflowInstance, error)
	predicates      []predicate.WorkflowInstance
}

var _ ent.Mutation = (*WorkflowInstanceMutation)(nil)

// workflowinstanceOption allows management of the mutation configuration using functional options.
type workflowinstanceOption func(*WorkflowInstanceMutation)

// newWorkflowInstanceMutation creates new mutation for the WorkflowInstance entity.
func newWorkflowInstanceMutation(c config, op Op, opts ...workflowinstanceOption) *WorkflowInstanceMutation {
	m := &WorkflowInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkflowInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkflowInstanceID sets the ID field of the mutation.
func withWorkflowInstanceID(id int) workflowinstanceOption {
	return func(m *WorkflowInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkflowInstance
		)
		m.oldValue = func(ctx context.Context) (*WorkflowInstance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkflowInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkflowInstance sets the old WorkflowInstance of the mutation.
func withWorkflowInstance(node *WorkflowInstance) workflowinstanceOption {
	return func(m *WorkflowInstanceMutation) {
		m.oldValue = func(context.Context) (*WorkflowInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkflowInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkflowInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkflowInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetInstanceID sets the "instanceID" field.
func (m *WorkflowInstanceMutation) SetInstanceID(s string) {
	m.instanceID = &s
}

// InstanceID returns the value of the "instanceID" field in the mutation.
func (m *WorkflowInstanceMutation) InstanceID() (r string, exists bool) {
	v := m.instanceID
	if v == nil {
		return
	}
	return *v, true
}

// OldInstanceID returns the old "instanceID" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldInstanceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInstanceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInstanceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInstanceID: %w", err)
	}
	return oldValue.InstanceID, nil
}

// ResetInstanceID resets all changes to the "instanceID" field.
func (m *WorkflowInstanceMutation) ResetInstanceID() {
	m.instanceID = nil
}

// SetInvokedBy sets the "invokedBy" field.
func (m *WorkflowInstanceMutation) SetInvokedBy(s string) {
	m.invokedBy = &s
}

// InvokedBy returns the value of the "invokedBy" field in the mutation.
func (m *WorkflowInstanceMutation) InvokedBy() (r string, exists bool) {
	v := m.invokedBy
	if v == nil {
		return
	}
	return *v, true
}

// OldInvokedBy returns the old "invokedBy" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldInvokedBy(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInvokedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInvokedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvokedBy: %w", err)
	}
	return oldValue.InvokedBy, nil
}

// ResetInvokedBy resets all changes to the "invokedBy" field.
func (m *WorkflowInstanceMutation) ResetInvokedBy() {
	m.invokedBy = nil
}

// SetStatus sets the "status" field.
func (m *WorkflowInstanceMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkflowInstanceMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkflowInstanceMutation) ResetStatus() {
	m.status = nil
}

// SetRevision sets the "revision" field.
func (m *WorkflowInstanceMutation) SetRevision(i int) {
	m.revision = &i
	m.addrevision = nil
}

// Revision returns the value of the "revision" field in the mutation.
func (m *WorkflowInstanceMutation) Revision() (r int, exists bool) {
	v := m.revision
	if v == nil {
		return
	}
	return *v, true
}

// OldRevision returns the old "revision" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldRevision(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRevision is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRevision requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRevision: %w", err)
	}
	return oldValue.Revision, nil
}

// AddRevision adds i to the "revision" field.
func (m *WorkflowInstanceMutation) AddRevision(i int) {
	if m.addrevision != nil {
		*m.addrevision += i
	} else {
		m.addrevision = &i
	}
}

// AddedRevision returns the value that was added to the "revision" field in this mutation.
func (m *WorkflowInstanceMutation) AddedRevision() (r int, exists bool) {
	v := m.addrevision
	if v == nil {
		return
	}
	return *v, true
}

// ResetRevision resets all changes to the "revision" field.
func (m *WorkflowInstanceMutation) ResetRevision() {
	m.revision = nil
	m.addrevision = nil
}

// SetBeginTime sets the "beginTime" field.
func (m *WorkflowInstanceMutation) SetBeginTime(t time.Time) {
	m.beginTime = &t
}

// BeginTime returns the value of the "beginTime" field in the mutation.
func (m *WorkflowInstanceMutation) BeginTime() (r time.Time, exists bool) {
	v := m.beginTime
	if v == nil {
		return
	}
	return *v, true
}

// OldBeginTime returns the old "beginTime" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldBeginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBeginTime: %w", err)
	}
	return oldValue.BeginTime, nil
}

// ResetBeginTime resets all changes to the "beginTime" field.
func (m *WorkflowInstanceMutation) ResetBeginTime() {
	m.beginTime = nil
}

// SetEndTime sets the "endTime" field.
func (m *WorkflowInstanceMutation) SetEndTime(t time.Time) {
	m.endTime = &t
}

// EndTime returns the value of the "endTime" field in the mutation.
func (m *WorkflowInstanceMutation) EndTime() (r time.Time, exists bool) {
	v := m.endTime
	if v == nil {
		return
	}
	return *v, true
}

// OldEndTime returns the old "endTime" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldEndTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndTime: %w", err)
	}
	return oldValue.EndTime, nil
}

// ClearEndTime clears the value of the "endTime" field.
func (m *WorkflowInstanceMutation) ClearEndTime() {
	m.endTime = nil
	m.clearedFields[workflowinstance.FieldEndTime] = struct{}{}
}

// EndTimeCleared returns if the "endTime" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) EndTimeCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldEndTime]
	return ok
}

// ResetEndTime resets all changes to the "endTime" field.
func (m *WorkflowInstanceMutation) ResetEndTime() {
	m.endTime = nil
	delete(m.clearedFields, workflowinstance.FieldEndTime)
}

// SetFlow sets the "flow" field.
func (m *WorkflowInstanceMutation) SetFlow(s []string) {
	m.flow = &s
}

// Flow returns the value of the "flow" field in the mutation.
func (m *WorkflowInstanceMutation) Flow() (r []string, exists bool) {
	v := m.flow
	if v == nil {
		return
	}
	return *v, true
}

// OldFlow returns the old "flow" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldFlow(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFlow is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFlow requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlow: %w", err)
	}
	return oldValue.Flow, nil
}

// ClearFlow clears the value of the "flow" field.
func (m *WorkflowInstanceMutation) ClearFlow() {
	m.flow = nil
	m.clearedFields[workflowinstance.FieldFlow] = struct{}{}
}

// FlowCleared returns if the "flow" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) FlowCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldFlow]
	return ok
}

// ResetFlow resets all changes to the "flow" field.
func (m *WorkflowInstanceMutation) ResetFlow() {
	m.flow = nil
	delete(m.clearedFields, workflowinstance.FieldFlow)
}

// SetInput sets the "input" field.
func (m *WorkflowInstanceMutation) SetInput(s string) {
	m.input = &s
}

// Input returns the value of the "input" field in the mutation.
func (m *WorkflowInstanceMutation) Input() (r string, exists bool) {
	v := m.input
	if v == nil {
		return
	}
	return *v, true
}

// OldInput returns the old "input" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldInput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldInput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldInput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInput: %w", err)
	}
	return oldValue.Input, nil
}

// ResetInput resets all changes to the "input" field.
func (m *WorkflowInstanceMutation) ResetInput() {
	m.input = nil
}

// SetOutput sets the "output" field.
func (m *WorkflowInstanceMutation) SetOutput(s string) {
	m.output = &s
}

// Output returns the value of the "output" field in the mutation.
func (m *WorkflowInstanceMutation) Output() (r string, exists bool) {
	v := m.output
	if v == nil {
		return
	}
	return *v, true
}

// OldOutput returns the old "output" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldOutput(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOutput is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOutput requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutput: %w", err)
	}
	return oldValue.Output, nil
}

// ClearOutput clears the value of the "output" field.
func (m *WorkflowInstanceMutation) ClearOutput() {
	m.output = nil
	m.clearedFields[workflowinstance.FieldOutput] = struct{}{}
}

// OutputCleared returns if the "output" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) OutputCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldOutput]
	return ok
}

// ResetOutput resets all changes to the "output" field.
func (m *WorkflowInstanceMutation) ResetOutput() {
	m.output = nil
	delete(m.clearedFields, workflowinstance.FieldOutput)
}

// SetStateData sets the "stateData" field.
func (m *WorkflowInstanceMutation) SetStateData(s string) {
	m.stateData = &s
}

// StateData returns the value of the "stateData" field in the mutation.
func (m *WorkflowInstanceMutation) StateData() (r string, exists bool) {
	v := m.stateData
	if v == nil {
		return
	}
	return *v, true
}

// OldStateData returns the old "stateData" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldStateData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStateData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStateData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateData: %w", err)
	}
	return oldValue.StateData, nil
}

// ClearStateData clears the value of the "stateData" field.
func (m *WorkflowInstanceMutation) ClearStateData() {
	m.stateData = nil
	m.clearedFields[workflowinstance.FieldStateData] = struct{}{}
}

// StateDataCleared returns if the "stateData" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) StateDataCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldStateData]
	return ok
}

// ResetStateData resets all changes to the "stateData" field.
func (m *WorkflowInstanceMutation) ResetStateData() {
	m.stateData = nil
	delete(m.clearedFields, workflowinstance.FieldStateData)
}

// SetMemory sets the "memory" field.
func (m *WorkflowInstanceMutation) SetMemory(s string) {
	m.memory = &s
}

// Memory returns the value of the "memory" field in the mutation.
func (m *WorkflowInstanceMutation) Memory() (r string, exists bool) {
	v := m.memory
	if v == nil {
		return
	}
	return *v, true
}

// OldMemory returns the old "memory" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldMemory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMemory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMemory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMemory: %w", err)
	}
	return oldValue.Memory, nil
}

// ClearMemory clears the value of the "memory" field.
func (m *WorkflowInstanceMutation) ClearMemory() {
	m.memory = nil
	m.clearedFields[workflowinstance.FieldMemory] = struct{}{}
}

// MemoryCleared returns if the "memory" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) MemoryCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldMemory]
	return ok
}

// ResetMemory resets all changes to the "memory" field.
func (m *WorkflowInstanceMutation) ResetMemory() {
	m.memory = nil
	delete(m.clearedFields, workflowinstance.FieldMemory)
}

// SetDeadline sets the "deadline" field.
func (m *WorkflowInstanceMutation) SetDeadline(t time.Time) {
	m.deadline = &t
}

// Deadline returns the value of the "deadline" field in the mutation.
func (m *WorkflowInstanceMutation) Deadline() (r time.Time, exists bool) {
	v := m.deadline
	if v == nil {
		return
	}
	return *v, true
}

// OldDeadline returns the old "deadline" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldDeadline(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeadline: %w", err)
	}
	return oldValue.Deadline, nil
}

// ClearDeadline clears the value of the "deadline" field.
func (m *WorkflowInstanceMutation) ClearDeadline() {
	m.deadline = nil
	m.clearedFields[workflowinstance.FieldDeadline] = struct{}{}
}

// DeadlineCleared returns if the "deadline" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) DeadlineCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldDeadline]
	return ok
}

// ResetDeadline resets all changes to the "deadline" field.
func (m *WorkflowInstanceMutation) ResetDeadline() {
	m.deadline = nil
	delete(m.clearedFields, workflowinstance.FieldDeadline)
}

// SetAttempts sets the "attempts" field.
func (m *WorkflowInstanceMutation) SetAttempts(i int) {
	m.attempts = &i
	m.addattempts = nil
}

// Attempts returns the value of the "attempts" field in the mutation.
func (m *WorkflowInstanceMutation) Attempts() (r int, exists bool) {
	v := m.attempts
	if v == nil {
		return
	}
	return *v, true
}

// OldAttempts returns the old "attempts" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldAttempts(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttempts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttempts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttempts: %w", err)
	}
	return oldValue.Attempts, nil
}

// AddAttempts adds i to the "attempts" field.
func (m *WorkflowInstanceMutation) AddAttempts(i int) {
	if m.addattempts != nil {
		*m.addattempts += i
	} else {
		m.addattempts = &i
	}
}

// AddedAttempts returns the value that was added to the "attempts" field in this mutation.
func (m *WorkflowInstanceMutation) AddedAttempts() (r int, exists bool) {
	v := m.addattempts
	if v == nil {
		return
	}
	return *v, true
}

// ClearAttempts clears the value of the "attempts" field.
func (m *WorkflowInstanceMutation) ClearAttempts() {
	m.attempts = nil
	m.addattempts = nil
	m.clearedFields[workflowinstance.FieldAttempts] = struct{}{}
}

// AttemptsCleared returns if the "attempts" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) AttemptsCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldAttempts]
	return ok
}

// ResetAttempts resets all changes to the "attempts" field.
func (m *WorkflowInstanceMutation) ResetAttempts() {
	m.attempts = nil
	m.addattempts = nil
	delete(m.clearedFields, workflowinstance.FieldAttempts)
}

// SetErrorCode sets the "errorCode" field.
func (m *WorkflowInstanceMutation) SetErrorCode(s string) {
	m.errorCode = &s
}

// ErrorCode returns the value of the "errorCode" field in the mutation.
func (m *WorkflowInstanceMutation) ErrorCode() (r string, exists bool) {
	v := m.errorCode
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorCode returns the old "errorCode" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldErrorCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldErrorCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldErrorCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorCode: %w", err)
	}
	return oldValue.ErrorCode, nil
}

// ClearErrorCode clears the value of the "errorCode" field.
func (m *WorkflowInstanceMutation) ClearErrorCode() {
	m.errorCode = nil
	m.clearedFields[workflowinstance.FieldErrorCode] = struct{}{}
}

// ErrorCodeCleared returns if the "errorCode" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) ErrorCodeCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldErrorCode]
	return ok
}

// ResetErrorCode resets all changes to the "errorCode" field.
func (m *WorkflowInstanceMutation) ResetErrorCode() {
	m.errorCode = nil
	delete(m.clearedFields, workflowinstance.FieldErrorCode)
}

// SetErrorMessage sets the "errorMessage" field.
func (m *WorkflowInstanceMutation) SetErrorMessage(s string) {
	m.errorMessage = &s
}

// ErrorMessage returns the value of the "errorMessage" field in the mutation.
func (m *WorkflowInstanceMutation) ErrorMessage() (r string, exists bool) {
	v := m.errorMessage
	if v == nil {
		return
	}
	return *v, true
}

// OldErrorMessage returns the old "errorMessage" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldErrorMessage(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldErrorMessage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldErrorMessage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldErrorMessage: %w", err)
	}
	return oldValue.ErrorMessage, nil
}

// ClearErrorMessage clears the value of the "errorMessage" field.
func (m *WorkflowInstanceMutation) ClearErrorMessage() {
	m.errorMessage = nil
	m.clearedFields[workflowinstance.FieldErrorMessage] = struct{}{}
}

// ErrorMessageCleared returns if the "errorMessage" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) ErrorMessageCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldErrorMessage]
	return ok
}

// ResetErrorMessage resets all changes to the "errorMessage" field.
func (m *WorkflowInstanceMutation) ResetErrorMessage() {
	m.errorMessage = nil
	delete(m.clearedFields, workflowinstance.FieldErrorMessage)
}

// SetStateBeginTime sets the "stateBeginTime" field.
func (m *WorkflowInstanceMutation) SetStateBeginTime(t time.Time) {
	m.stateBeginTime = &t
}

// StateBeginTime returns the value of the "stateBeginTime" field in the mutation.
func (m *WorkflowInstanceMutation) StateBeginTime() (r time.Time, exists bool) {
	v := m.stateBeginTime
	if v == nil {
		return
	}
	return *v, true
}

// OldStateBeginTime returns the old "stateBeginTime" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldStateBeginTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStateBeginTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStateBeginTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStateBeginTime: %w", err)
	}
	return oldValue.StateBeginTime, nil
}

// ClearStateBeginTime clears the value of the "stateBeginTime" field.
func (m *WorkflowInstanceMutation) ClearStateBeginTime() {
	m.stateBeginTime = nil
	m.clearedFields[workflowinstance.FieldStateBeginTime] = struct{}{}
}

// StateBeginTimeCleared returns if the "stateBeginTime" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) StateBeginTimeCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldStateBeginTime]
	return ok
}

// ResetStateBeginTime resets all changes to the "stateBeginTime" field.
func (m *WorkflowInstanceMutation) ResetStateBeginTime() {
	m.stateBeginTime = nil
	delete(m.clearedFields, workflowinstance.FieldStateBeginTime)
}

// SetController sets the "controller" field.
func (m *WorkflowInstanceMutation) SetController(s string) {
	m.controller = &s
}

// Controller returns the value of the "controller" field in the mutation.
func (m *WorkflowInstanceMutation) Controller() (r string, exists bool) {
	v := m.controller
	if v == nil {
		return
	}
	return *v, true
}

// OldController returns the old "controller" field's value of the WorkflowInstance entity.
// If the WorkflowInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkflowInstanceMutation) OldController(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldController is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldController requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldController: %w", err)
	}
	return oldValue.Controller, nil
}

// ClearController clears the value of the "controller" field.
func (m *WorkflowInstanceMutation) ClearController() {
	m.controller = nil
	m.clearedFields[workflowinstance.FieldController] = struct{}{}
}

// ControllerCleared returns if the "controller" field was cleared in this mutation.
func (m *WorkflowInstanceMutation) ControllerCleared() bool {
	_, ok := m.clearedFields[workflowinstance.FieldController]
	return ok
}

// ResetController resets all changes to the "controller" field.
func (m *WorkflowInstanceMutation) ResetController() {
	m.controller = nil
	delete(m.clearedFields, workflowinstance.FieldController)
}

// SetWorkflowID sets the "workflow" edge to the Workflow entity by id.
func (m *WorkflowInstanceMutation) SetWorkflowID(id uuid.UUID) {
	m.workflow = &id
}

// ClearWorkflow clears the "workflow" edge to the Workflow entity.
func (m *WorkflowInstanceMutation) ClearWorkflow() {
	m.clearedworkflow = true
}

// WorkflowCleared reports if the "workflow" edge to the Workflow entity was cleared.
func (m *WorkflowInstanceMutation) WorkflowCleared() bool {
	return m.clearedworkflow
}

// WorkflowID returns the "workflow" edge ID in the mutation.
func (m *WorkflowInstanceMutation) WorkflowID() (id uuid.UUID, exists bool) {
	if m.workflow != nil {
		return *m.workflow, true
	}
	return
}

// WorkflowIDs returns the "workflow" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkflowID instead. It exists only for internal usage by the builders.
func (m *WorkflowInstanceMutation) WorkflowIDs() (ids []uuid.UUID) {
	if id := m.workflow; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkflow resets all changes to the "workflow" edge.
func (m *WorkflowInstanceMutation) ResetWorkflow() {
	m.workflow = nil
	m.clearedworkflow = false
}

// AddInstanceIDs adds the "instance" edge to the WorkflowEvents entity by ids.
func (m *WorkflowInstanceMutation) AddInstanceIDs(ids ...int) {
	if m.instance == nil {
		m.instance = make(map[int]struct{})
	}
	for i := range ids {
		m.instance[ids[i]] = struct{}{}
	}
}

// ClearInstance clears the "instance" edge to the WorkflowEvents entity.
func (m *WorkflowInstanceMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared reports if the "instance" edge to the WorkflowEvents entity was cleared.
func (m *WorkflowInstanceMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// RemoveInstanceIDs removes the "instance" edge to the WorkflowEvents entity by IDs.
func (m *WorkflowInstanceMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstance == nil {
		m.removedinstance = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.instance, ids[i])
		m.removedinstance[ids[i]] = struct{}{}
	}
}

// RemovedInstance returns the removed IDs of the "instance" edge to the WorkflowEvents entity.
func (m *WorkflowInstanceMutation) RemovedInstanceIDs() (ids []int) {
	for id := range m.removedinstance {
		ids = append(ids, id)
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
func (m *WorkflowInstanceMutation) InstanceIDs() (ids []int) {
	for id := range m.instance {
		ids = append(ids, id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *WorkflowInstanceMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
	m.removedinstance = nil
}

// Where appends a list predicates to the WorkflowInstanceMutation builder.
func (m *WorkflowInstanceMutation) Where(ps ...predicate.WorkflowInstance) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *WorkflowInstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (WorkflowInstance).
func (m *WorkflowInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkflowInstanceMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.instanceID != nil {
		fields = append(fields, workflowinstance.FieldInstanceID)
	}
	if m.invokedBy != nil {
		fields = append(fields, workflowinstance.FieldInvokedBy)
	}
	if m.status != nil {
		fields = append(fields, workflowinstance.FieldStatus)
	}
	if m.revision != nil {
		fields = append(fields, workflowinstance.FieldRevision)
	}
	if m.beginTime != nil {
		fields = append(fields, workflowinstance.FieldBeginTime)
	}
	if m.endTime != nil {
		fields = append(fields, workflowinstance.FieldEndTime)
	}
	if m.flow != nil {
		fields = append(fields, workflowinstance.FieldFlow)
	}
	if m.input != nil {
		fields = append(fields, workflowinstance.FieldInput)
	}
	if m.output != nil {
		fields = append(fields, workflowinstance.FieldOutput)
	}
	if m.stateData != nil {
		fields = append(fields, workflowinstance.FieldStateData)
	}
	if m.memory != nil {
		fields = append(fields, workflowinstance.FieldMemory)
	}
	if m.deadline != nil {
		fields = append(fields, workflowinstance.FieldDeadline)
	}
	if m.attempts != nil {
		fields = append(fields, workflowinstance.FieldAttempts)
	}
	if m.errorCode != nil {
		fields = append(fields, workflowinstance.FieldErrorCode)
	}
	if m.errorMessage != nil {
		fields = append(fields, workflowinstance.FieldErrorMessage)
	}
	if m.stateBeginTime != nil {
		fields = append(fields, workflowinstance.FieldStateBeginTime)
	}
	if m.controller != nil {
		fields = append(fields, workflowinstance.FieldController)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkflowInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workflowinstance.FieldInstanceID:
		return m.InstanceID()
	case workflowinstance.FieldInvokedBy:
		return m.InvokedBy()
	case workflowinstance.FieldStatus:
		return m.Status()
	case workflowinstance.FieldRevision:
		return m.Revision()
	case workflowinstance.FieldBeginTime:
		return m.BeginTime()
	case workflowinstance.FieldEndTime:
		return m.EndTime()
	case workflowinstance.FieldFlow:
		return m.Flow()
	case workflowinstance.FieldInput:
		return m.Input()
	case workflowinstance.FieldOutput:
		return m.Output()
	case workflowinstance.FieldStateData:
		return m.StateData()
	case workflowinstance.FieldMemory:
		return m.Memory()
	case workflowinstance.FieldDeadline:
		return m.Deadline()
	case workflowinstance.FieldAttempts:
		return m.Attempts()
	case workflowinstance.FieldErrorCode:
		return m.ErrorCode()
	case workflowinstance.FieldErrorMessage:
		return m.ErrorMessage()
	case workflowinstance.FieldStateBeginTime:
		return m.StateBeginTime()
	case workflowinstance.FieldController:
		return m.Controller()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkflowInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workflowinstance.FieldInstanceID:
		return m.OldInstanceID(ctx)
	case workflowinstance.FieldInvokedBy:
		return m.OldInvokedBy(ctx)
	case workflowinstance.FieldStatus:
		return m.OldStatus(ctx)
	case workflowinstance.FieldRevision:
		return m.OldRevision(ctx)
	case workflowinstance.FieldBeginTime:
		return m.OldBeginTime(ctx)
	case workflowinstance.FieldEndTime:
		return m.OldEndTime(ctx)
	case workflowinstance.FieldFlow:
		return m.OldFlow(ctx)
	case workflowinstance.FieldInput:
		return m.OldInput(ctx)
	case workflowinstance.FieldOutput:
		return m.OldOutput(ctx)
	case workflowinstance.FieldStateData:
		return m.OldStateData(ctx)
	case workflowinstance.FieldMemory:
		return m.OldMemory(ctx)
	case workflowinstance.FieldDeadline:
		return m.OldDeadline(ctx)
	case workflowinstance.FieldAttempts:
		return m.OldAttempts(ctx)
	case workflowinstance.FieldErrorCode:
		return m.OldErrorCode(ctx)
	case workflowinstance.FieldErrorMessage:
		return m.OldErrorMessage(ctx)
	case workflowinstance.FieldStateBeginTime:
		return m.OldStateBeginTime(ctx)
	case workflowinstance.FieldController:
		return m.OldController(ctx)
	}
	return nil, fmt.Errorf("unknown WorkflowInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workflowinstance.FieldInstanceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInstanceID(v)
		return nil
	case workflowinstance.FieldInvokedBy:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvokedBy(v)
		return nil
	case workflowinstance.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workflowinstance.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRevision(v)
		return nil
	case workflowinstance.FieldBeginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBeginTime(v)
		return nil
	case workflowinstance.FieldEndTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndTime(v)
		return nil
	case workflowinstance.FieldFlow:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlow(v)
		return nil
	case workflowinstance.FieldInput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInput(v)
		return nil
	case workflowinstance.FieldOutput:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutput(v)
		return nil
	case workflowinstance.FieldStateData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateData(v)
		return nil
	case workflowinstance.FieldMemory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMemory(v)
		return nil
	case workflowinstance.FieldDeadline:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeadline(v)
		return nil
	case workflowinstance.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttempts(v)
		return nil
	case workflowinstance.FieldErrorCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorCode(v)
		return nil
	case workflowinstance.FieldErrorMessage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetErrorMessage(v)
		return nil
	case workflowinstance.FieldStateBeginTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStateBeginTime(v)
		return nil
	case workflowinstance.FieldController:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetController(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkflowInstanceMutation) AddedFields() []string {
	var fields []string
	if m.addrevision != nil {
		fields = append(fields, workflowinstance.FieldRevision)
	}
	if m.addattempts != nil {
		fields = append(fields, workflowinstance.FieldAttempts)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkflowInstanceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case workflowinstance.FieldRevision:
		return m.AddedRevision()
	case workflowinstance.FieldAttempts:
		return m.AddedAttempts()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkflowInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case workflowinstance.FieldRevision:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRevision(v)
		return nil
	case workflowinstance.FieldAttempts:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAttempts(v)
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkflowInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workflowinstance.FieldEndTime) {
		fields = append(fields, workflowinstance.FieldEndTime)
	}
	if m.FieldCleared(workflowinstance.FieldFlow) {
		fields = append(fields, workflowinstance.FieldFlow)
	}
	if m.FieldCleared(workflowinstance.FieldOutput) {
		fields = append(fields, workflowinstance.FieldOutput)
	}
	if m.FieldCleared(workflowinstance.FieldStateData) {
		fields = append(fields, workflowinstance.FieldStateData)
	}
	if m.FieldCleared(workflowinstance.FieldMemory) {
		fields = append(fields, workflowinstance.FieldMemory)
	}
	if m.FieldCleared(workflowinstance.FieldDeadline) {
		fields = append(fields, workflowinstance.FieldDeadline)
	}
	if m.FieldCleared(workflowinstance.FieldAttempts) {
		fields = append(fields, workflowinstance.FieldAttempts)
	}
	if m.FieldCleared(workflowinstance.FieldErrorCode) {
		fields = append(fields, workflowinstance.FieldErrorCode)
	}
	if m.FieldCleared(workflowinstance.FieldErrorMessage) {
		fields = append(fields, workflowinstance.FieldErrorMessage)
	}
	if m.FieldCleared(workflowinstance.FieldStateBeginTime) {
		fields = append(fields, workflowinstance.FieldStateBeginTime)
	}
	if m.FieldCleared(workflowinstance.FieldController) {
		fields = append(fields, workflowinstance.FieldController)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkflowInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkflowInstanceMutation) ClearField(name string) error {
	switch name {
	case workflowinstance.FieldEndTime:
		m.ClearEndTime()
		return nil
	case workflowinstance.FieldFlow:
		m.ClearFlow()
		return nil
	case workflowinstance.FieldOutput:
		m.ClearOutput()
		return nil
	case workflowinstance.FieldStateData:
		m.ClearStateData()
		return nil
	case workflowinstance.FieldMemory:
		m.ClearMemory()
		return nil
	case workflowinstance.FieldDeadline:
		m.ClearDeadline()
		return nil
	case workflowinstance.FieldAttempts:
		m.ClearAttempts()
		return nil
	case workflowinstance.FieldErrorCode:
		m.ClearErrorCode()
		return nil
	case workflowinstance.FieldErrorMessage:
		m.ClearErrorMessage()
		return nil
	case workflowinstance.FieldStateBeginTime:
		m.ClearStateBeginTime()
		return nil
	case workflowinstance.FieldController:
		m.ClearController()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkflowInstanceMutation) ResetField(name string) error {
	switch name {
	case workflowinstance.FieldInstanceID:
		m.ResetInstanceID()
		return nil
	case workflowinstance.FieldInvokedBy:
		m.ResetInvokedBy()
		return nil
	case workflowinstance.FieldStatus:
		m.ResetStatus()
		return nil
	case workflowinstance.FieldRevision:
		m.ResetRevision()
		return nil
	case workflowinstance.FieldBeginTime:
		m.ResetBeginTime()
		return nil
	case workflowinstance.FieldEndTime:
		m.ResetEndTime()
		return nil
	case workflowinstance.FieldFlow:
		m.ResetFlow()
		return nil
	case workflowinstance.FieldInput:
		m.ResetInput()
		return nil
	case workflowinstance.FieldOutput:
		m.ResetOutput()
		return nil
	case workflowinstance.FieldStateData:
		m.ResetStateData()
		return nil
	case workflowinstance.FieldMemory:
		m.ResetMemory()
		return nil
	case workflowinstance.FieldDeadline:
		m.ResetDeadline()
		return nil
	case workflowinstance.FieldAttempts:
		m.ResetAttempts()
		return nil
	case workflowinstance.FieldErrorCode:
		m.ResetErrorCode()
		return nil
	case workflowinstance.FieldErrorMessage:
		m.ResetErrorMessage()
		return nil
	case workflowinstance.FieldStateBeginTime:
		m.ResetStateBeginTime()
		return nil
	case workflowinstance.FieldController:
		m.ResetController()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkflowInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.workflow != nil {
		edges = append(edges, workflowinstance.EdgeWorkflow)
	}
	if m.instance != nil {
		edges = append(edges, workflowinstance.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkflowInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workflowinstance.EdgeWorkflow:
		if id := m.workflow; id != nil {
			return []ent.Value{*id}
		}
	case workflowinstance.EdgeInstance:
		ids := make([]ent.Value, 0, len(m.instance))
		for id := range m.instance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkflowInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedinstance != nil {
		edges = append(edges, workflowinstance.EdgeInstance)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkflowInstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workflowinstance.EdgeInstance:
		ids := make([]ent.Value, 0, len(m.removedinstance))
		for id := range m.removedinstance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkflowInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedworkflow {
		edges = append(edges, workflowinstance.EdgeWorkflow)
	}
	if m.clearedinstance {
		edges = append(edges, workflowinstance.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkflowInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case workflowinstance.EdgeWorkflow:
		return m.clearedworkflow
	case workflowinstance.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkflowInstanceMutation) ClearEdge(name string) error {
	switch name {
	case workflowinstance.EdgeWorkflow:
		m.ClearWorkflow()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkflowInstanceMutation) ResetEdge(name string) error {
	switch name {
	case workflowinstance.EdgeWorkflow:
		m.ResetWorkflow()
		return nil
	case workflowinstance.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown WorkflowInstance edge %s", name)
}
