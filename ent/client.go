// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"log"

	"github.com/google/uuid"
	"github.com/vorteil/direktiv/ent/migrate"

	"github.com/vorteil/direktiv/ent/namespace"
	"github.com/vorteil/direktiv/ent/server"
	"github.com/vorteil/direktiv/ent/subroutine"
	"github.com/vorteil/direktiv/ent/timer"
	"github.com/vorteil/direktiv/ent/workflow"
	"github.com/vorteil/direktiv/ent/workflowevents"
	"github.com/vorteil/direktiv/ent/workfloweventswait"
	"github.com/vorteil/direktiv/ent/workflowinstance"

	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Namespace is the client for interacting with the Namespace builders.
	Namespace *NamespaceClient
	// Server is the client for interacting with the Server builders.
	Server *ServerClient
	// Subroutine is the client for interacting with the Subroutine builders.
	Subroutine *SubroutineClient
	// Timer is the client for interacting with the Timer builders.
	Timer *TimerClient
	// Workflow is the client for interacting with the Workflow builders.
	Workflow *WorkflowClient
	// WorkflowEvents is the client for interacting with the WorkflowEvents builders.
	WorkflowEvents *WorkflowEventsClient
	// WorkflowEventsWait is the client for interacting with the WorkflowEventsWait builders.
	WorkflowEventsWait *WorkflowEventsWaitClient
	// WorkflowInstance is the client for interacting with the WorkflowInstance builders.
	WorkflowInstance *WorkflowInstanceClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	cfg := config{log: log.Println, hooks: &hooks{}}
	cfg.options(opts...)
	client := &Client{config: cfg}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Namespace = NewNamespaceClient(c.config)
	c.Server = NewServerClient(c.config)
	c.Subroutine = NewSubroutineClient(c.config)
	c.Timer = NewTimerClient(c.config)
	c.Workflow = NewWorkflowClient(c.config)
	c.WorkflowEvents = NewWorkflowEventsClient(c.config)
	c.WorkflowEventsWait = NewWorkflowEventsWaitClient(c.config)
	c.WorkflowInstance = NewWorkflowInstanceClient(c.config)
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Namespace:          NewNamespaceClient(cfg),
		Server:             NewServerClient(cfg),
		Subroutine:         NewSubroutineClient(cfg),
		Timer:              NewTimerClient(cfg),
		Workflow:           NewWorkflowClient(cfg),
		WorkflowEvents:     NewWorkflowEventsClient(cfg),
		WorkflowEventsWait: NewWorkflowEventsWaitClient(cfg),
		WorkflowInstance:   NewWorkflowInstanceClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, fmt.Errorf("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %v", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		config:             cfg,
		Namespace:          NewNamespaceClient(cfg),
		Server:             NewServerClient(cfg),
		Subroutine:         NewSubroutineClient(cfg),
		Timer:              NewTimerClient(cfg),
		Workflow:           NewWorkflowClient(cfg),
		WorkflowEvents:     NewWorkflowEventsClient(cfg),
		WorkflowEventsWait: NewWorkflowEventsWaitClient(cfg),
		WorkflowInstance:   NewWorkflowInstanceClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Namespace.
//		Query().
//		Count(ctx)
//
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	c.Namespace.Use(hooks...)
	c.Server.Use(hooks...)
	c.Subroutine.Use(hooks...)
	c.Timer.Use(hooks...)
	c.Workflow.Use(hooks...)
	c.WorkflowEvents.Use(hooks...)
	c.WorkflowEventsWait.Use(hooks...)
	c.WorkflowInstance.Use(hooks...)
}

// NamespaceClient is a client for the Namespace schema.
type NamespaceClient struct {
	config
}

// NewNamespaceClient returns a client for the Namespace from the given config.
func NewNamespaceClient(c config) *NamespaceClient {
	return &NamespaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `namespace.Hooks(f(g(h())))`.
func (c *NamespaceClient) Use(hooks ...Hook) {
	c.hooks.Namespace = append(c.hooks.Namespace, hooks...)
}

// Create returns a create builder for Namespace.
func (c *NamespaceClient) Create() *NamespaceCreate {
	mutation := newNamespaceMutation(c.config, OpCreate)
	return &NamespaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Namespace entities.
func (c *NamespaceClient) CreateBulk(builders ...*NamespaceCreate) *NamespaceCreateBulk {
	return &NamespaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Namespace.
func (c *NamespaceClient) Update() *NamespaceUpdate {
	mutation := newNamespaceMutation(c.config, OpUpdate)
	return &NamespaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *NamespaceClient) UpdateOne(n *Namespace) *NamespaceUpdateOne {
	mutation := newNamespaceMutation(c.config, OpUpdateOne, withNamespace(n))
	return &NamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *NamespaceClient) UpdateOneID(id string) *NamespaceUpdateOne {
	mutation := newNamespaceMutation(c.config, OpUpdateOne, withNamespaceID(id))
	return &NamespaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Namespace.
func (c *NamespaceClient) Delete() *NamespaceDelete {
	mutation := newNamespaceMutation(c.config, OpDelete)
	return &NamespaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *NamespaceClient) DeleteOne(n *Namespace) *NamespaceDeleteOne {
	return c.DeleteOneID(n.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *NamespaceClient) DeleteOneID(id string) *NamespaceDeleteOne {
	builder := c.Delete().Where(namespace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &NamespaceDeleteOne{builder}
}

// Query returns a query builder for Namespace.
func (c *NamespaceClient) Query() *NamespaceQuery {
	return &NamespaceQuery{config: c.config}
}

// Get returns a Namespace entity by its id.
func (c *NamespaceClient) Get(ctx context.Context, id string) (*Namespace, error) {
	return c.Query().Where(namespace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *NamespaceClient) GetX(ctx context.Context, id string) *Namespace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflows queries the workflows edge of a Namespace.
func (c *NamespaceClient) QueryWorkflows(n *Namespace) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := n.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(namespace.Table, namespace.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, namespace.WorkflowsTable, namespace.WorkflowsColumn),
		)
		fromV = sqlgraph.Neighbors(n.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *NamespaceClient) Hooks() []Hook {
	return c.hooks.Namespace
}

// ServerClient is a client for the Server schema.
type ServerClient struct {
	config
}

// NewServerClient returns a client for the Server from the given config.
func NewServerClient(c config) *ServerClient {
	return &ServerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `server.Hooks(f(g(h())))`.
func (c *ServerClient) Use(hooks ...Hook) {
	c.hooks.Server = append(c.hooks.Server, hooks...)
}

// Create returns a create builder for Server.
func (c *ServerClient) Create() *ServerCreate {
	mutation := newServerMutation(c.config, OpCreate)
	return &ServerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Server entities.
func (c *ServerClient) CreateBulk(builders ...*ServerCreate) *ServerCreateBulk {
	return &ServerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Server.
func (c *ServerClient) Update() *ServerUpdate {
	mutation := newServerMutation(c.config, OpUpdate)
	return &ServerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ServerClient) UpdateOne(s *Server) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServer(s))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ServerClient) UpdateOneID(id int) *ServerUpdateOne {
	mutation := newServerMutation(c.config, OpUpdateOne, withServerID(id))
	return &ServerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Server.
func (c *ServerClient) Delete() *ServerDelete {
	mutation := newServerMutation(c.config, OpDelete)
	return &ServerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *ServerClient) DeleteOne(s *Server) *ServerDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *ServerClient) DeleteOneID(id int) *ServerDeleteOne {
	builder := c.Delete().Where(server.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ServerDeleteOne{builder}
}

// Query returns a query builder for Server.
func (c *ServerClient) Query() *ServerQuery {
	return &ServerQuery{config: c.config}
}

// Get returns a Server entity by its id.
func (c *ServerClient) Get(ctx context.Context, id int) (*Server, error) {
	return c.Query().Where(server.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ServerClient) GetX(ctx context.Context, id int) *Server {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *ServerClient) Hooks() []Hook {
	return c.hooks.Server
}

// SubroutineClient is a client for the Subroutine schema.
type SubroutineClient struct {
	config
}

// NewSubroutineClient returns a client for the Subroutine from the given config.
func NewSubroutineClient(c config) *SubroutineClient {
	return &SubroutineClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `subroutine.Hooks(f(g(h())))`.
func (c *SubroutineClient) Use(hooks ...Hook) {
	c.hooks.Subroutine = append(c.hooks.Subroutine, hooks...)
}

// Create returns a create builder for Subroutine.
func (c *SubroutineClient) Create() *SubroutineCreate {
	mutation := newSubroutineMutation(c.config, OpCreate)
	return &SubroutineCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Subroutine entities.
func (c *SubroutineClient) CreateBulk(builders ...*SubroutineCreate) *SubroutineCreateBulk {
	return &SubroutineCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Subroutine.
func (c *SubroutineClient) Update() *SubroutineUpdate {
	mutation := newSubroutineMutation(c.config, OpUpdate)
	return &SubroutineUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SubroutineClient) UpdateOne(s *Subroutine) *SubroutineUpdateOne {
	mutation := newSubroutineMutation(c.config, OpUpdateOne, withSubroutine(s))
	return &SubroutineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SubroutineClient) UpdateOneID(id int) *SubroutineUpdateOne {
	mutation := newSubroutineMutation(c.config, OpUpdateOne, withSubroutineID(id))
	return &SubroutineUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Subroutine.
func (c *SubroutineClient) Delete() *SubroutineDelete {
	mutation := newSubroutineMutation(c.config, OpDelete)
	return &SubroutineDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *SubroutineClient) DeleteOne(s *Subroutine) *SubroutineDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *SubroutineClient) DeleteOneID(id int) *SubroutineDeleteOne {
	builder := c.Delete().Where(subroutine.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SubroutineDeleteOne{builder}
}

// Query returns a query builder for Subroutine.
func (c *SubroutineClient) Query() *SubroutineQuery {
	return &SubroutineQuery{config: c.config}
}

// Get returns a Subroutine entity by its id.
func (c *SubroutineClient) Get(ctx context.Context, id int) (*Subroutine, error) {
	return c.Query().Where(subroutine.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SubroutineClient) GetX(ctx context.Context, id int) *Subroutine {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *SubroutineClient) Hooks() []Hook {
	return c.hooks.Subroutine
}

// TimerClient is a client for the Timer schema.
type TimerClient struct {
	config
}

// NewTimerClient returns a client for the Timer from the given config.
func NewTimerClient(c config) *TimerClient {
	return &TimerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `timer.Hooks(f(g(h())))`.
func (c *TimerClient) Use(hooks ...Hook) {
	c.hooks.Timer = append(c.hooks.Timer, hooks...)
}

// Create returns a create builder for Timer.
func (c *TimerClient) Create() *TimerCreate {
	mutation := newTimerMutation(c.config, OpCreate)
	return &TimerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Timer entities.
func (c *TimerClient) CreateBulk(builders ...*TimerCreate) *TimerCreateBulk {
	return &TimerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Timer.
func (c *TimerClient) Update() *TimerUpdate {
	mutation := newTimerMutation(c.config, OpUpdate)
	return &TimerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TimerClient) UpdateOne(t *Timer) *TimerUpdateOne {
	mutation := newTimerMutation(c.config, OpUpdateOne, withTimer(t))
	return &TimerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TimerClient) UpdateOneID(id int) *TimerUpdateOne {
	mutation := newTimerMutation(c.config, OpUpdateOne, withTimerID(id))
	return &TimerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Timer.
func (c *TimerClient) Delete() *TimerDelete {
	mutation := newTimerMutation(c.config, OpDelete)
	return &TimerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *TimerClient) DeleteOne(t *Timer) *TimerDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *TimerClient) DeleteOneID(id int) *TimerDeleteOne {
	builder := c.Delete().Where(timer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TimerDeleteOne{builder}
}

// Query returns a query builder for Timer.
func (c *TimerClient) Query() *TimerQuery {
	return &TimerQuery{config: c.config}
}

// Get returns a Timer entity by its id.
func (c *TimerClient) Get(ctx context.Context, id int) (*Timer, error) {
	return c.Query().Where(timer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TimerClient) GetX(ctx context.Context, id int) *Timer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TimerClient) Hooks() []Hook {
	return c.hooks.Timer
}

// WorkflowClient is a client for the Workflow schema.
type WorkflowClient struct {
	config
}

// NewWorkflowClient returns a client for the Workflow from the given config.
func NewWorkflowClient(c config) *WorkflowClient {
	return &WorkflowClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflow.Hooks(f(g(h())))`.
func (c *WorkflowClient) Use(hooks ...Hook) {
	c.hooks.Workflow = append(c.hooks.Workflow, hooks...)
}

// Create returns a create builder for Workflow.
func (c *WorkflowClient) Create() *WorkflowCreate {
	mutation := newWorkflowMutation(c.config, OpCreate)
	return &WorkflowCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Workflow entities.
func (c *WorkflowClient) CreateBulk(builders ...*WorkflowCreate) *WorkflowCreateBulk {
	return &WorkflowCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Workflow.
func (c *WorkflowClient) Update() *WorkflowUpdate {
	mutation := newWorkflowMutation(c.config, OpUpdate)
	return &WorkflowUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowClient) UpdateOne(w *Workflow) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflow(w))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowClient) UpdateOneID(id uuid.UUID) *WorkflowUpdateOne {
	mutation := newWorkflowMutation(c.config, OpUpdateOne, withWorkflowID(id))
	return &WorkflowUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Workflow.
func (c *WorkflowClient) Delete() *WorkflowDelete {
	mutation := newWorkflowMutation(c.config, OpDelete)
	return &WorkflowDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *WorkflowClient) DeleteOne(w *Workflow) *WorkflowDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *WorkflowClient) DeleteOneID(id uuid.UUID) *WorkflowDeleteOne {
	builder := c.Delete().Where(workflow.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowDeleteOne{builder}
}

// Query returns a query builder for Workflow.
func (c *WorkflowClient) Query() *WorkflowQuery {
	return &WorkflowQuery{config: c.config}
}

// Get returns a Workflow entity by its id.
func (c *WorkflowClient) Get(ctx context.Context, id uuid.UUID) (*Workflow, error) {
	return c.Query().Where(workflow.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowClient) GetX(ctx context.Context, id uuid.UUID) *Workflow {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryNamespace queries the namespace edge of a Workflow.
func (c *WorkflowClient) QueryNamespace(w *Workflow) *NamespaceQuery {
	query := &NamespaceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(namespace.Table, namespace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflow.NamespaceTable, workflow.NamespaceColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryInstances queries the instances edge of a Workflow.
func (c *WorkflowClient) QueryInstances(w *Workflow) *WorkflowInstanceQuery {
	query := &WorkflowInstanceQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(workflowinstance.Table, workflowinstance.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.InstancesTable, workflow.InstancesColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWfevents queries the wfevents edge of a Workflow.
func (c *WorkflowClient) QueryWfevents(w *Workflow) *WorkflowEventsQuery {
	query := &WorkflowEventsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflow.Table, workflow.FieldID, id),
			sqlgraph.To(workflowevents.Table, workflowevents.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflow.WfeventsTable, workflow.WfeventsColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowClient) Hooks() []Hook {
	return c.hooks.Workflow
}

// WorkflowEventsClient is a client for the WorkflowEvents schema.
type WorkflowEventsClient struct {
	config
}

// NewWorkflowEventsClient returns a client for the WorkflowEvents from the given config.
func NewWorkflowEventsClient(c config) *WorkflowEventsClient {
	return &WorkflowEventsClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowevents.Hooks(f(g(h())))`.
func (c *WorkflowEventsClient) Use(hooks ...Hook) {
	c.hooks.WorkflowEvents = append(c.hooks.WorkflowEvents, hooks...)
}

// Create returns a create builder for WorkflowEvents.
func (c *WorkflowEventsClient) Create() *WorkflowEventsCreate {
	mutation := newWorkflowEventsMutation(c.config, OpCreate)
	return &WorkflowEventsCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowEvents entities.
func (c *WorkflowEventsClient) CreateBulk(builders ...*WorkflowEventsCreate) *WorkflowEventsCreateBulk {
	return &WorkflowEventsCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowEvents.
func (c *WorkflowEventsClient) Update() *WorkflowEventsUpdate {
	mutation := newWorkflowEventsMutation(c.config, OpUpdate)
	return &WorkflowEventsUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowEventsClient) UpdateOne(we *WorkflowEvents) *WorkflowEventsUpdateOne {
	mutation := newWorkflowEventsMutation(c.config, OpUpdateOne, withWorkflowEvents(we))
	return &WorkflowEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowEventsClient) UpdateOneID(id int) *WorkflowEventsUpdateOne {
	mutation := newWorkflowEventsMutation(c.config, OpUpdateOne, withWorkflowEventsID(id))
	return &WorkflowEventsUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowEvents.
func (c *WorkflowEventsClient) Delete() *WorkflowEventsDelete {
	mutation := newWorkflowEventsMutation(c.config, OpDelete)
	return &WorkflowEventsDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *WorkflowEventsClient) DeleteOne(we *WorkflowEvents) *WorkflowEventsDeleteOne {
	return c.DeleteOneID(we.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *WorkflowEventsClient) DeleteOneID(id int) *WorkflowEventsDeleteOne {
	builder := c.Delete().Where(workflowevents.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowEventsDeleteOne{builder}
}

// Query returns a query builder for WorkflowEvents.
func (c *WorkflowEventsClient) Query() *WorkflowEventsQuery {
	return &WorkflowEventsQuery{config: c.config}
}

// Get returns a WorkflowEvents entity by its id.
func (c *WorkflowEventsClient) Get(ctx context.Context, id int) (*WorkflowEvents, error) {
	return c.Query().Where(workflowevents.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowEventsClient) GetX(ctx context.Context, id int) *WorkflowEvents {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a WorkflowEvents.
func (c *WorkflowEventsClient) QueryWorkflow(we *WorkflowEvents) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowevents.Table, workflowevents.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowevents.WorkflowTable, workflowevents.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWfeventswait queries the wfeventswait edge of a WorkflowEvents.
func (c *WorkflowEventsClient) QueryWfeventswait(we *WorkflowEvents) *WorkflowEventsWaitQuery {
	query := &WorkflowEventsWaitQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := we.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowevents.Table, workflowevents.FieldID, id),
			sqlgraph.To(workfloweventswait.Table, workfloweventswait.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workflowevents.WfeventswaitTable, workflowevents.WfeventswaitColumn),
		)
		fromV = sqlgraph.Neighbors(we.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowEventsClient) Hooks() []Hook {
	return c.hooks.WorkflowEvents
}

// WorkflowEventsWaitClient is a client for the WorkflowEventsWait schema.
type WorkflowEventsWaitClient struct {
	config
}

// NewWorkflowEventsWaitClient returns a client for the WorkflowEventsWait from the given config.
func NewWorkflowEventsWaitClient(c config) *WorkflowEventsWaitClient {
	return &WorkflowEventsWaitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workfloweventswait.Hooks(f(g(h())))`.
func (c *WorkflowEventsWaitClient) Use(hooks ...Hook) {
	c.hooks.WorkflowEventsWait = append(c.hooks.WorkflowEventsWait, hooks...)
}

// Create returns a create builder for WorkflowEventsWait.
func (c *WorkflowEventsWaitClient) Create() *WorkflowEventsWaitCreate {
	mutation := newWorkflowEventsWaitMutation(c.config, OpCreate)
	return &WorkflowEventsWaitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowEventsWait entities.
func (c *WorkflowEventsWaitClient) CreateBulk(builders ...*WorkflowEventsWaitCreate) *WorkflowEventsWaitCreateBulk {
	return &WorkflowEventsWaitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowEventsWait.
func (c *WorkflowEventsWaitClient) Update() *WorkflowEventsWaitUpdate {
	mutation := newWorkflowEventsWaitMutation(c.config, OpUpdate)
	return &WorkflowEventsWaitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowEventsWaitClient) UpdateOne(wew *WorkflowEventsWait) *WorkflowEventsWaitUpdateOne {
	mutation := newWorkflowEventsWaitMutation(c.config, OpUpdateOne, withWorkflowEventsWait(wew))
	return &WorkflowEventsWaitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowEventsWaitClient) UpdateOneID(id int) *WorkflowEventsWaitUpdateOne {
	mutation := newWorkflowEventsWaitMutation(c.config, OpUpdateOne, withWorkflowEventsWaitID(id))
	return &WorkflowEventsWaitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowEventsWait.
func (c *WorkflowEventsWaitClient) Delete() *WorkflowEventsWaitDelete {
	mutation := newWorkflowEventsWaitMutation(c.config, OpDelete)
	return &WorkflowEventsWaitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *WorkflowEventsWaitClient) DeleteOne(wew *WorkflowEventsWait) *WorkflowEventsWaitDeleteOne {
	return c.DeleteOneID(wew.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *WorkflowEventsWaitClient) DeleteOneID(id int) *WorkflowEventsWaitDeleteOne {
	builder := c.Delete().Where(workfloweventswait.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowEventsWaitDeleteOne{builder}
}

// Query returns a query builder for WorkflowEventsWait.
func (c *WorkflowEventsWaitClient) Query() *WorkflowEventsWaitQuery {
	return &WorkflowEventsWaitQuery{config: c.config}
}

// Get returns a WorkflowEventsWait entity by its id.
func (c *WorkflowEventsWaitClient) Get(ctx context.Context, id int) (*WorkflowEventsWait, error) {
	return c.Query().Where(workfloweventswait.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowEventsWaitClient) GetX(ctx context.Context, id int) *WorkflowEventsWait {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflowevent queries the workflowevent edge of a WorkflowEventsWait.
func (c *WorkflowEventsWaitClient) QueryWorkflowevent(wew *WorkflowEventsWait) *WorkflowEventsQuery {
	query := &WorkflowEventsQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := wew.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workfloweventswait.Table, workfloweventswait.FieldID, id),
			sqlgraph.To(workflowevents.Table, workflowevents.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workfloweventswait.WorkfloweventTable, workfloweventswait.WorkfloweventColumn),
		)
		fromV = sqlgraph.Neighbors(wew.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowEventsWaitClient) Hooks() []Hook {
	return c.hooks.WorkflowEventsWait
}

// WorkflowInstanceClient is a client for the WorkflowInstance schema.
type WorkflowInstanceClient struct {
	config
}

// NewWorkflowInstanceClient returns a client for the WorkflowInstance from the given config.
func NewWorkflowInstanceClient(c config) *WorkflowInstanceClient {
	return &WorkflowInstanceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workflowinstance.Hooks(f(g(h())))`.
func (c *WorkflowInstanceClient) Use(hooks ...Hook) {
	c.hooks.WorkflowInstance = append(c.hooks.WorkflowInstance, hooks...)
}

// Create returns a create builder for WorkflowInstance.
func (c *WorkflowInstanceClient) Create() *WorkflowInstanceCreate {
	mutation := newWorkflowInstanceMutation(c.config, OpCreate)
	return &WorkflowInstanceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkflowInstance entities.
func (c *WorkflowInstanceClient) CreateBulk(builders ...*WorkflowInstanceCreate) *WorkflowInstanceCreateBulk {
	return &WorkflowInstanceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkflowInstance.
func (c *WorkflowInstanceClient) Update() *WorkflowInstanceUpdate {
	mutation := newWorkflowInstanceMutation(c.config, OpUpdate)
	return &WorkflowInstanceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkflowInstanceClient) UpdateOne(wi *WorkflowInstance) *WorkflowInstanceUpdateOne {
	mutation := newWorkflowInstanceMutation(c.config, OpUpdateOne, withWorkflowInstance(wi))
	return &WorkflowInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkflowInstanceClient) UpdateOneID(id int) *WorkflowInstanceUpdateOne {
	mutation := newWorkflowInstanceMutation(c.config, OpUpdateOne, withWorkflowInstanceID(id))
	return &WorkflowInstanceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkflowInstance.
func (c *WorkflowInstanceClient) Delete() *WorkflowInstanceDelete {
	mutation := newWorkflowInstanceMutation(c.config, OpDelete)
	return &WorkflowInstanceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a delete builder for the given entity.
func (c *WorkflowInstanceClient) DeleteOne(wi *WorkflowInstance) *WorkflowInstanceDeleteOne {
	return c.DeleteOneID(wi.ID)
}

// DeleteOneID returns a delete builder for the given id.
func (c *WorkflowInstanceClient) DeleteOneID(id int) *WorkflowInstanceDeleteOne {
	builder := c.Delete().Where(workflowinstance.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkflowInstanceDeleteOne{builder}
}

// Query returns a query builder for WorkflowInstance.
func (c *WorkflowInstanceClient) Query() *WorkflowInstanceQuery {
	return &WorkflowInstanceQuery{config: c.config}
}

// Get returns a WorkflowInstance entity by its id.
func (c *WorkflowInstanceClient) Get(ctx context.Context, id int) (*WorkflowInstance, error) {
	return c.Query().Where(workflowinstance.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkflowInstanceClient) GetX(ctx context.Context, id int) *WorkflowInstance {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkflow queries the workflow edge of a WorkflowInstance.
func (c *WorkflowInstanceClient) QueryWorkflow(wi *WorkflowInstance) *WorkflowQuery {
	query := &WorkflowQuery{config: c.config}
	query.path = func(ctx context.Context) (fromV *sql.Selector, _ error) {
		id := wi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workflowinstance.Table, workflowinstance.FieldID, id),
			sqlgraph.To(workflow.Table, workflow.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workflowinstance.WorkflowTable, workflowinstance.WorkflowColumn),
		)
		fromV = sqlgraph.Neighbors(wi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkflowInstanceClient) Hooks() []Hook {
	return c.hooks.WorkflowInstance
}
